{"version":3,"file":"useBem.mjs","sources":["../../../../node_modules/lodash/kebabCase.js","../../src/composables/useBem.ts"],"sourcesContent":["var createCompounder = require('./_createCompounder');\n\n/**\n * Converts `string` to\n * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the kebab cased string.\n * @example\n *\n * _.kebabCase('Foo Bar');\n * // => 'foo-bar'\n *\n * _.kebabCase('fooBar');\n * // => 'foo-bar'\n *\n * _.kebabCase('__FOO_BAR__');\n * // => 'foo-bar'\n */\nvar kebabCase = createCompounder(function(result, word, index) {\n  return result + (index ? '-' : '') + word.toLowerCase();\n});\n\nmodule.exports = kebabCase;\n","import { computed, Ref, unref, ComputedRef } from 'vue'\n\nimport isFunction from 'lodash/isFunction.js'\nimport kebab from 'lodash/kebabCase.js'\n\nimport { __DEV__ } from '../utils/global-utils'\n\ntype Key<Prefix extends string, ModifierKey extends string> = `${Prefix}--${ModifierKey | string}`\n\ntype ClassesObject<Key extends string> = Record<Key, boolean>\n\ntype ComputedClasses<Key extends string> = ClassesObject<Key> & {\n  // TODO: How to remove it from spread?\n  readonly asObject: ComputedRef<ClassesObject<Key>>\n  readonly asArray: ComputedRef<Key[]>\n  readonly asString: ComputedRef<string>\n}\n\n/**\n * @description creates BEM modifiers based on transferred prefix (base BEM class) & modifiers list.\n * camelCase modifiers names will be transformed to the kebab-case.\n * @param prefix string that classes start with (base BEM class).\n * @param modifiers list of options that will serve as state BEM modifiers.\n * @returns computed classes starting with \"prefix\" and ending with form state BEM modifier.\n * @example\n *  const result = useBem('va-component', computed(() => pick(props, ['success, noError'])))\n *  // if success & noError are `true`\n *  { ...result }: { 'va-component--success': true, va-component--no-error: true }\n *  result.asObject.value: { 'va-component--success': true, va-component--no-error: true }\n *  result.asArray.value: ['va-component--success', 'va-component--no-error']\n *  result.asString.value: 'va-component--success va-component--no-error'\n */\nexport const useBem = <ModifierKey extends string, Prefix extends string>(\n  prefix: Prefix,\n  modifiers: Record<ModifierKey, boolean> | Ref<Record<ModifierKey, boolean>> | (() => Record<ModifierKey, boolean>),\n) => {\n  if (__DEV__ && !prefix) {\n    console.warn('You must pass the @param \"prefix\" to the useBem hook!')\n  }\n\n  const modifiersList = computed(() => isFunction(modifiers) ? modifiers() : unref(modifiers))\n\n  const computedBemClassesObject = computed(() => {\n    return Object\n      .entries(unref(modifiersList))\n      .reduce((classesObj: Record<string, boolean>, [modifierName, value]) => {\n        if (value) { classesObj[`${prefix}--${kebab(modifierName)}`] = true }\n        return classesObj\n      }, {})\n  })\n\n  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value))\n\n  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(' '))\n\n  return new Proxy({}, {\n    ownKeys () {\n      return Reflect.ownKeys(computedBemClassesObject.value)\n    },\n    getOwnPropertyDescriptor (_, key) {\n      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key)\n    },\n    get (_, key: string, receiver: any) {\n      switch (key) {\n        case 'asArray':\n          return computedBemClassesArray\n        case 'asString':\n          return computedBemClassesString\n        case 'asObject':\n          return computedBemClassesObject\n        default:\n          return Reflect.get(computedBemClassesObject.value, key, receiver)\n      }\n    },\n  }) as ComputedClasses<Key<Prefix, ModifierKey>>\n}\n"],"names":["kebabCase_1","require$$0","result","word","index","toLowerCase","useBem","prefix","modifiers","__DEV__","console","warn","modifiersList","computed","isFunction","unref","computedBemClassesObject","Object","entries","reduce","classesObj","modifierName","value","kebab","computedBemClassesArray","keys","computedBemClassesString","join","Proxy","ownKeys","Reflect","getOwnPropertyDescriptor","_","key","get","receiver"],"mappings":"qKAAA,IA2BAA,EA3BuBC,GAuBU,SAASC,EAAQC,EAAMC,GACtD,OAAOF,GAAUE,EAAQ,IAAM,IAAMD,EAAKE,uBCQ/BC,OAAS,CACpBC,EACAC,KAEIC,IAAYF,GACdG,QAAQC,KAAK,yDAGf,MAAMC,EAAgBC,GAAS,IAAMC,EAAWN,GAAaA,IAAcO,EAAMP,KAE3EQ,EAA2BH,GAAS,IACjCI,OACJC,QAAQH,EAAMH,IACdO,QAAO,CAACC,GAAsCC,EAAcC,MACvDA,IAASF,EAAW,GAAGb,MAAWgB,EAAMF,OAAmB,GACxDD,IACN,MAGDI,EAA0BX,GAAS,IAAMI,OAAOQ,KAAKT,EAAyBM,SAE9EI,EAA2Bb,GAAS,IAAMW,EAAwBF,MAAMK,KAAK,OAEnF,OAAO,IAAIC,MAAM,GAAI,CACnBC,QAAO,IACEC,QAAQD,QAAQb,EAAyBM,OAElDS,yBAAwB,CAAEC,EAAGC,IACpBH,QAAQC,yBAAyBf,EAAyBM,MAAOW,GAE1EC,IAAKF,EAAGC,EAAaE,GACnB,OAAQF,GACN,IAAK,UACH,OAAOT,EACT,IAAK,WACH,OAAOE,EACT,IAAK,WACH,OAAOV,EACT,QACE,OAAOc,QAAQI,IAAIlB,EAAyBM,MAAOW,EAAKE"}