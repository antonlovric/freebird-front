{"version":3,"file":"index2.mjs","sources":["../../../../node_modules/lodash/noop.js","../../../../node_modules/lodash/throttle.js","../../src/components/va-affix/VaAffix-utils.ts","../../src/components/va-affix/VaAffix.vue","../../src/components/va-affix/VaAffix.vue?vue&type=template&id=c9e05218&lang.js","../../src/components/va-affix/index.ts"],"sourcesContent":["/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","import throttle from 'lodash/throttle.js'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: HTMLElement | undefined;\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: DOMRect | undefined;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  if (!element) { return }\n\n  const isInitialCall = !eventName\n  const coordinates = element.getBoundingClientRect()\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  const nextState = isInitialCall && initialPosition\n    ? computeAffixedState({ coordinates: initialPosition, ...options })\n    : computeAffixedState({ coordinates, ...options })\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, nextTick, onMounted, onBeforeUnmount, shallowRef } from 'vue'\nimport noop from 'lodash/noop.js'\n\nimport { getWindow } from '../../utils/ssr-utils'\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number, default: undefined },\n    offsetBottom: { type: Number, default: undefined },\n    target: { type: [Object, Function] as PropType<HTMLElement | Window | (() => HTMLElement | Window)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state = ref<State>({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }))\n\n    const initialPosition = ref<DOMRect>()\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n\n    onMounted(() => {\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      const events = ['scroll', 'resize']\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    onBeforeUnmount(clearEventListeners)\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, nextTick, onMounted, onBeforeUnmount, shallowRef } from 'vue'\nimport noop from 'lodash/noop.js'\n\nimport { getWindow } from '../../utils/ssr-utils'\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number, default: undefined },\n    offsetBottom: { type: Number, default: undefined },\n    target: { type: [Object, Function] as PropType<HTMLElement | Window | (() => HTMLElement | Window)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state = ref<State>({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }))\n\n    const initialPosition = ref<DOMRect>()\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n\n    onMounted(() => {\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      const events = ['scroll', 'resize']\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    onBeforeUnmount(clearEventListeners)\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport _VaAffix from './VaAffix.vue'\n\nexport const VaAffix = withConfigTransport(_VaAffix)\n"],"names":["noop_1","noop","debounce","require$$0","isObject","require$$1","throttle_1","throttle","func","wait","options","leading","trailing","TypeError","maxWait","getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","isInitialCall","nextState","prevState","checkAffixedStateChange","currentState","width","useCaptureDefault","script","defineComponent","name","emits","props","type","Number","default","undefined","Object","Function","getWindow","setup","emit","shallowRef","getTargetElement","isAffixed","computed","state","value","ref","newState","calculateTop","Window","calculateBottom","borderTopWidth","borderBottomWidth","getComputedStyle","offsetHeight","scrollBarHeight","parseInt","convertToPixels","calculate","result","computedClass","computedStyle","throttledEventHandler","event","clearEventListeners","onMounted","_a","useEventsHandlerWithThrottle","events","handler","useCapture","clearHandlersArray","map","_handler","addEventListener","removeEventListener","forEach","clear","nextTick","onBeforeUnmount","class","_openBlock","_createElementBlock","_hoisted_1","_createElementVNode","style","_ctx","_renderSlot","$slots","VaAffix","withConfigTransport","_VaAffix"],"mappings":"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"}