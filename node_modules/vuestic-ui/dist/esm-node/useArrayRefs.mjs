import{onBeforeUpdate as e}from"vue";function makeMap(e,t){const r=Object.create(null),n=e.split(",");for(let e=0;e<n.length;e++)r[n[e]]=!0;return t?e=>!!r[e.toLowerCase()]:e=>!!r[e]}"production"===process.env.NODE_ENV||Object.freeze({}),"production"===process.env.NODE_ENV||Object.freeze([]);const t=Object.assign,r=Object.prototype.hasOwnProperty,hasOwn=(e,t)=>r.call(e,t),n=Array.isArray,isMap=e=>"[object Map]"===toTypeString(e),isSymbol=e=>"symbol"==typeof e,isObject=e=>null!==e&&"object"==typeof e,a=Object.prototype.toString,toTypeString=e=>a.call(e),toRawType=e=>toTypeString(e).slice(8,-1),isIntegerKey=e=>"string"==typeof e&&"NaN"!==e&&"-"!==e[0]&&""+parseInt(e,10)===e,o=(e=>{const t=Object.create(null);return r=>t[r]||(t[r]=e(r))})((e=>e.charAt(0).toUpperCase()+e.slice(1))),hasChanged=(e,t)=>!Object.is(e,t);function warn(e,...t){console.warn(`[Vue warn] ${e}`,...t)}const createDep=e=>{const t=new Set(e);return t.w=0,t.n=0,t},s=new WeakMap;const c=Symbol("production"!==process.env.NODE_ENV?"iterate":""),i=Symbol("production"!==process.env.NODE_ENV?"Map key iterate":"");let l=!0;const u=[];function track(e,t,r){0}function trigger(e,t,r,a,o,l){const u=s.get(e);if(!u)return;let f=[];if("clear"===t)f=[...u.values()];else if("length"===r&&n(e))u.forEach(((e,t)=>{("length"===t||t>=a)&&f.push(e)}));else switch(void 0!==r&&f.push(u.get(r)),t){case"add":n(e)?isIntegerKey(r)&&f.push(u.get("length")):(f.push(u.get(c)),isMap(e)&&f.push(u.get(i)));break;case"delete":n(e)||(f.push(u.get(c)),isMap(e)&&f.push(u.get(i)));break;case"set":isMap(e)&&f.push(u.get(c))}const d="production"!==process.env.NODE_ENV?{target:e,type:t,key:r,newValue:a,oldValue:o,oldTarget:l}:void 0;if(1===f.length)f[0]&&("production"!==process.env.NODE_ENV?triggerEffects(f[0],d):triggerEffects(f[0]));else{const e=[];for(const t of f)t&&e.push(...t);"production"!==process.env.NODE_ENV?triggerEffects(createDep(e),d):triggerEffects(createDep(e))}}function triggerEffects(e,r){for(const a of n(e)?e:[...e])(undefined!==a||a.allowRecurse)&&("production"!==process.env.NODE_ENV&&a.onTrigger&&a.onTrigger(t({effect:a},r)),a.scheduler?a.scheduler():a.run())}const f=makeMap("__proto__,__v_isRef,__isVue"),d=new Set(Object.getOwnPropertyNames(Symbol).map((e=>Symbol[e])).filter(isSymbol)),h=createGetter(),p=createGetter(!0),g=createArrayInstrumentations();function createArrayInstrumentations(){const e={};return["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const r=toRaw(this);for(let e=0,t=this.length;e<t;e++)track();const n=r[t](...e);return-1===n||!1===n?r[t](...e.map(toRaw)):n}})),["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){!function pauseTracking(){u.push(l),l=!1}();const r=toRaw(this)[t].apply(this,e);return function resetTracking(){const e=u.pop();l=void 0===e||e}(),r}})),e}function createGetter(e=!1,t=!1){return function get(r,a,o){if("__v_isReactive"===a)return!e;if("__v_isReadonly"===a)return e;if("__v_isShallow"===a)return t;if("__v_raw"===a&&o===(e?t?M:m:t?O:N).get(r))return r;const s=n(r);if(!e&&s&&hasOwn(g,a))return Reflect.get(g,a,o);const c=Reflect.get(r,a,o);if(isSymbol(a)?d.has(a):f(a))return c;if(e||track(),t)return c;if(isRef(c)){return!s||!isIntegerKey(a)?c.value:c}return isObject(c)?e?readonly(c):reactive(c):c}}function createSetter(e=!1){return function set(t,r,a,o){let s=t[r];if(isReadonly(s)&&isRef(s)&&!isRef(a))return!1;if(!e&&!isReadonly(a)&&(function isShallow(e){return!(!e||!e.__v_isShallow)}(a)||(a=toRaw(a),s=toRaw(s)),!n(t)&&isRef(s)&&!isRef(a)))return s.value=a,!0;const c=n(t)&&isIntegerKey(r)?Number(r)<t.length:hasOwn(t,r),i=Reflect.set(t,r,a,o);return t===toRaw(o)&&(c?hasChanged(a,s)&&trigger(t,"set",r,a,s):trigger(t,"add",r,a)),i}}const _={get:h,set:createSetter(),deleteProperty:function deleteProperty(e,t){const r=hasOwn(e,t),n=e[t],a=Reflect.deleteProperty(e,t);return a&&r&&trigger(e,"delete",t,void 0,n),a},has:function has(e,t){const r=Reflect.has(e,t);return isSymbol(t)&&d.has(t)||track(),r},ownKeys:function ownKeys(e){return track(0,0,n(e)),Reflect.ownKeys(e)}},v={get:p,set:(e,t)=>("production"!==process.env.NODE_ENV&&warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e),!0),deleteProperty:(e,t)=>("production"!==process.env.NODE_ENV&&warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e),!0)},toShallow=e=>e,getProto=e=>Reflect.getPrototypeOf(e);function get$1(e,t,r=!1,n=!1){const a=toRaw(e=e.__v_raw),o=toRaw(t);t!==o&&!r&&track(),!r&&track();const{has:s}=getProto(a),c=n?toShallow:r?toReadonly:toReactive;return s.call(a,t)?c(e.get(t)):s.call(a,o)?c(e.get(o)):void(e!==a&&e.get(t))}function has$1(e,t=!1){const r=this.__v_raw,n=(toRaw(r),toRaw(e));return e!==n&&!t&&track(),!t&&track(),e===n?r.has(e):r.has(e)||r.has(n)}function size(e,t=!1){return e=e.__v_raw,!t&&track(toRaw(e)),Reflect.get(e,"size",e)}function add(e){e=toRaw(e);const t=toRaw(this);return getProto(t).has.call(t,e)||(t.add(e),trigger(t,"add",e,e)),this}function set$1(e,t){t=toRaw(t);const r=toRaw(this),{has:n,get:a}=getProto(r);let o=n.call(r,e);o?"production"!==process.env.NODE_ENV&&checkIdentityKeys(r,n,e):(e=toRaw(e),o=n.call(r,e));const s=a.call(r,e);return r.set(e,t),o?hasChanged(t,s)&&trigger(r,"set",e,t,s):trigger(r,"add",e,t),this}function deleteEntry(e){const t=toRaw(this),{has:r,get:n}=getProto(t);let a=r.call(t,e);a?"production"!==process.env.NODE_ENV&&checkIdentityKeys(t,r,e):(e=toRaw(e),a=r.call(t,e));const o=n?n.call(t,e):void 0,s=t.delete(e);return a&&trigger(t,"delete",e,void 0,o),s}function clear(){const e=toRaw(this),t=0!==e.size,r="production"!==process.env.NODE_ENV?isMap(e)?new Map(e):new Set(e):void 0,n=e.clear();return t&&trigger(e,"clear",void 0,void 0,r),n}function createForEach(e,t){return function forEach(r,n){const a=this,o=a.__v_raw,s=(toRaw(o),t?toShallow:e?toReadonly:toReactive);return!e&&track(),o.forEach(((e,t)=>r.call(n,s(e),s(t),a)))}}function createIterableMethod(e,t,r){return function(...n){const a=this.__v_raw,o=toRaw(a),s=isMap(o),c="entries"===e||e===Symbol.iterator&&s,i=a[e](...n),l=r?toShallow:t?toReadonly:toReactive;return!t&&track(),{next(){const{value:e,done:t}=i.next();return t?{value:e,done:t}:{value:c?[l(e[0]),l(e[1])]:l(e),done:t}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(e){return function(...t){if("production"!==process.env.NODE_ENV){const r=t[0]?`on key "${t[0]}" `:"";console.warn(`${o(e)} operation ${r}failed: target is readonly.`,toRaw(this))}return"delete"!==e&&this}}function createInstrumentations(){const e={get(e){return get$1(this,e)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!1)},t={get(e){return get$1(this,e,!1,!0)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!0)},r={get(e){return get$1(this,e,!0)},get size(){return size(this,!0)},has(e){return has$1.call(this,e,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!1)},n={get(e){return get$1(this,e,!0,!0)},get size(){return size(this,!0)},has(e){return has$1.call(this,e,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach((a=>{e[a]=createIterableMethod(a,!1,!1),r[a]=createIterableMethod(a,!0,!1),t[a]=createIterableMethod(a,!1,!0),n[a]=createIterableMethod(a,!0,!0)})),[e,r,t,n]}const[w,R,y,E]=createInstrumentations();function createInstrumentationGetter(e,t){const r=t?e?E:y:e?R:w;return(t,n,a)=>"__v_isReactive"===n?!e:"__v_isReadonly"===n?e:"__v_raw"===n?t:Reflect.get(hasOwn(r,n)&&n in t?r:t,n,a)}const b={get:createInstrumentationGetter(!1,!1)},k={get:createInstrumentationGetter(!0,!1)};function checkIdentityKeys(e,t,r){const n=toRaw(r);if(n!==r&&t.call(e,n)){const t=toRawType(e);console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map"===t?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const N=new WeakMap,O=new WeakMap,m=new WeakMap,M=new WeakMap;function reactive(e){return isReadonly(e)?e:createReactiveObject(e,!1,_,b,N)}function readonly(e){return createReactiveObject(e,!0,v,k,m)}function createReactiveObject(e,t,r,n,a){if(!isObject(e))return"production"!==process.env.NODE_ENV&&console.warn(`value cannot be made reactive: ${String(e)}`),e;if(e.__v_raw&&(!t||!e.__v_isReactive))return e;const o=a.get(e);if(o)return o;const s=function getTargetType(e){return e.__v_skip||!Object.isExtensible(e)?0:function targetTypeMap(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}(toRawType(e))}(e);if(0===s)return e;const c=new Proxy(e,2===s?n:r);return a.set(e,c),c}function isReadonly(e){return!(!e||!e.__v_isReadonly)}function toRaw(e){const t=e&&e.__v_raw;return t?toRaw(t):e}const toReactive=e=>isObject(e)?reactive(e):e,toReadonly=e=>isObject(e)?readonly(e):e;function isRef(e){return!(!e||!0!==e.__v_isRef)}function shallowRef(e){return function createRef(e,t){if(isRef(e))return e;return new RefImpl(e,t)}(e,!0)}class RefImpl{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:toRaw(e),this._value=t?e:toReactive(e)}get value(){return this._value}set value(e){e=this.__v_isShallow?e:toRaw(e),hasChanged(e,this._rawValue)&&(this._rawValue=e,this._value=this.__v_isShallow?e:toReactive(e),function triggerRefValue(e,t){(e=toRaw(e)).dep&&("production"!==process.env.NODE_ENV?triggerEffects(e.dep,{target:e,type:"set",key:"value",newValue:t}):triggerEffects(e.dep))}(this,e))}}const useArrayRefs=()=>{const t=shallowRef([]);return e((()=>{t.value=[]})),{itemRefs:t,setItemRef:e=>{e&&t.value.push(e)},setItemRefByIndex:e=>r=>{r&&(t.value[e]=r)}}};export{useArrayRefs as u};
//# sourceMappingURL=useArrayRefs.mjs.map
