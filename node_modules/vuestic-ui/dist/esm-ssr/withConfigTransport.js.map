{"version":3,"file":"withConfigTransport.js","sources":["../../src/services/component-config/component-config.ts","../../src/services/config-transport/createProxyComponent.ts","../../src/services/config-transport/withConfigTransport.ts"],"sourcesContent":["import { useLocalConfig } from '../../components/va-config/VaConfig'\nimport { useGlobalConfig } from '../global-config/global-config'\nimport { computed } from 'vue'\nimport type { VuesticComponentsMap } from '../../vuestic-plugin/global-components'\nimport type { DefineComponent, VNodeProps, AllowedComponentProps } from 'vue'\n\ntype VuesticComponentName = keyof VuesticComponentsMap\ntype VueDefaultPropNames = keyof (VNodeProps & AllowedComponentProps) | `on${string}`\n\nexport type PropTypes<C> = C extends { new(): { $props: infer Props } } ? Omit<Props, VueDefaultPropNames> : never\nexport type ComponentConfig = {\n  // key-value hack to avoid generics in type (like Omit, PropTypes, etc.)\n  // `key: type` as result\n  [componentName in VuesticComponentName]?: {\n    [key in keyof PropTypes<VuesticComponentsMap[componentName]>]: PropTypes<VuesticComponentsMap[componentName]>[key]\n  }\n}\n\nexport const useComponentConfigProps = <T extends DefineComponent>(component: T) => {\n  const localConfig = useLocalConfig()\n  const { globalConfig } = useGlobalConfig()\n\n  return computed(() => {\n    const globalConfigProps = {\n      ...globalConfig.value.componentsAll,\n      ...globalConfig.value.components?.[component.name as VuesticComponentName],\n    }\n\n    const localConfigProps = localConfig.value\n      .reduce((finalConfig, config) => config[component.name as VuesticComponentName]\n        ? { ...finalConfig, ...config[component.name as VuesticComponentName] }\n        : finalConfig\n      , {})\n\n    const props = { ...globalConfigProps, ...localConfigProps }\n\n    return props\n  })\n}\n\nexport type Props = Record<string, any>\n","import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly } from 'vue'\nimport { useComponentConfigProps } from '../component-config/component-config'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incommingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value[key]\n\n      // Return prop from config only if user didn't pass props manually\n      if (incommingProps[key] === undefined && propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\n/**\n * Patch instance props with Proxy.\n * This will change props object during render and in Devtools.\n */\nconst patchInstanceProps = (instance: ComponentInternalInstance, props: Props) => {\n  instance.props = props\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component)\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n\n    patchInstanceProps(instance, props)\n\n    return component.setup?.(shallowReadonly(props), ctx)\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n","import { ComponentPublicInstance, DefineComponent } from 'vue'\nimport { createProxyComponent } from './createProxyComponent'\n\ntype WithConfigTransport<T> = T\n\nconst CLASS_COMPONENT_KEY = '__c'\n\nconst patchClassComponent = (component: { [CLASS_COMPONENT_KEY]: any }): any => {\n  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY])\n  return component\n}\n\n/** Allows props to be passed from vuestic config if they were not provided */\nexport const withConfigTransport = <T>(component: T): WithConfigTransport<T> => {\n  if ('setup' in component) {\n    return createProxyComponent(component as any)\n  } else if (CLASS_COMPONENT_KEY in component) {\n    // TODO: Remove this. We don't want to use class components\n    return patchClassComponent(component as any)\n  } else {\n    // Options api. We need to transform it to Composition API and then create proxy.\n    (component as any).setup = () => ({ /* Fake setup function */})\n    return createProxyComponent(component as any)\n  }\n}\n\nexport default withConfigTransport\n"],"names":["createProxyComponent","component","customSetup","originalProps","ctx","instance","getCurrentInstance","propsFromConfig","localConfig","useLocalConfig","globalConfig","useGlobalConfig","computed","value","componentsAll","_a","components","name","reduce","finalConfig","config","useComponentConfigProps","props","instanceProps","Proxy","get","target","key","incommingProps","vnode","originalProp","propFromConfig","undefined","createPropsWithCustomConfig","patchInstanceProps","setup","call","shallowReadonly","withConfigTransport","patchClassComponent"],"mappings":"qJAkBO,MCoCMA,qBAAmDC,IAC9D,MAAMC,YAAc,CAACC,EAAsBC,WACzC,MAAMC,EAAWC,IACXC,EDvC6B,CAA4BN,IACjE,MAAMO,EAAcC,KACdC,aAAEA,GAAiBC,IAEzB,OAAOC,GAAS,WAcd,MAFc,IAXY,IACrBF,EAAaG,MAAMC,iBACa,QAAhCC,EAAAL,EAAaG,MAAMG,kBAAa,IAAAD,OAAA,EAAAA,EAAAd,EAAUgB,UAGtBT,EAAYK,MAClCK,QAAO,CAACC,EAAaC,IAAWA,EAAOnB,EAAUgB,MAC9C,IAAKE,KAAgBC,EAAOnB,EAAUgB,OACtCE,GACF,SCyBoBE,CAAwBpB,GAE1CqB,EA/C0B,EAACjB,EAAqCE,KAKxE,MAAMgB,EAAuBlB,EAASiB,MAEtC,OAAO,IAAIE,MAAMD,EAAe,CAC9BE,IAAK,CAACC,EAAQC,KAKZ,MAAMC,EAA2BvB,EAASwB,MAAMP,OAAS,GAQnDQ,EAAeJ,EAAOC,GACtBI,EAAiBxB,EAAgBM,MAAMc,GAG7C,YAA4BK,IAAxBJ,EAAeD,SAAyCK,IAAnBD,EAChCA,EAGFD,MAkBKG,CAA4B5B,EAAUE,GAIpD,MAbuB,EAACF,EAAqCiB,KAC/DjB,EAASiB,MAAQA,GAUfY,CAAmB7B,EAAUiB,GAEJ,QAAlBP,EAAAd,EAAUkC,aAAQ,IAAApB,OAAA,EAAAA,EAAAqB,KAAAnC,EAAAoC,EAAgBf,GAAQlB,IAGnD,OAAO,IAAIoB,MAAMvB,EAAW,CAC1BwB,IAAG,CAAEC,EAAQC,IACC,UAARA,EAA0BzB,YAEvBwB,EAAOC,MCzDPW,oBAA0BrC,GACjC,UAAWA,EACND,qBAAqBC,GAVJ,QAWQA,EATR,CAACA,IAC3BA,EAA6B,IAAID,qBAAqBC,EAA6B,KAC5EA,GASEsC,CAAoBtC,IAG1BA,EAAkBkC,MAAQ,KAAO,IAC3BnC,qBAAqBC"}