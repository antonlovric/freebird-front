{"version":3,"file":"useAccordion.js","sources":["../../src/components/va-accordion/hooks/useAccordion.ts"],"sourcesContent":["import { computed, inject, onBeforeUnmount, onMounted, provide, Ref, ref, watch, WritableComputedRef } from 'vue'\n\nexport const AccordionServiceKey = Symbol('AccordionService')\n\nexport interface AccordionItemProps {\n  inset?: boolean,\n  popout?: boolean\n}\n\nexport interface AccordionProps extends AccordionItemProps {\n  modelValue: boolean[],\n  multiply: boolean,\n}\n\nexport interface AccordionItem {\n  state: WritableComputedRef<boolean>\n}\n\nexport interface AccordionInject {\n  onItemMounted: (item: AccordionItem) => void,\n  onItemUnmounted: (item: AccordionItem) => void,\n  onItemChanged: (changedItem: AccordionItem) => void,\n  props: Ref<AccordionItemProps>,\n}\n\n/**\n * @param props\n * @param state array of states of all accordion items */\nexport const useAccordion = (props: AccordionProps, state: WritableComputedRef<boolean[]>) => {\n  /** @notice items are reactive because they have reactive `state` inside */\n  let items: AccordionItem[] = []\n\n  const onItemMounted = (item: AccordionItem) => { items.push(item) }\n  const onItemUnmounted = (item: AccordionItem) => { items = items.filter((i) => i !== item) }\n  const onItemChanged = (changedItem: AccordionItem) => {\n    state.value = items\n      .map((item: AccordionItem) => {\n        if (item === changedItem) {\n          return item.state.value\n        }\n\n        if (!props.multiply) {\n          item.state.value = false\n        }\n\n        return item.state.value\n      })\n  }\n\n  provide(AccordionServiceKey, {\n    isInsideAccordion: true,\n    onItemMounted,\n    onItemUnmounted,\n    onItemChanged,\n    props: computed(() => props),\n  })\n\n  const updateItemStates = () => {\n    items.forEach((item: AccordionItem, index: number) => {\n      item.state.value = state.value[index]\n    })\n  }\n\n  onMounted(updateItemStates)\n  watch(state, updateItemStates)\n\n  return { items }\n}\n\n/**\n * Hook used in items that should react on VaAccordion changes\n * @param state shows if accordion item is open\n */\nexport const useAccordionItem = (state: WritableComputedRef<boolean>) => {\n  const accordion = inject<AccordionInject>(AccordionServiceKey, {\n    props: ref({ inset: undefined, popout: undefined }),\n    onItemChanged: () => undefined,\n    onItemMounted: () => undefined,\n    onItemUnmounted: () => undefined,\n  })\n\n  const item = { state }\n\n  onMounted(() => accordion.onItemMounted(item))\n  onBeforeUnmount(() => accordion.onItemUnmounted(item))\n\n  return {\n    accordionProps: accordion.props,\n\n    toggle: () => {\n      /** Toggle collapse value and notify accordion about it */\n      state.value = !state.value\n      accordion.onItemChanged(item)\n    },\n  }\n}\n"],"names":["AccordionServiceKey","Symbol","useAccordion","props","state","items","provide","isInsideAccordion","onItemMounted","item","push","onItemUnmounted","filter","i","onItemChanged","changedItem","value","map","multiply","computed","updateItemStates","forEach","index","onMounted","watch","useAccordionItem","accordion","inject","ref","inset","undefined","popout","onBeforeUnmount","accordionProps","toggle"],"mappings":"gHAEO,MAAMA,EAAsBC,OAAO,oBA0B7BC,aAAe,CAACC,EAAuBC,KAElD,IAAIC,EAAyB,GAmB7BC,EAAQN,EAAqB,CAC3BO,mBAAmB,EACnBC,cAnBqBC,IAA0BJ,EAAMK,KAAKD,IAoB1DE,gBAnBuBF,IAA0BJ,EAAQA,EAAMO,QAAQC,GAAMA,IAAMJ,KAoBnFK,cAnBqBC,IACrBX,EAAMY,MAAQX,EACXY,KAAKR,IACAA,IAASM,GAIRZ,EAAMe,WACTT,EAAKL,MAAMY,OAAQ,GAJZP,EAAKL,MAAMY,UAgBxBb,MAAOgB,GAAS,IAAMhB,MAGxB,MAAMiB,iBAAmB,KACvBf,EAAMgB,SAAQ,CAACZ,EAAqBa,KAClCb,EAAKL,MAAMY,MAAQZ,EAAMY,MAAMM,OAOnC,OAHAC,EAAUH,kBACVI,EAAMpB,EAAOgB,kBAEN,CAAEf,MAAAA,IAOEoB,iBAAoBrB,IAC/B,MAAMsB,EAAYC,EAAwB3B,EAAqB,CAC7DG,MAAOyB,EAAI,CAAEC,WAAOC,EAAWC,YAAQD,IACvChB,cAAe,OACfN,cAAe,OACfG,gBAAiB,SAGbF,EAAO,CAAEL,MAAAA,GAKf,OAHAmB,GAAU,IAAMG,EAAUlB,cAAcC,KACxCuB,GAAgB,IAAMN,EAAUf,gBAAgBF,KAEzC,CACLwB,eAAgBP,EAAUvB,MAE1B+B,OAAQ,KAEN9B,EAAMY,OAASZ,EAAMY,MACrBU,EAAUZ,cAAcL"}