{"version":3,"file":"index33.js","sources":["../../src/components/va-infinite-scroll/VaInfiniteScroll.vue","../../src/components/va-infinite-scroll/hooks/useScroll.ts","../../src/components/va-infinite-scroll/VaInfiniteScroll.vue?vue&type=template&id=b399cd12&lang.js","../../src/components/va-infinite-scroll/index.ts"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag\"\n    ref=\"element\"\n    role=\"feed\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    :aria-busy=\"fetching\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      ref=\"spinnerSlotContainer\"\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n    >\n      <slot\n        v-if=\"!$props.disabled\"\n        name=\"loading\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, shallowRef, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nimport { sleep } from '../../services/utils'\nimport { useColors } from '../../composables'\nimport { useScroll } from './hooks/useScroll'\n\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [String, Object] as PropType<string | HTMLElement>, default: undefined },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n    const spinnerSlotContainer = shallowRef<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { getColor } = useColors()\n\n    const spinnerColor = computed(() => {\n      return error.value ? getColor('danger') : getColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import { Ref, onMounted, onBeforeUnmount } from 'vue'\n\ninterface ScrollTargetProps {\n  scrollTarget: HTMLElement | string | undefined;\n  disabled: boolean;\n  reverse: boolean;\n}\n\nexport const useScroll = (\n  props: ScrollTargetProps,\n  element: Ref<HTMLElement | undefined>,\n  handler: Ref<any>,\n) => {\n  const addScrollListener = () => {\n    element.value?.addEventListener(\n      'scroll',\n      handler.value,\n      { passive: true },\n    )\n  }\n\n  const removeScrollListener = () => {\n    element.value?.removeEventListener(\n      'scroll',\n      handler.value,\n    )\n  }\n\n  onMounted(() => {\n    if (!element.value) { return }\n\n    element.value.style.overflowY = 'scroll'\n\n    if (props.reverse) {\n      element.value.scrollTop = element.value.scrollHeight\n    }\n\n    addScrollListener()\n  })\n\n  onBeforeUnmount(removeScrollListener)\n\n  return {\n    addScrollListener,\n    removeScrollListener,\n  }\n}\n","<template>\n  <component\n    :is=\"$props.tag\"\n    ref=\"element\"\n    role=\"feed\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    :aria-busy=\"fetching\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      ref=\"spinnerSlotContainer\"\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n    >\n      <slot\n        v-if=\"!$props.disabled\"\n        name=\"loading\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, shallowRef, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nimport { sleep } from '../../services/utils'\nimport { useColors } from '../../composables'\nimport { useScroll } from './hooks/useScroll'\n\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [String, Object] as PropType<string | HTMLElement>, default: undefined },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n    const spinnerSlotContainer = shallowRef<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { getColor } = useColors()\n\n    const spinnerColor = computed(() => {\n      return error.value ? getColor('danger') : getColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport _VaInfiniteScroll from './VaInfiniteScroll.vue'\n\nexport const VaInfiniteScroll = withConfigTransport(_VaInfiniteScroll)\n"],"names":["script","defineComponent","name","components","VaProgressCircle","props","load","type","Function","required","offset","Number","default","reverse","Boolean","disabled","scrollTarget","String","Object","undefined","debounce","tag","emits","setup","emit","element","shallowRef","spinnerSlotContainer","fetching","ref","error","forcedScrolling","debouncedLoad","notScrolledContentBeforeLoad","prevScrollTop","scrollTargetElement","computed","target","document","querySelector","_a","value","parentElement","body","addScrollListener","removeScrollListener","handler","addEventListener","passive","removeEventListener","onMounted","style","overflowY","scrollTop","scrollHeight","onBeforeUnmount","useScroll","getColor","useColors","spinnerColor","spinnerHeight","offsetHeight","computedOffset","stop","resume","onLoad","clientHeight","scrollDelta","then","finishLoading","catch","onError","forceSetScrollTopToTarget","updateTargetElementScrollTop","isScrolledUp","isSpinnerHidden","stopErrorDisplay","sleep","watch","immediate","_ssrRenderVNode","_push","_createVNode","_resolveDynamicComponent","_ctx","$props","_mergeProps","role","class","_","_parent","_scopeId","_renderSlot","$slots","_component_va_progress_circle","size","thickness","color","indeterminate","VaInfiniteScroll","withConfigTransport","_VaInfiniteScroll"],"mappings":"g0BA2CA,IAAAA,EAAeC,EAAgB,CAC7BC,KAAM,mBAENC,WAAY,CAAEC,iBAAAA,GAEdC,MAAO,CACLC,KAAM,CAAEC,KAAMC,SAAUC,UAAU,GAClCC,OAAQ,CAAEH,KAAMI,OAAQC,QAAS,KACjCC,QAAS,CAAEN,KAAMO,QAASF,SAAS,GACnCG,SAAU,CAAER,KAAMO,QAASF,SAAS,GACpCI,aAAc,CAAET,KAAM,CAACU,OAAQC,QAA2CN,aAASO,GACnFC,SAAU,CAAEb,KAAMI,OAAQC,QAAS,KACnCS,IAAK,CAAEd,KAAMU,OAAQL,QAAS,QAGhCU,MAAO,CAAC,SAAU,WAElBC,MAAOlB,GAAOmB,KAAEA,IACd,MAAMC,EAAUC,IACVC,EAAuBD,IAEvBE,EAAWC,GAAI,GACfC,EAAQD,GAAI,GACZE,EAAkBF,GAAI,GACtBG,EAAgBH,IAChBI,EAA+BJ,EAAI,GACnCK,EAAgBL,EAAI,GAEpBM,EAAsBC,GAAsB,WAChD,IAAIC,EAQJ,OALEA,EADgC,iBAAvBhC,EAAMW,aACNsB,SAASC,cAAclC,EAAMW,cAE7BX,EAAMW,eAA6B,QAAbwB,EAAAf,EAAQgB,aAAK,IAAAD,OAAA,EAAAA,EAAEE,eAGxCL,GAAUC,SAASK,SAGvBC,kBACJA,EAAiBC,qBACjBA,GC7EmB,EACvBxC,EACAoB,EACAqB,KAEA,MAAMF,kBAAoB,mBACxBJ,EAAAf,EAAQgB,sBAAOM,iBACb,SACAD,EAAQL,MACR,CAAEO,SAAS,KAITH,qBAAuB,WACd,QAAbL,EAAAf,EAAQgB,aAAK,IAAAD,GAAAA,EAAES,oBACb,SACAH,EAAQL,QAkBZ,OAdAS,GAAU,KACHzB,EAAQgB,QAEbhB,EAAQgB,MAAMU,MAAMC,UAAY,SAE5B/C,EAAMQ,UACRY,EAAQgB,MAAMY,UAAY5B,EAAQgB,MAAMa,cAG1CV,wBAGFW,EAAgBV,sBAET,CACLD,kBAAAA,kBACAC,qBAAAA,uBD0CIW,CAAUnD,EAAO8B,EAAqBH,IAEpCyB,SAAEA,GAAaC,IAEfC,EAAevB,GAAS,IACrBN,EAAMW,MAAQgB,EAAS,UAAYA,EAAS,aAG/CG,EAAgBxB,GAAS,WAC7B,OAAmC,UAA5BT,EAAqBc,aAAO,IAAAD,OAAA,EAAAA,EAAAqB,eAAgB,KAG/CC,EAAiB1B,GAAS,IACvB/B,EAAMK,OAASkD,EAAcnB,QAGhCsB,KAAO,KACP1D,EAAMU,WAEVa,EAASa,OAAQ,EACjBI,MAGImB,OAAS,KACT3D,EAAMU,UAEV6B,KAGIqB,OAAS,KACb,MAAMZ,UAAEA,EAASC,aAAEA,EAAYY,aAAEA,GAAiB/B,EAAoBM,MACtER,EAA6BQ,MAAQa,EAAeD,EACpD,MAAMc,EAAcd,EAAYnB,EAAcO,MAG9C,GAFAP,EAAcO,MAAQY,EAElBhD,EAAMU,UAAYe,EAAMW,OAASb,EAASa,MAAS,OAEvD,GAAIV,EAAgBU,MAElB,YADAV,EAAgBU,OAAQ,GAK1B,GADkCpC,EAAMQ,SAAWsD,EAAc,IAAQ9D,EAAMQ,SAAWsD,EAAc,EACxE,QAEjB9D,EAAMQ,QAAUwC,EAAYC,EAAeD,EAAYa,GACzDJ,EAAerB,QAE5Bb,EAASa,OAAQ,EAEjBpC,EAAMC,OACH8D,KAAKC,eACLC,MAAMC,WAGLC,0BAA6B/B,IACjCV,EAAgBU,OAAQ,EACxBN,EAAoBM,MAAMY,UAAYZ,GAGlCgC,6BAA+B,KACnC,MAAMpB,UAAEA,EAASC,aAAEA,EAAYY,aAAEA,GAAiB/B,EAAoBM,MAEtE,GAAIpC,EAAMQ,QAAS,CACjB,MAAM6D,EAAepB,EAAeD,EAAYpB,EAA6BQ,MACvEkC,EAAkBtB,GAAaO,EAAcnB,MAEnD,GAAIiC,GAAgBC,EAAmB,OAEtCrB,EAAerB,EAA6BQ,MAAQmB,EAAcnB,MAC/D+B,0BAA0BlB,EAAerB,EAA6BQ,OACtE+B,0BAA0BZ,EAAcnB,OAG9C,IAAKpC,EAAMQ,QAAS,GACMyC,EAAeD,EAAYa,GAAgBN,EAAcnB,QAC7D+B,0BAA0BlB,EAAeY,EAAeN,EAAcnB,SAIxF4B,cAAgB,KACpBI,+BACA7C,EAASa,OAAQ,EACjBjB,EAAK,WAGDoD,iBAAmB,KACvBH,+BACA1C,EAAgBU,OAAQ,EACxBX,EAAMW,OAAQ,EACdb,EAASa,OAAQ,EACjBjB,EAAK,YAGD+C,QAAU,KACdR,OACAjC,EAAMW,OAAQ,EAEdoC,EAAM,MACHT,KAAKQ,kBACLR,KAAKJ,SAWV,OARAc,GAAM,IAAMzE,EAAMe,WAAWqB,IAC3BT,EAAcS,MAAQrB,EAAS6C,OAAQxB,KACtC,CAAEsC,WAAW,IAEhBD,GAAM,IAAMzE,EAAMU,WAAW0B,IAC3BA,EAAQsB,OAASC,YAGZ,CACLvC,QAAAA,EACAE,qBAAAA,EAEAgC,aAAAA,EACA/B,SAAAA,sFExMGoD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,OAAOhE,KAAGiE,EAAA,CACfzD,IAAI,UACJ0D,KAAK,OACLC,MAAM,CAAA,qBACoC,CAAA,+BAAAJ,EAAAC,OAAOxE,UAChD,YAAWuE,EAAQxD,yBANtB,CA6BW6D,EAAAR,EAAAS,EAAAC,kBArBTC,EAAsBR,EAAAS,OAAA,WAEtBX,EAkBK,MAAA,CAjBHrD,IAAI,uBACJ2D,MAAK,CAAC,8BAA4B,CAAA,0CACmBJ,EAAOxD,aAGnDwD,EAAAC,OAAOtE,sBADhB6E,EAYMR,4BAZN,IAYM,CARJF,EAOK,MAAA,CAPAM,MAAM,wCAAsC,CAC/CN,EAKCY,EAAA,CAJCC,KAAK,QACJC,UAAW,IACXC,MAAOb,EAAYzB,aACpBuC,cAAA,+IAX+Cd,EAAOxD,UAAA,yCAGnDwD,EAAAC,OAAOtE,6HAKVgF,KAAK,QACJC,UAAW,IACXC,MAAOb,EAAYzB,aACpBuC,cAAA,qICtBCC,EAAmBC,EAAoBC"}