import { w as withConfigTransport } from './withConfigTransport.js';
import { ref, computed, getCurrentInstance, defineComponent, shallowRef, watch, resolveComponent, openBlock, createElementBlock, withKeys, renderSlot, createVNode, normalizeStyle, toDisplayString, normalizeClass, createElementVNode, Fragment, renderList, createBlock, mergeProps, createSlots, withCtx, createCommentVNode } from 'vue';
import { e as extractComponentProps, f as filterComponentProps } from './child-props.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import 'colortranslator';
import { u as useFormProps, a as useForm } from './useForm.js';
import { c as clamp_1 } from './clamp.js';
import { u as useHover } from './useHover.js';
import { a as useStatefulProps, b as useStateful } from './useStateful.js';
import { u as useColors } from './useColors.js';
import { u as useSyncProp } from './useSyncProp.js';
import { VaIcon } from './index31.js';
import { u as useSizeProps, a as useSize } from './useSize.js';
import './VaConfig.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './useBem.js';
import './_createCompounder.js';
import './toNumber.js';
import './VaIcon.js';

var RatingValue;
(function (RatingValue) {
    RatingValue[RatingValue["EMPTY"] = 0] = "EMPTY";
    RatingValue[RatingValue["HALF"] = 0.5] = "HALF";
    RatingValue[RatingValue["FULL"] = 1] = "FULL";
})(RatingValue || (RatingValue = {}));

const getContext = () => {
    const instance = getCurrentInstance();
    if (!instance) {
        throw new Error('useRating hooks must be used on top of setup function');
    }
    return {
        props: instance.props,
        emit: instance.emit,
    };
};
const useRatingProps = {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    clearable: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
};
const useRating = (props) => {
    const { emit } = getContext();
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { valueComputed: modelValue } = useStateful(props, emit);
    const hoveredValue = ref(0);
    const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
    const onItemValueUpdate = (itemIndex, newValue) => {
        const newModelValue = itemIndex + newValue;
        if (props.clearable) {
            if (modelValue.value === newModelValue) {
                modelValue.value = 0;
                return;
            }
        }
        modelValue.value = newModelValue;
    };
    const onItemHoveredValueUpdate = (itemIndex, newValue) => {
        if (!props.hover) {
            return;
        }
        hoveredValue.value = itemIndex + newValue;
    };
    const getItemValue = (itemIndex) => {
        const itemValue = visibleValue.value - itemIndex;
        return clamp_1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
    };
    return {
        visibleValue,
        modelValue,
        hoveredValue,
        isHovered,
        onMouseEnter,
        onMouseLeave,
        onItemValueUpdate,
        onItemHoveredValueUpdate,
        getItemValue,
    };
};

const useVaRatingColorsProps = {
    unselectedColor: { type: String },
    color: { type: String, default: 'primary' },
    modelValue: { type: Number },
};
const useVaRatingColors = (props) => {
    const { getColor, getFocusColor, getTextColor } = useColors();
    const computedColor = computed(() => getColor(props.color));
    const backgroundColor = computed(() => {
        if (props.unselectedColor) {
            return getColor(props.unselectedColor);
        }
        return getFocusColor(getColor(props.color));
    });
    const backgroundComputed = computed(() => {
        if (props.modelValue === RatingValue.HALF) {
            return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
        }
        if (props.modelValue === RatingValue.EMPTY) {
            return backgroundColor.value;
        }
        return computedColor.value;
    });
    const textColorComputed = computed(() => {
        if (props.modelValue === RatingValue.FULL) {
            return getTextColor(computedColor.value);
        }
        return getTextColor(backgroundColor.value);
    });
    return {
        computedColor,
        backgroundComputed,
        textColorComputed,
    };
};

var script$2 = defineComponent({
    name: 'VaRatingItem',
    components: { VaIcon },
    props: {
        modelValue: { type: Number, default: 0 },
        icon: { type: String, default: 'star' },
        halfIcon: { type: String, default: 'star_half' },
        emptyIcon: { type: String, default: 'star_outline' },
        halves: { type: Boolean, default: false },
        hover: { type: Boolean, default: false },
        tabindex: { type: Number, default: 0 },
        disabled: { type: Boolean, default: false },
        readonly: { type: Boolean, default: false },
        size: { type: [String, Number], default: 'medium' },
        unselectedColor: { type: String },
        color: { type: String, default: 'primary' },
    },
    emits: ['update:modelValue', 'click', 'hover'],
    setup(props, { emit }) {
        const rootEl = shallowRef();
        const [modelValue] = useSyncProp('modelValue', props, emit, RatingValue.EMPTY);
        const hoveredValue = ref(null);
        const visibleValue = computed(() => {
            if (props.hover && !props.disabled && !props.readonly) {
                return hoveredValue.value || modelValue.value;
            }
            return modelValue.value;
        });
        const { getColor } = useColors();
        const computedColor = computed(() => getColor(props.unselectedColor && visibleValue.value === RatingValue.EMPTY
            ? props.unselectedColor
            : props.color));
        const onMouseMove = (ev) => {
            if (!rootEl.value) {
                return;
            }
            const { offsetX } = ev;
            const iconWidth = rootEl.value.clientWidth;
            if (props.halves) {
                hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
            }
            else {
                hoveredValue.value = RatingValue.FULL;
            }
        };
        const onMouseLeave = () => {
            hoveredValue.value = null;
        };
        const onEnter = () => {
            modelValue.value = 1;
        };
        const onClick = () => {
            modelValue.value = hoveredValue.value || RatingValue.FULL;
            emit('click', hoveredValue.value || RatingValue.FULL);
        };
        watch(hoveredValue, () => emit('hover', hoveredValue.value || RatingValue.EMPTY));
        return {
            computedColor,
            rootEl,
            onEnter,
            onClick,
            onMouseMove,
            onMouseLeave,
            visibleValue,
            computedIconName: computed(() => {
                if (props.halves && visibleValue.value === RatingValue.HALF) {
                    return props.halfIcon;
                }
                if (visibleValue.value === RatingValue.EMPTY) {
                    return props.emptyIcon;
                }
                return props.icon;
            }),
            tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex),
        };
    },
});

const _hoisted_1$1 = ["tabindex"];

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");

  return (openBlock(), createElementBlock("div", {
    ref: "rootEl",
    class: "va-rating-item",
    role: "button",
    tabindex: _ctx.tabIndexComputed,
    onKeyup: [
      _cache[0] || (_cache[0] = withKeys((...args) => (_ctx.onClick && _ctx.onClick(...args)), ["enter"])),
      _cache[1] || (_cache[1] = withKeys((...args) => (_ctx.onClick && _ctx.onClick(...args)), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => (_ctx.onMouseMove && _ctx.onMouseMove(...args))),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => (_ctx.onMouseLeave && _ctx.onMouseLeave(...args)))
  }, [
    renderSlot(_ctx.$slots, "default", {
      props: { value: _ctx.visibleValue, onClick: _ctx.onClick }
    }, () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor,
        onClick: _ctx.onClick
      }, null, 8 /* PROPS */, ["name", "size", "color", "onClick"])
    ])
  ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$1))
}

script$2.render = render$2;
script$2.__file = "src/components/va-rating/components/VaRatingItem/VaRatingItem.vue";

var script$1 = defineComponent({
    name: 'VaRatingItemNumberButton',
    props: {
        ...useVaRatingColorsProps,
        ...useSizeProps,
        itemNumber: { type: Number, required: true },
        modelValue: { type: Number, required: true },
    },
    setup(props) {
        return {
            ...useVaRatingColors(props),
            ...useSize(props, 'VaRating'),
        };
    },
});

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`,
    })
  }, toDisplayString(_ctx.itemNumber), 5 /* TEXT, STYLE */))
}

script$1.render = render$1;
script$1.__file = "src/components/va-rating/components/VaRatingItemNumberButton.vue";

const VaRatingItemProps = extractComponentProps(script$2);
const VaRatingItemNumberButtonProps = extractComponentProps(script$1, ['modelValue', 'itemNumber']);
var script = defineComponent({
    name: 'VaRating',
    props: {
        ...useRatingProps,
        ...useVaRatingColorsProps,
        ...useFormProps,
        ...VaRatingItemProps,
        ...VaRatingItemNumberButtonProps,
        numbers: { type: Boolean, default: false },
        halves: { type: Boolean, default: false },
        max: { type: Number, default: 5 },
        texts: { type: Array, default: () => [] },
    },
    emits: ['update:modelValue'],
    components: { VaRatingItem: script$2, VaRatingItemNumberButton: script$1 },
    setup(props) {
        const { computedClasses: rootClass } = useForm('va-rating', props);
        const rating = useRating(props);
        const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
        return {
            ...useVaRatingColors(props),
            ...rating,
            rootClass,
            VaRatingItemProps: filterComponentProps(props, VaRatingItemProps),
            VaRatingItemNumberButtonProps: filterComponentProps(props, VaRatingItemNumberButtonProps),
            isInteractionsEnabled,
            tabIndexComputed: computed(() => isInteractionsEnabled.value ? 0 : undefined),
            onArrowKeyPress: (direction) => {
                const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
                rating.onItemValueUpdate(rating.visibleValue.value, step * direction);
            },
        };
    },
});

const _hoisted_1 = ["aria-label"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": `current rating ${_ctx.$props.modelValue} of ${_ctx.$props.max}`
  }, [
    createElementVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys($event => (_ctx.onArrowKeyPress(-1)), ["left"])),
        _cache[1] || (_cache[1] = withKeys($event => (_ctx.onArrowKeyPress(1)), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => (_ctx.onMouseEnter && _ctx.onMouseEnter(...args))),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => (_ctx.onMouseLeave && _ctx.onMouseLeave(...args)))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return (openBlock(), createBlock(_component_va_rating_item, mergeProps({ key: itemNumber }, _ctx.VaRatingItemProps, {
          "aria-label": `vote rating ${itemNumber} of ${_ctx.$props.max}`,
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: $event => (_ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event)),
          "onUpdate:modelValue": $event => (_ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event))
        }), createSlots({ _: 2 /* DYNAMIC */ }, [
          (_ctx.$props.numbers)
            ? {
                name: "default",
                fn: withCtx(({ props }) => [
                  createVNode(_component_VaRatingItemNumberButton, mergeProps(_ctx.VaRatingItemNumberButtonProps, {
                    "model-value": props.value,
                    "item-number": itemNumber,
                    onClick: props.onClick
                  }), null, 16 /* FULL_PROPS */, ["model-value", "item-number", "onClick"])
                ])
              }
            : undefined
        ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]))
      }), 128 /* KEYED_FRAGMENT */))
    ], 32 /* HYDRATE_EVENTS */),
    (_ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max)
      ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "va-rating__text-wrapper",
          style: normalizeStyle({ color: _ctx.computedColor })
        }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5 /* TEXT, STYLE */))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1))
}

script.render = render;
script.__file = "src/components/va-rating/VaRating.vue";

const VaRatingItem = withConfigTransport(script$2);

const VaRating = withConfigTransport(script);

export { VaRating, VaRatingItem };
//# sourceMappingURL=index45.js.map
