import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, shallowRef, ref, computed, watch, resolveComponent, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, toDisplayString, createCommentVNode, normalizeClass, normalizeStyle, createBlock, createElementVNode, withDirectives, createVNode, vShow, nextTick, withCtx, createSlots, mergeProps, renderSlot, normalizeProps, createTextVNode } from 'vue';
import { w as warn } from './utils.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useClearableEmits, b as useClearableProps, c as useFocusDeep, a as useClearable } from './VaInput.js';
import { b as useColorProps, u as useColors } from './useColors.js';
import { u as useFormProps } from './useForm.js';
import { u as useLoadingProps } from './useLoading.js';
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from './index67.js';
import { u as useSelectableListProps, a as useSelectableList } from './useSelectableList.js';
import { VaDropdown, VaDropdownContent } from './index27.js';
import { VaIcon } from './index31.js';
import { VaInput } from './index35.js';
import { s as script$2 } from './VaInputWrapper.js';
import './VaConfig.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './VaIcon.js';
import './useSize.js';
import './child-props.js';
import './useFocus.js';
import 'colortranslator';
import './useEmitProxy.js';
import './useCaptureEvent.js';
import 'cleave.js';
import './useBem.js';
import './_createCompounder.js';
import './useSyncProp.js';
import './consts.js';
import './debounce.js';
import './toNumber.js';
import './useStateful.js';
import './useTextColor.js';
import './VaMessageListWrapper.js';
import './useCSSVariables.js';

/**
 * You could add these props to any component by destructuring them inside props option.
 * @example
 * props: { ...useMaxSelectionsProps, componentsOwnProp, etc. }
 * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision
 */
const useMaxSelectionsProps = {
    maxSelections: {
        type: [Number, String],
        default: undefined,
    },
};
function useMaxSelections(selections, maxSelections, emit) {
    const exceedsMaxSelections = () => {
        if (maxSelections.value === undefined || isNaN(+maxSelections.value)) {
            return false;
        }
        return selections.value.length >= maxSelections.value;
    };
    const addOption = (optionToAdd) => {
        const newSelectedOptions = [...selections.value, optionToAdd];
        emit('update:modelValue', newSelectedOptions);
    };
    return {
        exceedsMaxSelections,
        addOption,
    };
}

const getTopCoordinate = (element) => element.offsetTop;
const getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
const getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
const getScrollTop = (element, scrollTarget, verticalAlignment) => {
    const viewHeight = scrollTarget.offsetHeight;
    const currentPosition = scrollTarget.scrollTop;
    const top = getTopCoordinate(element) - scrollTarget.offsetTop;
    const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
    const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
    if (verticalAlignment === 'start') {
        return top;
    }
    if (verticalAlignment === 'end') {
        return bottom - viewHeight;
    }
    if (verticalAlignment === 'center') {
        return center - viewHeight / 2;
    }
    if (verticalAlignment === 'any') {
        if (top - currentPosition < 0) {
            return top;
        }
        if (bottom - currentPosition > viewHeight) {
            return bottom - viewHeight;
        }
    }
};
/**
 * @param options.scrollTarget - element that will be scrolled
 */
const scrollToElement = (element, options = {
    scrollTarget: element.parentElement,
    verticalAlignment: 'any',
    smooth: false,
}) => {
    const scrollTarget = options.scrollTarget || element.parentElement;
    const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
    if (top === undefined) {
        return;
    }
    scrollTarget.scroll({
        top: top,
        behavior: options.smooth ? 'smooth' : 'auto',
    });
};

var script$1 = defineComponent({
    name: 'VaSelectOptionList',
    components: { VaIcon },
    emits: [
        'select-option',
        'update:hoveredOption',
        'no-previous-option-to-hover',
        'scroll-bottom',
    ],
    props: {
        ...useColorProps,
        options: { type: Array, default: () => [] },
        noOptionsText: { type: String, default: 'Items not found' },
        getSelectedState: { type: Function, required: true },
        getText: { type: Function, required: true },
        getTrackBy: { type: Function, required: true },
        getGroupBy: { type: Function, required: true },
        multiple: { type: Boolean, default: false },
        search: { type: String, default: '' },
        tabindex: { type: Number, default: 0 },
        hoveredOption: {
            type: [String, Number, Object],
            default: null,
        },
    },
    setup(props, { emit }) {
        const { getColor, getHoverColor } = useColors();
        const rootElement = shallowRef();
        const itemRefs = ref({});
        const onScroll = (event) => {
            const target = event.target;
            if (!target) {
                return;
            }
            if (target.scrollTop + target.clientHeight === target.scrollHeight) {
                emit('scroll-bottom');
            }
        };
        const beforeUpdate = () => { itemRefs.value = {}; };
        const setItemRef = (option) => (el) => {
            if (el) {
                itemRefs.value[props.getTrackBy(option)] = el;
            }
        };
        const hoveredOptionComputed = computed({
            get: () => props.hoveredOption || null,
            set: (value) => emit('update:hoveredOption', value),
        });
        const filteredOptions = computed(() => {
            if (!props.search) {
                return props.options;
            }
            return props.options.filter((option) => {
                const optionText = props.getText(option).toString().toUpperCase();
                const search = props.search.toUpperCase();
                return optionText.includes(search);
            });
        });
        const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
            if (typeof option !== 'object' || !option.group) {
                groups._noGroup.push(option);
            }
            else {
                const groupBy = props.getGroupBy(option);
                if (!groups[groupBy]) {
                    groups[groupBy] = [];
                }
                groups[groupBy].push(option);
            }
            return groups;
        }, { _noGroup: [] }));
        const selectOption = (option) => emit('select-option', option);
        const getOptionIcon = (option) => typeof option === 'object' ? option.icon : undefined;
        const getOptionClass = (option) => ({
            'va-select-option-list__option': true,
            'va-select-option-list__option--selected': props.getSelectedState(option),
        });
        const getOptionStyle = (option) => ({
            color: props.getSelectedState(option) ? getColor(props.color) : 'inherit',
            backgroundColor: isHovered(option) ? getHoverColor(getColor(props.color)) : 'transparent',
        });
        const isHovered = (option) => {
            if (!hoveredOptionComputed.value) {
                return false;
            }
            if (typeof option === 'string') {
                return option === hoveredOptionComputed.value;
            }
            if (!props.getTrackBy) {
                return false;
            }
            return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option);
        };
        const updateHoveredOption = (option) => { hoveredOptionComputed.value = option || null; };
        const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
            return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value);
        }));
        const hoverPreviousOption = () => {
            if (!hoveredOptionComputed.value) {
                // Hover last option from list
                filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1));
            }
            else {
                if (filteredOptions.value[hoveredOptionIndex.value - 1]) {
                    hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1];
                }
                else {
                    emit('no-previous-option-to-hover');
                }
            }
        };
        const hoverNextOption = () => {
            if (!hoveredOptionComputed.value) {
                // Hover first option from list
                filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0]);
            }
            else {
                if (filteredOptions.value[hoveredOptionIndex.value + 1]) {
                    hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1];
                }
            }
        };
        const hoverFirstOption = () => {
            if (filteredOptions.value.length > 0) {
                updateHoveredOption(filteredOptions.value[0]);
            }
        };
        const focus = () => {
            var _a;
            // Prevent scroll since element in dropdown and it cause scrolling to page end.
            (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
        };
        const scrollToOption = (option) => {
            if (!option) {
                return;
            }
            const element = itemRefs.value[props.getTrackBy(option)];
            if (element) {
                scrollToElement(element);
            }
        };
        watch(() => props.hoveredOption, (newOption) => newOption && scrollToOption(newOption));
        const publicMethods = {
            hoverPreviousOption,
            hoverNextOption,
            hoverFirstOption,
            focus,
            scrollToOption,
        };
        return {
            rootElement,
            getColor,
            filteredOptions,
            optionGroups,
            onScroll,
            beforeUpdate,
            setItemRef,
            selectOption,
            getOptionIcon,
            getOptionClass,
            getOptionStyle,
            updateHoveredOption,
            ...publicMethods,
        };
    },
});

const _hoisted_1$1 = ["tabindex"];
const _hoisted_2$1 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
const _hoisted_3 = ["aria-selected", "onClick", "onMouseover"];
const _hoisted_4 = {
  key: 0,
  class: "va-select-option-list no-options"
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");

  return (openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => (_ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args)), ["stop","prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => (_ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args)), ["stop","prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => (_ctx.hoverNextOption && _ctx.hoverNextOption(...args)), ["stop","prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => (_ctx.hoverNextOption && _ctx.hoverNextOption(...args)), ["stop","prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => (_ctx.onScroll && _ctx.onScroll(...args)))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return (openBlock(), createElementBlock(Fragment, { key: groupName }, [
        (groupName !== '_noGroup')
          ? (openBlock(), createElementBlock("span", _hoisted_2$1, toDisplayString(groupName), 1 /* TEXT */))
          : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
          return (openBlock(), createElementBlock("div", {
            key: _ctx.$props.getTrackBy(option),
            ref_for: true,
            ref: _ctx.setItemRef(option),
            role: "option",
            "aria-selected": !!_ctx.$props.getSelectedState(option),
            class: normalizeClass(_ctx.getOptionClass(option)),
            style: normalizeStyle(_ctx.getOptionStyle(option)),
            onClick: $event => (_ctx.selectOption(option)),
            onMouseover: $event => (_ctx.updateHoveredOption(option))
          }, [
            (_ctx.getOptionIcon(option))
              ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  size: "small",
                  class: "va-select-option-list__option--icon",
                  name: _ctx.getOptionIcon(option)
                }, null, 8 /* PROPS */, ["name"]))
              : createCommentVNode("v-if", true),
            createElementVNode("span", null, toDisplayString(_ctx.getText(option)), 1 /* TEXT */),
            withDirectives(createVNode(_component_va_icon, {
              class: "va-select-option-list__option--selected-icon",
              size: "small",
              name: "done",
              color: _ctx.getColor(_ctx.$props.color)
            }, null, 8 /* PROPS */, ["color"]), [
              [vShow, _ctx.$props.getSelectedState(option)]
            ])
          ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_3))
        }), 128 /* KEYED_FRAGMENT */))
      ], 64 /* STABLE_FRAGMENT */))
    }), 128 /* KEYED_FRAGMENT */)),
    (!_ctx.filteredOptions.length)
      ? (openBlock(), createElementBlock("div", _hoisted_4, toDisplayString(_ctx.noOptionsText), 1 /* TEXT */))
      : createCommentVNode("v-if", true)
  ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$1))
}

script$1.render = render$1;
script$1.__file = "src/components/va-select/VaSelectOptionList/VaSelectOptionList.vue";

const VaSelectOptionList = withConfigTransport(script$1);

var script = defineComponent({
    name: 'VaSelect',
    components: {
        VaSelectOptionList,
        VaIcon,
        VaDropdown,
        VaDropdownContent,
        VaInput,
        VaInputWrapper: script$2,
    },
    emits: [
        'update:modelValue',
        'update-search',
        'create-new',
        'scroll-bottom',
        ...useValidationEmits,
        ...useClearableEmits,
    ],
    props: {
        ...useSelectableListProps,
        ...useValidationProps,
        ...useLoadingProps,
        ...useMaxSelectionsProps,
        ...useClearableProps,
        ...useFormProps,
        modelValue: {
            type: [String, Number, Array, Object],
            default: '',
        },
        // Dropdown placement
        placement: {
            type: String,
            default: 'bottom',
            validator: (placement) => ['top', 'bottom'].includes(placement),
        },
        allowCreate: {
            type: [Boolean, String],
            default: false,
            validator: (mode) => [true, false, 'unique'].includes(mode),
        },
        color: { type: String, default: 'primary' },
        multiple: { type: Boolean, default: false },
        searchable: { type: Boolean, default: false },
        separator: { type: String, default: ', ' },
        width: { type: String, default: '100%' },
        maxHeight: { type: String, default: '256px' },
        noOptionsText: { type: String, default: 'Items not found' },
        fixed: { type: Boolean, default: true },
        hideSelected: { type: Boolean, default: false },
        tabindex: { type: Number, default: 0 },
        dropdownIcon: {
            type: [String, Object],
            default: () => ({
                open: 'expand_more',
                close: 'expand_less',
            }),
            validator: (value) => {
                if (typeof value === 'string') {
                    return true;
                }
                const isOpenIconString = typeof value.open === 'string';
                const isCloseIconString = typeof value.close === 'string';
                return isOpenIconString && isCloseIconString;
            },
        },
        // Input style
        outline: { type: Boolean, default: false },
        bordered: { type: Boolean, default: false },
        label: { type: String, default: '' },
        placeholder: { type: String, default: '' },
        requiredMark: { type: Boolean, default: false },
    },
    setup(props, { emit }) {
        const optionList = shallowRef();
        const input = shallowRef();
        const searchBar = shallowRef();
        const isInputFocused = useFocusDeep();
        const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
        const { getHoverColor, getColor } = useColors();
        const { getOptionByValue, getValue, getText, getTrackBy, getGroupBy } = useSelectableList(props);
        const { validate, computedError, computedErrorMessages, } = useValidation(props, emit, () => reset(), () => focus());
        const colorComputed = computed(() => getColor(props.color));
        const toggleIconColor = computed(() => props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value);
        const onScrollBottom = () => {
            emit('scroll-bottom');
        };
        const searchInput = ref('');
        const showSearchInput = computed(() => props.searchable || props.allowCreate);
        watch(searchInput, (value) => {
            emit('update-search', value);
            hoveredOption.value = null;
        });
        // Select value
        const valueComputed = computed({
            get() {
                const value = getOptionByValue(props.modelValue);
                if (props.multiple) {
                    if (!value) {
                        return [];
                    }
                    if (!Array.isArray(value)) {
                        return [value];
                    }
                    return value;
                }
                if (Array.isArray(value)) {
                    warn('Model value should be a string or a number for a single Select.');
                    if (value.length) {
                        return value[value.length - 1];
                    }
                }
                return value;
            },
            set(value) {
                if (Array.isArray(value)) {
                    emit('update:modelValue', value.map(getValue));
                }
                else {
                    emit('update:modelValue', getValue(value));
                }
            },
        });
        const valueComputedString = computed(() => {
            if (!valueComputed.value) {
                return props.clearValue;
            }
            if (typeof valueComputed.value === 'string' || typeof valueComputed.value === 'number') {
                return valueComputed.value;
            }
            if (Array.isArray(valueComputed.value)) {
                return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
            }
            return getText(valueComputed.value);
        });
        const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
        // Icons
        const { canBeCleared, clearIconProps, onFocus, onBlur, } = useClearable(props, valueComputed);
        const showClearIcon = computed(() => {
            return props.multiple && Array.isArray(valueComputed.value) ? !!valueComputed.value.length : canBeCleared.value;
        });
        const toggleIcon = computed(() => {
            if (!props.dropdownIcon) {
                return '';
            }
            if (typeof props.dropdownIcon === 'string') {
                return props.dropdownIcon;
            }
            return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
        });
        // Options
        const filteredOptions = computed(() => {
            if (!props.options) {
                return [];
            }
            if (props.hideSelected) {
                return props.options.filter((option) => !checkIsOptionSelected(option));
            }
            return props.options;
        });
        const checkIsOptionSelected = (option) => {
            if (!valueComputed.value) {
                return false;
            }
            if (Array.isArray(valueComputed.value)) {
                return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
            }
            return compareOptions(valueComputed.value, option);
        };
        const compareOptions = (option1, option2) => {
            const one = getValue(option1);
            const two = getValue(option2);
            // identity check works nice for strings and exact matches.
            if (one === two) {
                return true;
            }
            if (typeof one === 'string' && typeof two === 'string') {
                return one === two;
            }
            if (one === null || two === null) {
                return false;
            }
            if (typeof one === 'object' && typeof two === 'object') {
                return getTrackBy(one) === getTrackBy(two);
            }
            return false;
        };
        const isValueComputedArray = (v) => Array.isArray(v.value);
        const selectOption = (option) => {
            if (hoveredOption.value === null) {
                hideAndFocus();
                return;
            }
            if (showSearchInput.value) {
                searchInput.value = '';
            }
            if (props.multiple && isValueComputedArray(valueComputed)) {
                const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit);
                const isSelected = checkIsOptionSelected(getValue(option));
                if (isSelected) {
                    // Unselect
                    valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue(option), getValue(optionSelected)));
                }
                else {
                    if (exceedsMaxSelections()) {
                        return;
                    }
                    addOption(getValue(option));
                }
            }
            else {
                valueComputed.value = typeof option === 'string' || typeof option === 'number' ? option : { ...option };
                hideAndFocus();
            }
        };
        const addNewOption = () => {
            var _a;
            // Do not emit if option already exist and allow create is `unique`
            const hasAddedOption = (_a = props.options) === null || _a === void 0 ? void 0 : _a.some((option) => getText(option) === searchInput.value);
            if (!(props.allowCreate === 'unique' && hasAddedOption)) {
                emit('create-new', searchInput.value);
                searchInput.value = '';
            }
        };
        // Hovered options
        const hoveredOption = ref(null);
        const selectHoveredOption = () => {
            if (!hoveredOption.value) {
                return;
            }
            if (!showDropdownContent.value) {
                // We can not select options if they are hidden
                showDropdown();
                return;
            }
            selectOption(hoveredOption.value);
        };
        const selectOrAddOption = () => {
            const allowedToCreate = !!props.allowCreate && searchInput.value !== '';
            if (hoveredOption.value !== null) {
                selectHoveredOption();
            }
            else if (allowedToCreate) {
                addNewOption();
            }
        };
        const hoverPreviousOption = () => {
            var _a;
            (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.hoverPreviousOption();
        };
        const hoverNextOption = () => {
            var _a;
            (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.hoverNextOption();
        };
        // Dropdown content
        const showDropdownContent = ref(false);
        const showDropdownContentComputed = computed({
            get: () => showDropdownContent.value,
            set: (show) => {
                show ? showDropdown() : hideDropdown();
            },
        });
        const closeOnContentClick = computed(() => {
            return !(props.multiple || props.searchable || props.allowCreate);
        });
        const showDropdown = () => {
            if (props.disabled || props.readonly) {
                return;
            }
            showDropdownContent.value = true;
            scrollToSelected();
            focusSearchOrOptions();
        };
        const hideDropdown = () => {
            showDropdownContent.value = false;
            searchInput.value = '';
            validate();
        };
        const toggleDropdown = () => {
            if (showDropdownContent.value) {
                hideAndFocus();
            }
            else {
                showDropdown();
            }
        };
        const onSelectClick = () => {
            if (props.disabled || props.readonly) {
                return;
            }
            toggleDropdown();
        };
        const hideAndFocus = () => {
            hideDropdown();
            isInputFocused.value = true;
        };
        const focusSearchBar = () => {
            var _a;
            (_a = searchBar.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const focusOptionList = () => {
            var _a, _b;
            (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.focus();
            !props.modelValue && ((_b = optionList.value) === null || _b === void 0 ? void 0 : _b.hoverFirstOption());
        };
        const focusSearchOrOptions = () => nextTick(() => {
            if (showSearchInput.value) {
                focusSearchBar();
            }
            else {
                focusOptionList();
            }
        });
        const onInputFocus = () => {
            isInputFocused.value = true;
            onFocus();
        };
        const onInputBlur = () => {
            if (showDropdownContentComputed.value) {
                return;
            }
            onBlur();
            isInputFocused.value
                ? isInputFocused.value = false
                : validate();
        };
        /** @public */
        const focus = () => {
            var _a;
            if (props.disabled) {
                return;
            }
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        /** @public */
        const blur = () => {
            var _a;
            if (showDropdownContentComputed.value) {
                showDropdownContentComputed.value = false;
            }
            nextTick((_a = input.value) === null || _a === void 0 ? void 0 : _a.blur);
        };
        /** @public */
        const reset = () => {
            if (props.multiple) {
                valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
            }
            else {
                valueComputed.value = props.clearValue;
            }
            searchInput.value = '';
            emit('clear');
        };
        const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
        const scrollToSelected = () => {
            const selected = valueComputed.value;
            const nothingSelected = typeof selected !== 'object' && Array.isArray(selected) && !selected.length;
            if (nothingSelected) {
                return;
            }
            const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
            hoveredOption.value = scrollTo;
            nextTick(() => { var _a; return (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.scrollToOption(scrollTo); });
        };
        // Hinted search
        let hintedSearchQuery = '';
        let hintedSearchQueryTimeoutIndex;
        const navigationKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' '];
        // Hinted search - hover option if you typing it's value on select without search-bar
        const onHintedSearch = (event) => {
            if (navigationKeys.some(key => key === event.key)) {
                return;
            }
            const isLetter = event.key.length === 1;
            const isDeleteKey = event.key === 'Backspace' || event.key === 'Delete';
            clearTimeout(hintedSearchQueryTimeoutIndex);
            if (isDeleteKey) {
                // Remove last letter from query
                hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : '';
            }
            else if (isLetter) {
                // Add every new letter to the query
                hintedSearchQuery += event.key;
            }
            if (showSearchInput.value) {
                searchInput.value = hintedSearchQuery;
                return;
            }
            // Search for an option that matches the query
            if (hintedSearchQuery) {
                const appropriateOption = props.options.find(option => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
                if (appropriateOption) {
                    hoveredOption.value = appropriateOption;
                }
            }
            hintedSearchQueryTimeoutIndex = setTimeout(() => { hintedSearchQuery = ''; }, 1000);
        };
        return {
            isFocused,
            input,
            optionList,
            searchBar,
            reset,
            focus,
            blur,
            onInputFocus,
            onInputBlur,
            focusOptionList,
            onSelectClick,
            focusSearchBar,
            searchInput,
            showSearchInput,
            hoveredOption,
            tabIndexComputed,
            valueComputed,
            valueComputedString,
            showClearIcon,
            toggleIcon,
            computedErrorMessages,
            computedError,
            filteredOptions,
            checkIsOptionSelected,
            closeOnContentClick,
            selectOption,
            selectOrAddOption,
            selectHoveredOption,
            hoverPreviousOption,
            hoverNextOption,
            showDropdownContentComputed,
            showDropdown,
            hideDropdown,
            hideAndFocus,
            toggleDropdown,
            toggleIconColor,
            onHintedSearch,
            getText,
            getTrackBy,
            getGroupBy,
            onScrollBottom,
            clearIconProps,
            isPlaceholder,
        };
    },
});

const _hoisted_1 = {
  key: 0,
  class: "va-select__placeholder"
};
const _hoisted_2 = { class: "va-select-dropdown__options-wrapper" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");

  return (openBlock(), createBlock(_component_va_dropdown, {
    ref: "dropdown",
    class: "va-select__dropdown va-select-dropdown",
    trigger: "none",
    anchorSelector: ".va-input-wrapper__field",
    placement: _ctx.$props.placement,
    disabled: _ctx.$props.disabled,
    "max-height": _ctx.$props.maxHeight,
    fixed: _ctx.$props.fixed,
    "close-on-content-click": _ctx.closeOnContentClick,
    stateful: false,
    offset: [1, 0],
    "keep-anchor-width": "",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((_ctx.showDropdownContentComputed) = $event)),
    onKeydown: [
      withKeys(withModifiers(_ctx.showDropdown, ["stop","prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop","prevent"]), ["down"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop","prevent"]), ["space"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop","prevent"]), ["enter"])
    ],
    onClick: withModifiers(_ctx.onSelectClick, ["prevent"])
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select",
        "aria-label": "selected option",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        disabled: _ctx.$props.disabled,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          (_ctx.showClearIcon)
            ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                role: "button",
                "aria-hidden": "false",
                "aria-label": "reset",
                tabindex: "0"
              }, _ctx.clearIconProps, {
                onClick: withModifiers(_ctx.reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
                ]
              }), null, 16 /* FULL_PROPS */, ["onClick", "onKeydown"]))
            : createCommentVNode("v-if", true)
        ]),
        appendInner: withCtx(() => [
          (_ctx.$slots.appendInner)
            ? renderSlot(_ctx.$slots, "appendInner", { key: 0 })
            : createCommentVNode("v-if", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8 /* PROPS */, ["color", "name"])
        ]),
        default: withCtx(() => [
          (_ctx.isPlaceholder)
            ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(_ctx.$props.placeholder), 1 /* TEXT */))
            : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
              valueString: _ctx.valueComputedString,
              value: _ctx.valueComputed,
              tabindex: _ctx.tabIndexComputed,
            })), () => [
                createTextVNode(toDisplayString(_ctx.valueComputedString), 1 /* TEXT */)
              ])
        ]),
        _: 2 /* DYNAMIC */
      }, [
        (_ctx.$slots.prepend)
          ? {
              name: "prepend",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "prepend")
              ])
            }
          : undefined,
        (_ctx.$slots.append)
          ? {
              name: "append",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "append")
              ])
            }
          : undefined,
        (_ctx.$slots.prependInner)
          ? {
              name: "prependInner",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "prependInner")
              ])
            }
          : undefined
      ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["model-value", "success", "error", "color", "label", "loading", "disabled", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width }),
        onKeyup: _cache[4] || (_cache[4] = withKeys(withModifiers(() => undefined, ["stop"]), ["enter"])),
        onKeydown: [
          _cache[5] || (_cache[5] = withKeys(withModifiers(() => undefined, ["stop","prevent"]), ["tab"])),
          withKeys(withModifiers(_ctx.hideAndFocus, ["prevent"]), ["esc"])
        ]
      }, {
        default: withCtx(() => [
          (_ctx.showSearchInput)
            ? (openBlock(), createBlock(_component_va_input, {
                key: 0,
                ref: "searchBar",
                class: "va-select__input",
                placeholder: "Search",
                "aria-label": "options filter",
                tabindex: _ctx.tabIndexComputed,
                bordered: true,
                modelValue: _ctx.searchInput,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.searchInput) = $event)),
                onKeydown: [
                  withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop","prevent"]), ["up"]),
                  withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop","prevent"]), ["left"]),
                  withKeys(withModifiers(_ctx.hoverNextOption, ["stop","prevent"]), ["down"]),
                  withKeys(withModifiers(_ctx.hoverNextOption, ["stop","prevent"]), ["right"]),
                  withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
                ],
                onFocus: _cache[1] || (_cache[1] = $event => (_ctx.hoveredOption = null))
              }, null, 8 /* PROPS */, ["tabindex", "modelValue", "onKeydown"]))
            : createCommentVNode("v-if", true),
          createElementVNode("div", _hoisted_2, [
            createVNode(_component_va_select_option_list, {
              ref: "optionList",
              hoveredOption: _ctx.hoveredOption,
              "onUpdate:hoveredOption": _cache[2] || (_cache[2] = $event => ((_ctx.hoveredOption) = $event)),
              style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
              options: _ctx.filteredOptions,
              "selected-value": _ctx.valueComputed,
              "get-selected-state": _ctx.checkIsOptionSelected,
              "get-text": _ctx.getText,
              "get-track-by": _ctx.getTrackBy,
              "get-group-by": _ctx.getGroupBy,
              search: _ctx.searchInput,
              "no-options-text": _ctx.$props.noOptionsText,
              color: _ctx.$props.color,
              tabindex: _ctx.tabIndexComputed,
              onSelectOption: _ctx.selectOption,
              onNoPreviousOptionToHover: _ctx.focusSearchBar,
              onKeydown: [
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop","prevent"]), ["enter"]),
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop","prevent"]), ["space"]),
                _cache[3] || (_cache[3] = withKeys(withModifiers($event => (_ctx.searchBar && _ctx.searchBar.focus()), ["stop","prevent"]), ["tab"])),
                _ctx.onHintedSearch
              ],
              onScrollBottom: _ctx.onScrollBottom
            }, null, 8 /* PROPS */, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "get-text", "get-track-by", "get-group-by", "search", "no-options-text", "color", "tabindex", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
          ])
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["style", "onKeydown"])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["placement", "disabled", "max-height", "fixed", "close-on-content-click", "modelValue", "onKeydown", "onClick"]))
}

script.render = render;
script.__file = "src/components/va-select/VaSelect.vue";

const VaSelect = withConfigTransport(script);

export { VaSelect, VaSelectOptionList };
//# sourceMappingURL=index46.js.map
