import { m as useGlobalConfigSafe } from './global-config.js';
import { ColorTranslator } from 'colortranslator';

// import colortranslator, { ColorTranslator as CTClass } from 'colortranslator'
/** This is a hack for cjs and esm build when we can transpile colortranslator */
// const ColorTranslator = CTClass || colortranslator.ColorTranslator
const colorToRgba = (color, opacity) => {
    return new ColorTranslator(color).setA(opacity).RGBA;
};
const getTextColor = (color, darkColor = 'dark', lightColor = 'white') => {
    const { R, G, B } = new ColorTranslator(color);
    const isLightBackground = Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068) > 130;
    return isLightBackground ? darkColor : lightColor;
};
const getBoxShadowColor = (color) => {
    return new ColorTranslator(color).setA(0.4).RGBA;
};
const getHoverColor = (color) => {
    return new ColorTranslator(color).setA(0.2).RGBA;
};
const getFocusColor = (color) => {
    return new ColorTranslator(color).setA(0.3).RGBA;
};
const shiftHSLAColor = (color, offset) => {
    const result = new ColorTranslator(color);
    if (offset.h) {
        result.setH(result.H + offset.h);
    }
    if (offset.s) {
        result.setS(result.S + offset.s);
    }
    if (offset.l) {
        result.setL(result.L + offset.l);
    }
    if (offset.a) {
        result.setA(result.A + offset.a);
    }
    return result.HSLA;
};
const setHSLAColor = (color, newColor) => {
    const result = new ColorTranslator(color);
    if (newColor.h !== undefined) {
        result.setH(newColor.h);
    }
    if (newColor.s !== undefined) {
        result.setS(newColor.s);
    }
    if (newColor.l !== undefined) {
        result.setL(newColor.l);
    }
    if (newColor.a !== undefined) {
        result.setA(newColor.a);
    }
    return result.HSLA;
};
/**
 * This method guesses second color for gradient based on first one.
 * Calculation method should differ for different colors, so we split color circle
 * in zones.
 *
 * @param color
 */
const shiftGradientColor = (color) => {
    const newColor = ColorTranslator.toHSLA(color, false);
    // Gray
    if (newColor.s < 10) {
        return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
    }
    // Unsaturated (too pale, gray-ish, monotone)
    // For unsaturated color, hue change does nothing.
    if (newColor.s < 30) {
        return shiftHSLAColor(newColor, { s: -14, l: 11 });
    }
    // Red
    if ((newColor.h >= 0 && newColor.h < 44) || (newColor.h >= 285)) {
        return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
    }
    // Yellow
    if (newColor.h >= 44 && newColor.h < 85) {
        return shiftHSLAColor(newColor, { h: 3, l: 9 });
    }
    // Green
    if (newColor.h >= 85 && newColor.h < 165) {
        return shiftHSLAColor(newColor, { h: 16, l: 14 });
    }
    // Blue
    if (newColor.h >= 165 && newColor.h < 285) {
        return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
    }
    throw new Error('This method should handle all colors. But it didn\'t for some reason.');
};
const getGradientBackground = (color) => {
    const colorLeft = shiftGradientColor(color);
    const colorRight = ColorTranslator.toHSLA(color);
    return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
/**
 * Check if color is valid hsl, hsla, rga, rgba or hex color
 * Taken from https://www.regextester.com/103656
 * Check options <or> isCSSVariable(prop) <or> CSS.supports('color', prop) deleted due to problems with SSR and opacity
 * Details are in the discussion: https://github.com/epicmaxco/vuestic-ui/pull/1589
 * @param strColor
 */
const isColor = (strColor) => {
    // Need to use Regex instead of DOM methods because we support SSR
    const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
    return cssColorRegex.test(strColor.toLocaleLowerCase());
};
const isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);

/**
 * You can add these props to any component by destructuring them inside props option.
 * @example
 * props: { ...useColorProps, componentsOwnProp, etc. }
 * It's better to add props at the beginning to make sure that component own props will be used instead in case of collision.
 */
const useColorProps = {
    color: {
        type: String,
        default: '',
    },
};
const useColors = () => {
    const globalConfig = useGlobalConfigSafe();
    if (!globalConfig) {
        throw new Error('useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!');
    }
    const { setGlobalConfig, getGlobalConfig } = globalConfig;
    const setColors = (colors) => {
        setGlobalConfig((config) => ({
            ...config,
            colors: { ...config.colors, ...colors },
        }));
    };
    const getColors = () => {
        return getGlobalConfig().colors || {};
    };
    /**
     * Returns color from config by name or return prop if color is a valid hex, hsl, hsla, rgb or rgba color.
     * @param prop - should be color name or color in hex, hsl, hsla, rgb or rgba format.
     * @param preferVariables - function should return (if possible) CSS variable instead of hex (hex is needed to set opacity).
     * @param defaultColor - this color will be used if prop is invalid.
     */
    const getColor = (prop, defaultColor, preferVariables) => {
        if (!defaultColor) {
            /**
             * Most default color - fallback when nothing else is found.
             */
            defaultColor = getColors().primary;
        }
        const colors = getColors();
        if (!prop) {
            prop = defaultColor;
        }
        if (colors[prop]) {
            return preferVariables ? `var(--va-${prop})` : colors[prop];
        }
        if (isColor(prop)) {
            return prop;
        }
        if (preferVariables && isCSSVariable(prop)) {
            return prop;
        }
        if (process.env.NODE_ENV !== 'production') {
            console.warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
        }
        return defaultColor;
    };
    const colorsToCSSVariable = (colors, prefix = 'va') => {
        return Object
            .keys(colors)
            .filter((key) => colors[key] !== undefined)
            .reduce((acc, colorName) => {
            acc[`--${prefix}-${colorName}`] = getColor(colors[colorName], undefined, true);
            return acc;
        }, {});
    };
    return {
        setColors,
        getColors,
        getColor,
        getBoxShadowColor,
        getHoverColor,
        getFocusColor,
        getGradientBackground,
        getTextColor,
        shiftHSLAColor,
        setHSLAColor,
        colorsToCSSVariable,
    };
};

export { getGradientBackground as a, useColorProps as b, getFocusColor as c, getHoverColor as d, colorToRgba as e, getBoxShadowColor as g, shiftHSLAColor as s, useColors as u };
//# sourceMappingURL=useColors.js.map
