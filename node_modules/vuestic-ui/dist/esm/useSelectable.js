import { computed } from 'vue';
import { a as useStatefulProps, b as useStateful } from './useStateful.js';
import { u as useLoadingProps } from './useLoading.js';
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from './index67.js';
import { a as useFocus } from './useFocus.js';

const useSelectableProps = {
    ...useStatefulProps,
    ...useLoadingProps,
    ...useValidationProps,
    arrayValue: { type: null, default: null },
    label: { type: String, default: '' },
    leftLabel: { type: Boolean, default: false },
    trueValue: { type: null, default: true },
    falseValue: { type: null, default: false },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: null, default: null },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
};
const useSelectableEmits = [...useValidationEmits, 'update:modelValue', 'focus', 'blur'];
const checkDuplicates = (props) => {
    // Just validating state values.
    const values = [props.falseValue, props.trueValue];
    if (props.indeterminate) {
        values.push(props.indeterminateValue);
    }
    const hasDuplicates = new Set(values).size !== values.length;
    if (hasDuplicates) {
        throw new Error('falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.');
    }
};
const useSelectable = (props, emit, { input, label, container }) => {
    checkDuplicates(props);
    /** @public */
    const reset = () => emit('update:modelValue', false);
    const focus = () => { var _a; return (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus(); };
    const { computedError, computedErrorMessages, validate } = useValidation(props, emit, reset, focus);
    const { valueComputed } = useStateful(props, emit);
    const { isFocused } = useFocus();
    const isElementRelated = (element) => {
        return !!element && [label.value, container.value].includes(element);
    };
    const onBlur = (event) => {
        if ((input.value === event.target) && !isElementRelated(event.relatedTarget)) {
            isFocused.value = false;
            computedError.value = false;
            validate();
            emit('blur', event);
        }
    };
    const onFocus = (event) => {
        isFocused.value = true;
        emit('focus', event);
    };
    const isIndeterminate = computed(() => !!props.indeterminate && valueComputed.value === props.indeterminateValue);
    const modelIsArray = computed(() => props.arrayValue !== null);
    const isChecked = computed(() => {
        var _a;
        if (modelIsArray.value) {
            return (_a = props.modelValue) === null || _a === void 0 ? void 0 : _a.includes(props.arrayValue);
        }
        return valueComputed.value === props.trueValue;
    });
    const toggleSelection = () => {
        if (props.readonly || props.disabled || props.loading) {
            return;
        }
        // For array access we pretend computedValue does not exist and use modelValue + emit input directly.
        if (modelIsArray.value) {
            if (!props.modelValue) {
                emit('update:modelValue', [props.arrayValue]);
            }
            else if (!Array.isArray(props.modelValue)) {
                emit('update:modelValue', props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
            }
            else if (props.modelValue.includes(props.arrayValue)) {
                emit('update:modelValue', props.modelValue.filter((option) => option !== props.arrayValue));
            }
            else {
                emit('update:modelValue', props.modelValue.concat(props.arrayValue));
            }
            return;
        }
        if (props.indeterminate) {
            if (isIndeterminate.value) {
                valueComputed.value = props.trueValue;
            }
            else if (isChecked.value) {
                valueComputed.value = props.falseValue;
            }
            else {
                // unchecked
                valueComputed.value = props.indeterminateValue;
            }
            return;
        }
        if (isChecked.value) {
            valueComputed.value = props.falseValue;
        }
        else {
            valueComputed.value = props.trueValue;
        }
    };
    return {
        isChecked,
        isIndeterminate,
        onBlur,
        onFocus,
        toggleSelection,
        reset,
        focus,
        computedError,
        computedErrorMessages,
    };
};

export { useSelectableProps as a, useSelectable as b, useSelectableEmits as u };
//# sourceMappingURL=useSelectable.js.map
