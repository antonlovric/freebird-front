import { computed } from 'vue';

function normalizeProps(props) {
    switch (true) {
        case Array.isArray(props):
            return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
        case typeof props === 'object' && props !== null:
            return props;
        default:
            return {};
    }
}
function mergeProps(to, from, optionsType = 'props') {
    const { mixins, extends: extendsOptions } = from;
    extendsOptions && mergeProps(to, extendsOptions, optionsType);
    mixins && mixins.forEach((m) => mergeProps(to, m, optionsType));
    const props = normalizeProps(from[optionsType]);
    for (const key in props) {
        to[key] = props[key];
    }
}
function getComponentOptions(component) {
    if (component.options) {
        return component.options;
    }
    if (component.__vccOpts || component.__b) {
        return { ...component.__vccOpts, ...component.__b };
    }
    return component;
}
function resolveProps(options, optionsType = 'props') {
    var _a, _b;
    const mixins = (_a = options.mixins) !== null && _a !== void 0 ? _a : [];
    const extendsOptions = (_b = options.extends) !== null && _b !== void 0 ? _b : [];
    const result = {};
    mergeProps(result, extendsOptions, optionsType);
    for (let i = 0; i < mixins.length; i++) {
        mergeProps(result, mixins[i], optionsType);
    }
    Object.assign(result, normalizeProps(options[optionsType]));
    return result;
}
const getComponentProps = (component) => {
    return resolveProps(getComponentOptions(component));
};

/**
 * Accepts parent component props and return value only for child component props.
 *
 * Used to proxy child component props from parent.
 */
const filterComponentProps = (propsValues, childProps) => {
    return computed(() => {
        return Object
            .keys(childProps)
            .reduce((acc, propName) => {
            acc[propName] = propsValues[propName];
            return acc;
        }, {});
    });
};
/**
 * Works only with defineComponent function.
 * @notion Be aware that `withConfigTransport` you will lose prop types
 */
function extractComponentProps(component, ignoreProps) {
    const props = getComponentProps(component);
    if (ignoreProps) {
        return Object
            .keys(props)
            .reduce((acc, propName) => {
            if (ignoreProps.includes(propName)) {
                return acc;
            }
            if (props[propName] === undefined) {
                return acc;
            }
            acc[propName] = typeof props[propName] === 'string' ? {} : props[propName];
            return acc;
        }, {});
    }
    return props;
}
function extractComponentEmits(component) {
    return [...new Set(component.emits)];
}

export { extractComponentEmits as a, extractComponentProps as e, filterComponentProps as f };
//# sourceMappingURL=child-props.js.map
