import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, shallowRef, ref, computed, onMounted, onBeforeUnmount, watch, resolveComponent, openBlock, createElementBlock, mergeProps, renderSlot, createCommentVNode, normalizeStyle, createTextVNode, toDisplayString, createVNode, createElementVNode, Fragment, renderList, normalizeClass, normalizeProps, guardReactiveProps } from 'vue';
import { e as pick_1 } from './usePopover.js';
import { w as warn, g as generateUniqueId } from './utils.js';
import { u as useArrayRefs } from './useArrayRefs.js';
import { u as useBem } from './useBem.js';
import { u as useColors } from './useColors.js';
import './global-config.js';
import { VaIcon } from './index31.js';
import './VaConfig.js';
import './isSymbol.js';
import './ssr-utils.js';
import './global-utils.js';
import './_createCompounder.js';
import 'colortranslator';
import './global-properties.js';
import './VaIcon.js';
import './useSize.js';

const validateSlider = (value, step, min, max, range) => {
    if ((Array.isArray(value) && !range) || (!Array.isArray(value) && range)) {
        warn(`The type "${Array.isArray(value) ? 'array' : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
    }
    if (max < min) {
        warn('The maximum value can not be less than the minimum value.');
    }
    if (min > max) {
        warn('The minimum value can not be greater than the maximum value.');
    }
    if ((max - min) % step !== 0) {
        warn('Step is illegal. Slider is nondivisible.');
    }
    const inRange = (v) => {
        if (v < min) {
            warn(`The value of the slider is ${v}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
        }
        else if (v > max) {
            warn(`The value of the slider is ${v}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
        }
    };
    if (Array.isArray(value)) {
        value.map(inRange);
    }
    else {
        inRange(value);
    }
    return true;
};

var script = defineComponent({
    name: 'VaSlider',
    components: { VaIcon },
    emits: ['drag-start', 'drag-end', 'change', 'update:modelValue'],
    props: {
        range: { type: Boolean, default: false },
        modelValue: ({ type: [Number, Array], default: 0 }),
        trackLabel: ({ type: [Function, String] }),
        color: { type: String, default: 'primary' },
        trackColor: { type: String, default: '' },
        labelColor: { type: String, default: '' },
        trackLabelVisible: { type: Boolean, default: false },
        min: { type: Number, default: 0 },
        max: { type: Number, default: 100 },
        step: { type: Number, default: 1 },
        label: { type: String, default: '' },
        invertLabel: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        readonly: { type: Boolean, default: false },
        pins: { type: Boolean, default: false },
        iconPrepend: { type: String, default: '' },
        iconAppend: { type: String, default: '' },
        vertical: { type: Boolean, default: false },
        showTrack: { type: Boolean, default: true },
    },
    setup(props, { emit }) {
        const { getColor, getHoverColor } = useColors();
        const sliderContainer = shallowRef();
        const dot = shallowRef();
        const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
        const isFocused = ref(false);
        const flag = ref(false);
        const offset = ref(0);
        const size = ref(0);
        const currentValue = ref(props.modelValue);
        const currentSliderDotIndex = ref(0);
        const hasMouseDown = ref(false);
        const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
        const pinPositionStyle = computed(() => props.vertical ? 'bottom' : 'left');
        const trackSizeStyle = computed(() => props.vertical ? 'height' : 'width');
        const moreToLess = computed(() => Array.isArray(val.value) && (val.value[1] - props.step) < val.value[0]);
        const lessToMore = computed(() => Array.isArray(val.value) && (val.value[0] + props.step) > val.value[1]);
        const sliderClass = useBem('va-slider', () => ({
            ...pick_1(props, ['disabled', 'readonly', 'vertical']),
            active: isFocused.value,
            horizontal: !props.vertical,
            grabbing: hasMouseDown.value,
        }));
        const dotClass = useBem('va-slider__handler', () => ({
            onFocus: !props.range && (flag.value || isFocused.value),
            inactive: !isFocused.value,
        }));
        const labelStyles = computed(() => ({
            color: props.labelColor ? getColor(props.labelColor) : getColor(props.color),
        }));
        const trackStyles = computed(() => ({
            backgroundColor: props.trackColor
                ? getColor(props.trackColor)
                : getHoverColor(getColor(props.color)),
        }));
        const processedStyles = computed(() => {
            const validatedValue = limitValue(props.modelValue);
            if (Array.isArray(validatedValue)) {
                const val0 = ((validatedValue[0] - props.min) / (props.max - props.min)) * 100;
                const val1 = ((validatedValue[1] - props.min) / (props.max - props.min)) * 100;
                return {
                    [pinPositionStyle.value]: `${val0}%`,
                    [trackSizeStyle.value]: `${val1 - val0}%`,
                    backgroundColor: getColor(props.color),
                    visibility: props.showTrack ? 'visible' : 'hidden',
                };
            }
            else {
                const val = ((validatedValue - props.min) / (props.max - props.min)) * 100;
                return {
                    [trackSizeStyle.value]: `${val}%`,
                    backgroundColor: getColor(props.color),
                    visibility: props.showTrack ? 'visible' : 'hidden',
                };
            }
        });
        const dottedStyles = computed(() => {
            const validatedValue = limitValue(props.modelValue);
            if (Array.isArray(validatedValue)) {
                const val0 = ((validatedValue[0] - props.min) / (props.max - props.min)) * 100;
                const val1 = ((validatedValue[1] - props.min) / (props.max - props.min)) * 100;
                return [
                    {
                        [pinPositionStyle.value]: `${val0}%`,
                        backgroundColor: isActiveDot(0) ? getColor(props.color) : '#ffffff',
                        borderColor: getColor(props.color),
                    },
                    {
                        [pinPositionStyle.value]: `${val1}%`,
                        backgroundColor: isActiveDot(1) ? getColor(props.color) : '#ffffff',
                        borderColor: getColor(props.color),
                    },
                ];
            }
            else {
                const val = ((validatedValue - props.min) / (props.max - props.min)) * 100;
                return {
                    [pinPositionStyle.value]: `${val}%`,
                    backgroundColor: isActiveDot(0) ? getColor(props.color) : '#ffffff',
                    borderColor: getColor(props.color),
                };
            }
        });
        const getDottedStyles = (index) => props.range && index !== undefined
            ? dottedStyles.value[index]
            : dottedStyles.value;
        const val = computed({
            get: () => props.modelValue,
            set: (val) => {
                if (!props.range) {
                    val = limitValue(val);
                }
                if (!flag.value) {
                    emit('change', val);
                }
                emit('update:modelValue', val);
            },
        });
        const getValueByOrder = (order) => props.range && order !== undefined
            ? val.value[order]
            : val.value;
        const gap = computed(() => {
            const total = (props.max - props.min) / props.step;
            return size.value / total;
        });
        const multiple = computed(() => {
            const decimals = `${props.step}`.split('.')[1];
            return decimals ? Math.pow(10, decimals.length) : 1;
        });
        const pinsCol = computed(() => ((props.max - props.min) / props.step) - 1);
        const position = computed(() => {
            return Array.isArray(props.modelValue)
                ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value]
                : ((props.modelValue - props.min) / props.step * gap.value);
        });
        const limit = computed(() => [0, size.value]);
        const valueLimit = computed(() => [props.min, props.max]);
        const isActiveDot = (index) => {
            if ((!isFocused.value && !flag.value) || props.disabled || props.readonly) {
                return false;
            }
            return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
        };
        const moveStart = (e, index = currentSliderDotIndex.value) => {
            var _a, _b;
            e.preventDefault(); // prevent page scrolling
            if (!index) {
                if (!props.range) {
                    index = 0;
                }
                else if (Array.isArray(position.value)) {
                    const touch = 'touches' in e ? e.touches[0] : e;
                    const pos = getPos(touch);
                    index = pos > ((position.value[1] - position.value[0]) / 2 + position.value[0]) ? 1 : 0;
                }
            }
            if (Array.isArray(props.modelValue)) {
                currentSliderDotIndex.value = index;
            }
            Array.isArray(props.modelValue)
                ? (_a = dots.value[index]) === null || _a === void 0 ? void 0 : _a.focus()
                : (_b = dot.value) === null || _b === void 0 ? void 0 : _b.focus();
            flag.value = true;
            emit('drag-start');
        };
        const moving = (e) => {
            if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
                return;
            }
            e.preventDefault();
            if ('touches' in e) {
                setValueOnPos(getPos(e.touches[0]));
            }
            else {
                setValueOnPos(getPos(e));
            }
        };
        const moveEnd = () => {
            if (!props.disabled && !props.readonly) {
                if (flag.value) {
                    emit('drag-end');
                    emit('change', props.modelValue);
                }
                else {
                    return false;
                }
                flag.value = false;
                hasMouseDown.value = false;
            }
        };
        const moveWithKeys = (event) => {
            var _a, _b;
            // don't do anything if a dot isn't focused or if the slider's disabled or readonly
            if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
                return;
            }
            if (props.disabled || props.readonly) {
                return;
            }
            /*
              where: where to move
                0 - to left
                1 - to right
      
              which: which dot to move (only makes sense when isRange is true)
                0 - left dot
                1 - right dot
              */
            const moveDot = (isRange, where, which) => {
                if (isRange && Array.isArray(val.value)) {
                    if (!props.pins) {
                        return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
                    }
                    // how many value units one pin occupies
                    const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
                    // how many full pins are to the left of the dot now
                    const fullPinsNow = val.value[which] / onePinInterval | 0;
                    // the value of the nearest pin
                    let nearestPinVal = fullPinsNow * onePinInterval;
                    if (val.value[which] !== nearestPinVal) { // if the dot's not pinned already
                        nearestPinVal += where ? onePinInterval : 0; // take one more pin if moving right
                        val.value.splice(which, 1, nearestPinVal);
                    }
                    else {
                        val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
                    }
                }
                else {
                    if (!props.pins && !Array.isArray(val.value)) {
                        val.value += where ? props.step : -props.step;
                        return;
                    }
                    // how many value units one pin occupies
                    const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
                    // how many full pins are to the left of the dot now
                    const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
                    // the value of the nearest pin
                    let nearestPinVal = fullPinsNow * onePinInterval;
                    if (val.value !== nearestPinVal) { // if the dot's not pinned already
                        nearestPinVal += where ? onePinInterval : 0; // take one more pin if moving right
                        val.value = nearestPinVal;
                    }
                    else {
                        val.value += where ? props.step : -props.step;
                    }
                }
            };
            // prevent page scroll
            if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].includes(event.key)) {
                event.preventDefault();
            }
            const isActive = (el) => el === document.activeElement;
            if (props.range && Array.isArray(val.value)) {
                const isVerticalDot0More = (event) => props.vertical && isActive(dots.value[0]) && event.key === 'ArrowUp';
                const isVerticalDot0Less = (event) => props.vertical && isActive(dots.value[0]) && event.key === 'ArrowDown';
                const isVerticalDot1More = (event) => props.vertical && isActive(dots.value[1]) && event.key === 'ArrowUp';
                const isVerticalDot1Less = (event) => props.vertical && isActive(dots.value[1]) && event.key === 'ArrowDown';
                const isHorizontalDot0Less = (event) => !props.vertical && isActive(dots.value[0]) && event.key === 'ArrowLeft';
                const isHorizontalDot0More = (event) => !props.vertical && isActive(dots.value[0]) && event.key === 'ArrowRight';
                const isHorizontalDot1Less = (event) => !props.vertical && isActive(dots.value[1]) && event.key === 'ArrowLeft';
                const isHorizontalDot1More = (event) => !props.vertical && isActive(dots.value[1]) && event.key === 'ArrowRight';
                switch (true) {
                    case (isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min:
                        (_a = dots.value[0]) === null || _a === void 0 ? void 0 : _a.focus();
                        moveDot(true, 0, 0);
                        break;
                    case (isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max:
                        (_b = dots.value[1]) === null || _b === void 0 ? void 0 : _b.focus();
                        moveDot(true, 1, 1);
                        break;
                    case (isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min:
                        moveDot(true, 0, 0);
                        break;
                    case (isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max:
                        moveDot(true, 1, 1);
                        break;
                    case (isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min:
                        moveDot(true, 0, 1);
                        break;
                    case (isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max:
                        moveDot(true, 1, 0);
                        break;
                }
            }
            else {
                if (props.vertical) {
                    if (event.key === 'ArrowDown') {
                        moveDot(false, 0, 0);
                    }
                    if (event.key === 'ArrowUp') {
                        moveDot(false, 1, 0);
                    }
                }
                else {
                    if (event.key === 'ArrowLeft') {
                        moveDot(false, 0, 0);
                    }
                    if (event.key === 'ArrowRight') {
                        moveDot(false, 1, 0);
                    }
                }
            }
        };
        const checkActivePin = (pin) => {
            if (Array.isArray(val.value)) {
                return pin * props.step > val.value[0] && pin * props.step < val.value[1];
            }
            else {
                return pin * props.step < val.value;
            }
        };
        const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
        const getPinStyles = (pin) => ({
            backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor(getColor(props.color)),
            [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
            transition: hasMouseDown.value ? 'none' : 'var(--va-slider-pin-transition)',
        });
        const getPos = (e) => {
            getStaticData();
            return props.vertical ? offset.value - e.clientY : e.clientX - offset.value;
        };
        const getStaticData = () => {
            if (sliderContainer.value) {
                size.value = sliderContainer.value[props.vertical ? 'offsetHeight' : 'offsetWidth'];
                offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
            }
        };
        const getValueByIndex = (index) => {
            return ((props.step * multiple.value) * index + (props.min * multiple.value)) / multiple.value;
        };
        const getTrackLabel = (val, order) => {
            if (!props.trackLabel) {
                return val;
            }
            return typeof props.trackLabel === 'function'
                ? props.trackLabel(val, order)
                : props.trackLabel;
        };
        const setCurrentValue = (newValue) => {
            const slider = currentSliderDotIndex.value;
            if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
                if (isDiff(currentValue.value[slider], newValue)) {
                    currentValue.value.splice(slider, 1, newValue);
                    if (slider === 0) {
                        val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
                        currentValue.value = [...val.value];
                    }
                    else {
                        val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
                        currentValue.value = [...val.value];
                    }
                }
            }
            else {
                if (newValue < props.min || newValue > props.max) {
                    return false;
                }
                if (isDiff(currentValue.value, newValue)) {
                    currentValue.value = newValue;
                    val.value = newValue;
                }
            }
        };
        const setValueOnPos = (pixelPosition) => {
            const range = limit.value;
            const valueRange = valueLimit.value;
            // set focus on current thumb
            const dotToFocus = Array.isArray(props.modelValue)
                ? dots.value[currentSliderDotIndex.value]
                : dot.value;
            dotToFocus === null || dotToFocus === void 0 ? void 0 : dotToFocus.focus();
            if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
                if (currentSliderDotIndex.value) {
                    if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
                        val.value[1] = val.value[0];
                        currentSliderDotIndex.value = 0;
                    }
                    const v = getValueByIndex(Math.round(pixelPosition / gap.value));
                    setCurrentValue(v);
                }
                else {
                    if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
                        val.value[0] = val.value[1];
                        currentSliderDotIndex.value = 1;
                    }
                    const v = getValueByIndex(Math.round(pixelPosition / gap.value));
                    setCurrentValue(v);
                }
            }
            else if (pixelPosition < range[0]) {
                setCurrentValue(valueRange[0]);
            }
            else {
                setCurrentValue(valueRange[1]);
            }
        };
        const limitValue = (val) => {
            const inRange = (v) => {
                if (v < props.min) {
                    return props.min;
                }
                else if (v > props.max) {
                    return props.max;
                }
                return v;
            };
            if (Array.isArray(val)) {
                if (val[0] >= val[1] && currentSliderDotIndex.value === 0) {
                    const v = inRange(val[1]);
                    return [v, v];
                }
                if (val[0] >= val[1] && currentSliderDotIndex.value === 1) {
                    const v = inRange(val[0]);
                    return [v, v];
                }
                return val.map((v) => inRange(v));
            }
            else {
                return inRange(val);
            }
        };
        const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
        const clickOnContainer = (e) => {
            if (props.disabled || props.readonly) {
                return;
            }
            const pos = ('touches' in e) ? getPos(e.touches[0]) : getPos(e);
            if (Array.isArray(position.value)) {
                currentSliderDotIndex.value = pos > ((position.value[1] - position.value[0]) / 2 + position.value[0]) ? 1 : 0;
            }
            hasMouseDown.value = true;
            setValueOnPos(pos);
            moveStart(e, currentSliderDotIndex.value);
        };
        const bindEvents = () => {
            document.addEventListener('mousemove', moving);
            document.addEventListener('touchmove', moving, { passive: false });
            document.addEventListener('mouseup', moveEnd);
            document.addEventListener('mouseleave', moveEnd);
            document.addEventListener('touchcancel', moveEnd);
            document.addEventListener('touchend', moveEnd);
            document.addEventListener('keydown', moveWithKeys);
        };
        const unbindEvents = () => {
            document.removeEventListener('mousemove', moving);
            document.removeEventListener('touchmove', moving);
            document.removeEventListener('mouseup', moveEnd);
            document.removeEventListener('mouseleave', moveEnd);
            document.removeEventListener('touchcancel', moveEnd);
            document.removeEventListener('touchend', moveEnd);
            document.removeEventListener('keydown', moveWithKeys);
        };
        const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
        const ariaAttributesComputed = computed(() => ({
            role: 'slider',
            ariaValuemin: props.min,
            ariaValuemax: props.max,
            ariaLabelledby: ariaLabelIdComputed.value,
            ariaOrientation: props.vertical ? 'vertical' : 'horizontal',
            ariaDisabled: props.disabled,
            ariaReadonly: props.readonly,
            ariaValuenow: !Array.isArray(props.modelValue) ? props.modelValue : undefined,
        }));
        onMounted(() => {
            if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
                getStaticData();
                bindEvents();
            }
        });
        onBeforeUnmount(unbindEvents);
        watch([
            val,
            () => props.step,
            () => props.min,
            () => props.max,
            () => props.range,
        ], ([value, step, min, max, range]) => {
            validateSlider(value, step, min, max, range);
        });
        watch(hasMouseDown, (hasMouseDown) => {
            document.documentElement.style.cursor = hasMouseDown ? 'grabbing' : '';
        });
        return {
            getColor,
            dot,
            dots,
            setItemRefByIndex,
            orders,
            sliderContainer,
            val,
            getValueByOrder,
            sliderClass,
            dotClass,
            labelStyles,
            processedStyles,
            getPinStyles,
            dottedStyles,
            getDottedStyles,
            clickOnContainer,
            hasMouseDown,
            trackStyles,
            pinsCol,
            checkActivePin,
            isFocused,
            isActiveDot,
            getTrackLabel,
            currentSliderDotIndex,
            ariaLabelIdComputed,
            ariaAttributesComputed,
        };
    },
});

const _hoisted_1 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
const _hoisted_2 = ["id"];
const _hoisted_3 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
const _hoisted_4 = ["tabindex", "onFocus"];
const _hoisted_5 = ["tabindex"];
const _hoisted_6 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
const _hoisted_7 = {
  key: 5,
  class: "va-slider__input-wrapper"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend)
      ? (openBlock(), createElementBlock("div", _hoisted_1, [
          renderSlot(_ctx.$slots, _ctx.vertical ? 'append' : 'prepend')
        ]))
      : createCommentVNode("v-if", true),
    ((_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel)
      ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "va-input__label",
          id: _ctx.ariaLabelIdComputed,
          style: normalizeStyle(_ctx.labelStyles)
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1 /* TEXT */)
          ])
        ], 12 /* STYLE, PROPS */, _hoisted_2))
      : createCommentVNode("v-if", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend)
      ? (openBlock(), createElementBlock("span", _hoisted_3, [
          createVNode(_component_va_icon, {
            name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
            color: _ctx.getColor(_ctx.$props.color),
            size: 16
          }, null, 8 /* PROPS */, ["name", "color"])
        ]))
      : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => (_ctx.clickOnContainer && _ctx.clickOnContainer(...args))),
      onMouseup: _cache[4] || (_cache[4] = $event => (_ctx.hasMouseDown = false)),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => (_ctx.clickOnContainer && _ctx.clickOnContainer(...args)))
    }, [
      createElementVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4 /* STYLE */),
      (_ctx.pins)
        ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i) => {
            return (openBlock(), createElementBlock("div", {
              key: i,
              class: normalizeClass(["va-slider__mark", { 'va-slider__mark--active': _ctx.checkActivePin(pin) }]),
              style: normalizeStyle(_ctx.getPinStyles(pin))
            }, null, 6 /* CLASS, STYLE */))
          }), 128 /* KEYED_FRAGMENT */))
        : createCommentVNode("v-if", true),
      (_ctx.$props.range)
        ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createElementVNode("div", {
              ref: "process",
              class: normalizeClass(["va-slider__track va-slider__track--selected", {'va-slider__track--active': _ctx.isFocused}]),
              "aria-hidden": "true",
              style: normalizeStyle(_ctx.processedStyles)
            }, null, 6 /* CLASS, STYLE */),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
              return (openBlock(), createElementBlock("div", {
                key: 'dot' + order,
                ref_for: true,
                ref: _ctx.setItemRefByIndex(order),
                class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
                style: normalizeStyle(_ctx.getDottedStyles(order)),
                tabindex: _ctx.disabled || _ctx.readonly ? undefined : 0,
                onFocus: $event => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
                onBlur: _cache[0] || (_cache[0] = $event => (_ctx.isFocused = false))
              }, [
                (_ctx.isActiveDot(order))
                  ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
                      class: "va-slider__handler__dot--focus"
                    }, null, 4 /* STYLE */))
                  : createCommentVNode("v-if", true),
                (_ctx.trackLabelVisible)
                  ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      style: normalizeStyle(_ctx.labelStyles),
                      class: "va-slider__handler__dot--value"
                    }, [
                      renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                        createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1 /* TEXT */)
                      ])
                    ], 4 /* STYLE */))
                  : createCommentVNode("v-if", true)
              ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_4))
            }), 128 /* KEYED_FRAGMENT */))
          ], 64 /* STABLE_FRAGMENT */))
        : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createElementVNode("div", {
              ref: "process",
              "aria-hidden": "true",
              class: normalizeClass(["va-slider__track va-slider__track--selected", {'va-slider__track--active': _ctx.isFocused}]),
              style: normalizeStyle(_ctx.processedStyles)
            }, null, 6 /* CLASS, STYLE */),
            createElementVNode("div", {
              ref: "dot",
              class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
              style: normalizeStyle(_ctx.dottedStyles),
              tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? undefined : 0,
              onFocus: _cache[1] || (_cache[1] = $event => (_ctx.isFocused = true)),
              onBlur: _cache[2] || (_cache[2] = $event => (_ctx.isFocused = false))
            }, [
              (_ctx.isActiveDot(0))
                ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "va-slider__handler__dot--focus",
                    style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
                  }, null, 4 /* STYLE */))
                : createCommentVNode("v-if", true),
              (_ctx.trackLabelVisible)
                ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "va-slider__handler__dot--value",
                    style: normalizeStyle(_ctx.labelStyles)
                  }, [
                    renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
                      createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1 /* TEXT */)
                    ])
                  ], 4 /* STYLE */))
                : createCommentVNode("v-if", true)
            ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_5)
          ], 64 /* STABLE_FRAGMENT */))
    ], 544 /* HYDRATE_EVENTS, NEED_PATCH */),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend)
      ? (openBlock(), createElementBlock("span", _hoisted_6, [
          createVNode(_component_va_icon, {
            name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
            color: _ctx.getColor(_ctx.$props.color),
            size: 16
          }, null, 8 /* PROPS */, ["name", "color"])
        ]))
      : createCommentVNode("v-if", true),
    ((_ctx.$slots.label || _ctx.label) && _ctx.invertLabel)
      ? (openBlock(), createElementBlock("span", {
          key: 4,
          class: "va-input__label va-input__label--inverse",
          style: normalizeStyle(_ctx.labelStyles)
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1 /* TEXT */)
          ])
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append)
      ? (openBlock(), createElementBlock("div", _hoisted_7, [
          renderSlot(_ctx.$slots, _ctx.vertical ? 'prepend' : 'append')
        ]))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script.render = render;
script.__file = "src/components/va-slider/VaSlider.vue";

const VaSlider = withConfigTransport(script);

export { VaSlider };
//# sourceMappingURL=index48.js.map
