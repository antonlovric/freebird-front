import { w as withConfigTransport } from './withConfigTransport.js';
import { computed, onMounted, onBeforeUnmount, ref, watch, defineComponent, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, Fragment, withKeys, withModifiers, renderSlot, createVNode, withCtx, createCommentVNode, renderList, mergeProps, normalizeProps, guardReactiveProps, createTextVNode, toDisplayString, createElementVNode } from 'vue';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import 'colortranslator';
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from './useStateful.js';
import { VaImage } from './index32.js';
import { VaButton } from './index12.js';
import { VaHover } from './index30.js';
import './VaConfig.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './VaButton.js';
import './useLoading.js';
import './useRouterLink.js';
import './useSize.js';
import './useTextColor.js';
import './index31.js';
import './VaIcon.js';
import './index43.js';
import './clamp.js';
import './toNumber.js';

const useCarousel = (props, currentSlide) => {
    const goTo = (index) => { currentSlide.value = index; };
    const prev = () => {
        if (props.infinite) {
            if (currentSlide.value <= 0) {
                currentSlide.value = props.items.length - 1;
                return;
            }
        }
        currentSlide.value -= 1;
    };
    const next = () => {
        if (props.infinite) {
            if (currentSlide.value >= props.items.length - 1) {
                currentSlide.value = 0;
                return;
            }
        }
        currentSlide.value += 1;
    };
    const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
    const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
    return {
        doShowPrevButton,
        doShowNextButton,
        goTo,
        prev,
        next,
    };
};

const useCarouselAnimation = (props, currentSlide) => {
    let animationInterval = -1;
    let direction = 1;
    const start = () => {
        if (!props.autoscroll) {
            return;
        }
        clearInterval(animationInterval);
        animationInterval = setInterval(() => {
            if (props.infinite) {
                currentSlide.value += 1;
                if (currentSlide.value >= props.items.length) {
                    currentSlide.value = 0;
                }
            }
            else {
                if (currentSlide.value <= 0) {
                    direction = 1;
                }
                if (currentSlide.value >= props.items.length - 1) {
                    direction = -1;
                }
                currentSlide.value += direction;
            }
        }, props.autoscrollInterval);
    };
    let pauseTimeout;
    const pause = () => {
        if (!props.autoscroll) {
            return;
        }
        clearInterval(animationInterval);
        pauseTimeout = setTimeout(() => {
            start();
            clearTimeout(pauseTimeout);
        }, props.autoscrollPauseDuration);
    };
    const stop = () => {
        clearInterval(animationInterval);
        clearTimeout(pauseTimeout);
    };
    onMounted(() => start());
    onBeforeUnmount(() => stop());
    const withPause = (fn) => {
        return (...args) => { pause(); fn(...args); };
    };
    const slidesContainerStyle = ref({
        transition: undefined,
    });
    /**
     * Used for infinite loop. In infinite loop additional first item is placed after all items.
     * Use own currentSlider, which will not update model value if we need to show slide that placed after all items
     */
    const sliderToBeShown = ref(0);
    const computedSlidesStyle = computed(() => {
        if (props.effect === 'fade') {
            return {
                ...slidesContainerStyle.value,
                transition: 'none',
            };
        }
        if (props.vertical) {
            return {
                ...slidesContainerStyle.value,
                transform: `translateY(${sliderToBeShown.value * -100}%)`,
            };
        }
        return {
            ...slidesContainerStyle.value,
            transform: `translateX(${sliderToBeShown.value * -100}%)`,
        };
    });
    const animator = {
        isAnimating: false,
        speed: 0.3,
        order: [],
        move(from, to) {
            const last = props.items.length - 1;
            const firstAfterLast = props.items.length;
            if (to === 0 && from === last) {
                this.order.push({ to: firstAfterLast });
                this.order.push({ to: 0, animate: false });
            }
            else if (to === last && from === 0) {
                this.order.push({ to: firstAfterLast, animate: false });
                this.order.push({ to });
            }
            else {
                this.order.push({ to });
            }
            if (!this.isAnimating) {
                this.runAnimation();
            }
        },
        runAnimation() {
            this.isAnimating = true;
            const animation = this.order.shift();
            if (!animation) {
                this.isAnimating = false;
                return;
            }
            sliderToBeShown.value = animation === null || animation === void 0 ? void 0 : animation.to;
            if (animation.animate || animation.animate === undefined) {
                slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
                setTimeout(() => { this.runAnimation(); }, this.speed * 1000);
            }
            else {
                slidesContainerStyle.value.transition = 'none';
                setTimeout(() => { this.runAnimation(); }, 16);
            }
        },
    };
    watch(currentSlide, (newValue, oldValue) => {
        animator.move(oldValue, newValue);
    });
    /** Animation should control how much slides to display */
    const slides = computed(() => {
        if (props.effect === 'fade') {
            return [props.items[currentSlide.value]];
        }
        if (props.infinite) {
            return [...props.items, props.items[0]];
        }
        return props.items;
    });
    return {
        start,
        pause,
        stop,
        withPause,
        computedSlidesStyle,
        slides,
    };
};

const useCarouselColor = () => {
    const { setHSLAColor, getColor } = useColors();
    return {
        computedColor: computed(() => setHSLAColor(getColor('dark'), { a: 0.7 })),
        computedHoverColor: computed(() => setHSLAColor(getColor('primary'), { a: 0.7 })),
        computedActiveColor: computed(() => getColor('primary')),
    };
};

var script = defineComponent({
    name: 'VaCarousel',
    components: { VaImage, VaButton, VaHover },
    props: {
        ...useStatefulProps,
        modelValue: { type: Number, default: 0 },
        items: { type: Array, required: true },
        // Animations
        autoscroll: { type: Boolean, default: false },
        autoscrollInterval: { type: Number, default: 1000 },
        autoscrollPauseDuration: { type: Number, default: 2000 },
        infinite: { type: Boolean, default: false },
        fadeKeyframe: { type: String, default: 'va-carousel-fade-appear 1s' },
        // Visual
        arrows: { type: Boolean, default: true },
        indicators: { type: Boolean, default: true },
        indicatorTrigger: {
            type: String,
            default: 'click',
            validator: (value) => ['click', 'hover'].includes(value),
        },
        vertical: { type: Boolean, default: false },
        height: { type: String, default: '300px' },
        effect: {
            type: String,
            default: 'transition',
            validator: (value) => ['fade', 'transition'].includes(value),
        },
        color: { type: String, default: 'primary' },
    },
    emits: useStatefulEmits,
    setup(props, { emit }) {
        const { valueComputed: currentSlide } = useStateful(props, emit, 0);
        const { goTo, next, prev, doShowNextButton, doShowPrevButton, } = useCarousel(props, currentSlide);
        const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
        const isObjectSlides = computed(() => {
            return props.items.length && props.items.every((el) => !!el && typeof el === 'object' && !!(el === null || el === void 0 ? void 0 : el.src));
        });
        const isCurrentSlide = (index) => +index === currentSlide.value;
        return {
            doShowNextButton,
            doShowPrevButton,
            computedSlidesStyle,
            goTo: withPause(goTo),
            prev: withPause(prev),
            next: withPause(next),
            slides,
            isObjectSlides,
            isCurrentSlide,
            ...useCarouselColor(),
        };
    },
});

const _hoisted_1 = {
  key: 1,
  class: "va-carousel__indicators"
};
const _hoisted_2 = { class: "va-carousel__content" };
const _hoisted_3 = ["aria-hidden", "aria-current", "aria-label"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      'va-carousel--vertical': _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.height }),
    role: "region",
    "aria-label": "carousel"
  }, [
    (_ctx.$props.arrows)
      ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          (_ctx.doShowPrevButton)
            ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-carousel__arrow va-carousel__arrow--left",
                onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.prev && _ctx.prev(...args))),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => (_ctx.prev && _ctx.prev(...args)), ["stop"]), ["enter"]))
              }, [
                renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
                  createVNode(_component_va_hover, { stateful: "" }, {
                    default: withCtx(({ hover }) => [
                      createVNode(_component_va_button, {
                        color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                        icon: _ctx.vertical ? 'expand_less' : 'chevron_left',
                        "aria-label": "go previous slide"
                      }, null, 8 /* PROPS */, ["color", "icon"])
                    ]),
                    _: 1 /* STABLE */
                  })
                ])
              ], 32 /* HYDRATE_EVENTS */))
            : createCommentVNode("v-if", true),
          (_ctx.doShowNextButton)
            ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "va-carousel__arrow va-carousel__arrow--right",
                onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.next && _ctx.next(...args))),
                onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => (_ctx.next && _ctx.next(...args)), ["stop"]), ["enter"]))
              }, [
                renderSlot(_ctx.$slots, "next-arrow", {}, () => [
                  createVNode(_component_va_hover, { stateful: "" }, {
                    default: withCtx(({ hover }) => [
                      createVNode(_component_va_button, {
                        color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                        icon: _ctx.vertical ? 'expand_more' : 'chevron_right',
                        "aria-label": "go next slide"
                      }, null, 8 /* PROPS */, ["color", "icon"])
                    ]),
                    _: 1 /* STABLE */
                  })
                ])
              ], 32 /* HYDRATE_EVENTS */))
            : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */))
      : createCommentVNode("v-if", true),
    (_ctx.$props.indicators)
      ? (openBlock(), createElementBlock("div", _hoisted_1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
            return (openBlock(), createElementBlock("div", mergeProps({
              class: ["va-carousel__indicator", { 'va-carousel__indicator--active': index === _ctx.modelValue }],
              key: index
            }, _ctx.indicatorTrigger === 'hover' ? { onmouseover: () => _ctx.goTo(index) } : { onclick: () => _ctx.goTo(index) }), [
              renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
                createVNode(_component_va_hover, { stateful: "" }, {
                  default: withCtx(({ hover }) => [
                    createVNode(_component_va_button, {
                      "aria-label": `go slide #${index + 1}`,
                      round: "",
                      color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : (hover ? _ctx.computedHoverColor : _ctx.computedColor)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(index + 1), 1 /* TEXT */)
                      ]),
                      _: 2 /* DYNAMIC */
                    }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["aria-label", "color"])
                  ]),
                  _: 2 /* DYNAMIC */
                }, 1024 /* DYNAMIC_SLOTS */)
              ])
            ], 16 /* FULL_PROPS */))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : createCommentVNode("v-if", true),
    createElementVNode("div", _hoisted_2, [
      createElementVNode("div", {
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return (openBlock(), createElementBlock("div", {
            class: "va-carousel__slide",
            key: item,
            style: normalizeStyle(_ctx.effect === 'fade' ? { animation: _ctx.fadeKeyframe } : ''),
            role: "listitem",
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": `slide ${index + 1} of ${_ctx.slides.length}`
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : ''
              }, null, 8 /* PROPS */, ["src", "alt"])
            ])
          ], 12 /* STYLE, PROPS */, _hoisted_3))
        }), 128 /* KEYED_FRAGMENT */))
      ], 4 /* STYLE */)
    ])
  ], 6 /* CLASS, STYLE */))
}

script.render = render;
script.__file = "src/components/va-carousel/VaCarousel.vue";

const VaCarousel = withConfigTransport(script);

export { VaCarousel };
//# sourceMappingURL=index14.js.map
