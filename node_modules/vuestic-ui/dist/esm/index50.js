import { w as withConfigTransport } from './withConfigTransport.js';
import { ref, watch, onMounted, onBeforeUnmount, unref, defineComponent, shallowRef, reactive, computed, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, createBlock, createCommentVNode, normalizeStyle, createVNode, withCtx, renderSlot, inject, resolveDynamicComponent, mergeProps, toHandlers, withKeys, toDisplayString } from 'vue';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { a as useStatefulProps, b as useStateful } from './useStateful.js';
import { VaButton } from './index12.js';
import { V as VaConfig } from './VaConfig.js';
import { u as useKeyboardOnlyFocus } from './useKeyboardOnlyFocus.js';
import { u as useRouterLinkProps, a as useRouterLink } from './useRouterLink.js';
import { VaIcon } from './index31.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import 'colortranslator';
import './VaButton.js';
import './useLoading.js';
import './useSize.js';
import './useTextColor.js';
import './index43.js';
import './clamp.js';
import './toNumber.js';
import './VaIcon.js';

const useResizeObserver = (elementsList, cb) => {
    const resizeObserver = ref();
    const observeAll = (elementsList) => {
        elementsList.forEach((element) => {
            var _a;
            const unrefedElement = unref(element);
            unrefedElement && ((_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.observe(unrefedElement));
        });
    };
    watch(elementsList, (newValue) => {
        var _a;
        (_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.disconnect();
        observeAll(newValue);
    });
    onMounted(() => {
        resizeObserver.value = new ResizeObserver(cb);
        observeAll(elementsList);
    });
    onBeforeUnmount(() => { var _a; return (_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.disconnect(); });
    return resizeObserver;
};

const TabsViewKey = Symbol('TabsView');
const TabKey = Symbol('Tab');

const getClientWidth = (element) => (element === null || element === void 0 ? void 0 : element.clientWidth) || 0;
var script$1 = defineComponent({
    name: 'VaTabs',
    components: { VaButton, VaConfig },
    emits: ['update:modelValue', 'click:next', 'click:prev'],
    props: {
        ...useStatefulProps,
        modelValue: { type: [String, Number], default: null },
        left: { type: Boolean, default: true },
        right: { type: Boolean, default: false },
        center: { type: Boolean, default: false },
        grow: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        hideSlider: { type: Boolean, default: false },
        vertical: { type: Boolean, default: false },
        color: { type: String, default: 'primary' },
        prevIcon: { type: String, default: 'chevron_left' },
        nextIcon: { type: String, default: 'chevron_right' },
    },
    setup: (props, { emit }) => {
        const wrapper = shallowRef();
        const container = shallowRef();
        const tabs = shallowRef();
        const tabsList = ref([]);
        const sliderHeight = ref(null);
        const sliderWidth = ref(null);
        const sliderOffsetX = ref(0);
        const sliderOffsetY = ref(0);
        const showPagination = ref(false);
        const tabsContentOffset = ref(0);
        const startingXPoint = ref(0);
        const animationIncluded = ref(false);
        const { valueComputed: tabSelected } = useStateful(props, emit);
        const tabConfig = reactive({
            VaTab: {
                color: props.color,
            },
        });
        const computedClass = computed(() => {
            const { left, right, center, grow, disabled } = props;
            return {
                'va-tabs__container--left': left && !right && !center && !grow,
                'va-tabs__container--right': right,
                'va-tabs__container--center': center,
                'va-tabs__container--grow': grow,
                'va-tabs__container--disabled': disabled,
            };
        });
        const computedTabsClass = computed(() => ({ 'va-tabs--vertical': props.vertical }));
        const { getColor } = useColors();
        const colorComputed = computed(() => getColor(props.color));
        const sliderStyles = computed(() => {
            if (props.hideSlider) {
                return { display: 'none' };
            }
            return {
                backgroundColor: colorComputed.value,
                height: props.vertical ? `${sliderHeight.value}px` : '',
                width: props.vertical ? '' : `${sliderWidth.value}px`,
                transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
                transition: animationIncluded.value ? 'var(--va-tabs-slider-wrapper-transition)' : '',
            };
        });
        const paginationControlledStyles = computed(() => {
            // Prevents the movement of vertical tabs
            if (props.vertical) {
                return {
                    transform: 'translateX(0px)',
                };
            }
            return {
                transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
                transition: animationIncluded.value ? 'var(--va-tabs-slider-transition)' : '',
            };
        });
        const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
        const disablePaginationRight = computed(() => {
            const lastTab = tabsList.value[tabsList.value.length - 1];
            const leftSidePosition = unref(lastTab.leftSidePosition);
            const rightSidePosition = unref(lastTab.rightSidePosition);
            const containerClientWidth = getClientWidth(container.value);
            return rightSidePosition <= tabsContentOffset.value + containerClientWidth ||
                leftSidePosition <= tabsContentOffset.value;
        });
        // Methods
        const resetSliderSizes = () => {
            sliderWidth.value = 0;
            sliderHeight.value = 0;
        };
        const moveToTab = (tab) => {
            const containerClientWidth = getClientWidth(container.value);
            const tabsClientWidth = getClientWidth(tabs.value);
            const leftSidePosition = unref(tab.leftSidePosition);
            const rightSidePosition = unref(tab.rightSidePosition);
            if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
                tabsContentOffset.value = leftSidePosition;
            }
            else if (showPagination.value && rightSidePosition >= containerClientWidth) {
                tabsContentOffset.value = rightSidePosition - containerClientWidth;
            }
            else {
                tabsContentOffset.value = 0;
            }
        };
        const updateStartingXPoint = () => {
            startingXPoint.value = 0;
            if (!showPagination.value) {
                return;
            }
            const containerClientWidth = getClientWidth(container.value);
            const tabsClientWidth = getClientWidth(tabs.value);
            if (props.right) {
                startingXPoint.value = tabsClientWidth - containerClientWidth;
            }
            else if (props.center) {
                startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
            }
        };
        const updateTabsState = () => {
            resetSliderSizes();
            tabsList.value.forEach((tab) => {
                var _a;
                tab.updateSidePositions();
                const isTabSelected = (((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || tab.id) === tabSelected.value;
                tab.isActive = tab.isActiveRouterLink || isTabSelected;
                if (tab.isActive) {
                    moveToTab(tab);
                    updateSlider(tab);
                }
            });
            const containerClientWidth = getClientWidth(container.value);
            const tabsClientWidth = getClientWidth(tabs.value);
            if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value) {
                moveToTab(tabsList.value[0]);
            }
            updateStartingXPoint();
        };
        const updatePagination = () => {
            const tabsClientWidth = getClientWidth(tabs.value);
            const wrapperClientWidth = getClientWidth(wrapper.value);
            showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
        };
        const movePaginationLeft = () => {
            var _a, _b;
            const containerClientWidth = getClientWidth(container.value);
            let offsetToSet = tabsContentOffset.value - containerClientWidth;
            if (tabsList.value) {
                for (let i = 0; i < tabsList.value.length - 1; i++) {
                    const currentTabLeftSidePosition = unref((_a = tabsList.value[i]) === null || _a === void 0 ? void 0 : _a.leftSidePosition);
                    const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) === null || _b === void 0 ? void 0 : _b.leftSidePosition);
                    if ((currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value) ||
                        nextTabLeftSidePosition >= tabsContentOffset.value) {
                        offsetToSet = currentTabLeftSidePosition;
                        break;
                    }
                }
            }
            tabsContentOffset.value = Math.max(0, offsetToSet);
            emit('click:prev');
        };
        const movePaginationRight = () => {
            var _a;
            const containerClientWidth = getClientWidth(container.value);
            const containerRightSide = tabsContentOffset.value + containerClientWidth;
            let offsetToSet = containerRightSide;
            if (tabsList.value) {
                for (let i = 0; i < tabsList.value.length - 1; i++) {
                    const rightSidePosition = unref(tabsList.value[i].rightSidePosition);
                    if (rightSidePosition > containerRightSide) {
                        offsetToSet = unref(tabsList.value[i].leftSidePosition);
                        if (tabsContentOffset.value < offsetToSet) {
                            break;
                        }
                    }
                }
            }
            const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) === null || _a === void 0 ? void 0 : _a.rightSidePosition);
            const maxOffset = rightSidePosition - containerClientWidth;
            offsetToSet = Math.min(maxOffset, offsetToSet);
            tabsContentOffset.value = Math.max(0, offsetToSet);
            emit('click:next');
        };
        const updateSlider = (tab) => {
            var _a;
            const tabElement = unref(tab.tabElement);
            const tabOffsetTop = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.offsetTop) || 0;
            const tabOffsetLeft = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.offsetLeft) || 0;
            const tabClientHeight = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.clientHeight) || 0;
            const tabClientWidth = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.clientWidth) || 0;
            if (props.vertical) {
                const containerClientHeight = ((_a = container.value) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;
                const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
                sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
                sliderHeight.value = tabClientHeight;
                sliderOffsetX.value = 0;
                sliderWidth.value = 0;
            }
            else {
                sliderOffsetX.value = tabOffsetLeft;
                sliderWidth.value = tabClientWidth;
                sliderOffsetY.value = 0;
                sliderHeight.value = 0;
            }
        };
        const includeAnimation = () => {
            if (!animationIncluded.value) {
                requestAnimationFrame(() => {
                    animationIncluded.value = true;
                });
            }
        };
        const redrawTabs = () => {
            const oldShowPaginationValue = showPagination.value;
            updatePagination();
            if (oldShowPaginationValue === showPagination.value) {
                updateTabsState();
                includeAnimation();
            }
            else {
                requestAnimationFrame(() => {
                    updateTabsState();
                    includeAnimation();
                });
            }
        };
        const selectTab = (tab) => {
            var _a;
            if (!tab) {
                return;
            }
            tabSelected.value = ((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || tab.id;
            if (props.stateful) {
                updateTabsState();
            }
        };
        const registerTab = (tab) => {
            var _a;
            const idx = tabsList.value.push(tab) - 1;
            tab.id = ((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || idx;
        };
        const unregisterTab = (tab) => {
            tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
            tabsList.value.forEach((tabListItem, idx) => {
                var _a;
                tabListItem.id = ((_a = tabListItem.name) === null || _a === void 0 ? void 0 : _a.value) || idx;
            });
        };
        provide(TabsViewKey, {
            parentDisabled: props.disabled,
            selectTab,
            moveToTab,
            registerTab,
            unregisterTab,
        });
        // Lifecycle hooks
        watch(() => props.modelValue, updateTabsState);
        useResizeObserver([wrapper, tabs], redrawTabs);
        return {
            wrapper,
            container,
            tabs,
            tabsList,
            sliderHeight,
            sliderWidth,
            sliderOffsetX,
            sliderOffsetY,
            showPagination,
            tabsContentOffset,
            startingXPoint,
            animationIncluded,
            colorComputed,
            tabConfig,
            computedClass,
            computedTabsClass,
            tabSelected,
            sliderStyles,
            paginationControlledStyles,
            disablePaginationLeft,
            disablePaginationRight,
            resetSliderSizes,
            moveToTab,
            updateStartingXPoint,
            updateTabsState,
            updatePagination,
            movePaginationLeft,
            movePaginationRight,
            updateSlider,
            includeAnimation,
            redrawTabs,
            selectTab,
        };
    },
});

const _hoisted_1$1 = ["aria-disabled"];
const _hoisted_2$1 = /*#__PURE__*/createElementVNode("div", { class: "va-tabs__slider" }, null, -1 /* HOISTED */);
const _hoisted_3 = [
  _hoisted_2$1
];
const _hoisted_4 = { class: "va-tabs__tabs-items" };
const _hoisted_5 = { class: "va-tabs__content" };

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createElementVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      (_ctx.showPagination)
        ? (openBlock(), createBlock(_component_va_button, {
            key: 0,
            class: "va-tabs__pagination",
            "aria-label": "move pagination left",
            size: "medium",
            disabled: _ctx.disablePaginationLeft,
            color: _ctx.color,
            flat: "",
            icon: _ctx.$props.prevIcon,
            onClick: _ctx.movePaginationLeft
          }, null, 8 /* PROPS */, ["disabled", "color", "icon", "onClick"]))
        : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createElementVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createElementVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_3, 4 /* STYLE */),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_4, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3 /* FORWARDED */
          }, 8 /* PROPS */, ["components"])
        ], 4 /* STYLE */)
      ], 2 /* CLASS */),
      (_ctx.showPagination)
        ? (openBlock(), createBlock(_component_va_button, {
            key: 1,
            class: "va-tabs__pagination",
            "aria-label": "move pagination right",
            size: "medium",
            color: _ctx.color,
            disabled: _ctx.disablePaginationRight,
            flat: "",
            icon: _ctx.$props.nextIcon,
            onClick: _ctx.movePaginationRight
          }, null, 8 /* PROPS */, ["color", "disabled", "icon", "onClick"]))
        : createCommentVNode("v-if", true)
    ], 8 /* PROPS */, _hoisted_1$1),
    createElementVNode("div", _hoisted_5, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2 /* CLASS */))
}

script$1.render = render$1;
script$1.__file = "src/components/va-tabs/VaTabs.vue";

var script = defineComponent({
    name: 'VaTab',
    components: { VaIcon },
    emits: ['click', 'keydown-enter', 'focus'],
    props: {
        ...useRouterLinkProps,
        selected: { type: Boolean, default: false },
        color: { type: String, default: '' },
        icon: { type: String, default: '' },
        label: { type: String, default: '' },
        disabled: { type: Boolean },
        name: { type: [String, Number] },
        tag: { type: String, default: 'div' },
    },
    setup: (props, { emit }) => {
        const tabElement = shallowRef();
        const isActive = ref(false);
        const hoverState = ref(false);
        const rightSidePosition = ref(0);
        const leftSidePosition = ref(0);
        const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
        const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
        const classComputed = computed(() => ({ 'va-tab--disabled': props.disabled }));
        const { parentDisabled, selectTab, moveToTab, registerTab, unregisterTab, } = inject(TabsViewKey, {
            parentDisabled: false,
            tabsList: [],
            selectTab: (tab) => tab,
            moveToTab: (tab) => tab,
            registerTab: (tab) => tab,
            unregisterTab: (tab) => tab,
        });
        const tabIndexComputed = computed(() => (props.disabled || parentDisabled) ? -1 : 0);
        const { getColor } = useColors();
        const colorComputed = computed(() => getColor(props.color));
        const computedStyle = computed(() => ({
            color: hasKeyboardFocus.value || hoverState.value || isActive.value ? colorComputed.value : 'inherit',
        }));
        const updateHoverState = (isHover) => {
            hoverState.value = isHover;
        };
        const updateSidePositions = () => {
            var _a, _b;
            const componentOffsetLeft = ((_a = tabElement.value) === null || _a === void 0 ? void 0 : _a.offsetLeft) || 0;
            const componentOffsetWidth = ((_b = tabElement.value) === null || _b === void 0 ? void 0 : _b.offsetWidth) || 0;
            rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
            leftSidePosition.value = componentOffsetLeft;
        };
        const onTabClick = () => {
            selectTab(tabComponent);
            emit('click');
        };
        const onTabKeydown = () => {
            selectTab(tabComponent);
            emit('keydown-enter');
        };
        const onFocus = () => {
            if (hasKeyboardFocus.value) {
                moveToTab(tabComponent);
            }
            emit('focus');
        };
        const tabComponent = {
            name: computed(() => props.name),
            id: null,
            tabElement,
            isActive,
            tabIndexComputed,
            isActiveRouterLink,
            rightSidePosition,
            leftSidePosition,
            onTabClick,
            onTabKeydown,
            onFocus,
            updateSidePositions,
        };
        onMounted(() => {
            registerTab(tabComponent);
        });
        onBeforeUnmount(() => {
            unregisterTab(tabComponent);
        });
        return {
            tabElement,
            parentDisabled,
            isActive,
            hoverState,
            hasKeyboardFocus,
            keyboardFocusListeners,
            tagComputed,
            hrefComputed,
            isActiveRouterLink,
            colorComputed,
            classComputed,
            computedStyle,
            tabIndexComputed,
            rightSidePosition,
            leftSidePosition,
            updateHoverState,
            updateSidePositions,
            onTabClick,
            onTabKeydown,
            onFocus,
        };
    },
});

const _hoisted_1 = ["tabindex"];
const _hoisted_2 = ["textContent"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");

  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = $event => (_ctx.updateHoverState(true))),
    onMouseleave: _cache[4] || (_cache[4] = $event => (_ctx.updateHoverState(false)))
  }, {
    default: withCtx(() => [
      createElementVNode("div", mergeProps({ class: "va-tab__content" }, toHandlers(_ctx.keyboardFocusListeners), {
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => (_ctx.onFocus && _ctx.onFocus(...args))),
        onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.onTabClick && _ctx.onTabClick(...args))),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => (_ctx.onTabKeydown && _ctx.onTabKeydown(...args)), ["enter"]))
      }), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          (_ctx.icon)
            ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                class: "va-tab__icon",
                size: "small",
                name: _ctx.icon
              }, null, 8 /* PROPS */, ["name"]))
            : createCommentVNode("v-if", true),
          createElementVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8 /* PROPS */, _hoisted_2)
        ])
      ], 16 /* FULL_PROPS */, _hoisted_1)
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]))
}

script.render = render;
script.__file = "src/components/va-tabs/components/VaTab/VaTab.vue";

const VaTab = withConfigTransport(script);

const VaTabs = withConfigTransport(script$1);

export { TabKey, TabsViewKey, VaTab, VaTabs };
//# sourceMappingURL=index50.js.map
