import { w as withConfigTransport } from './withConfigTransport.js';
import { unref, isRef, watch, defineComponent, shallowRef, computed, toRef, openBlock, createElementBlock, normalizeClass, createElementVNode, renderSlot, createBlock, Teleport, withModifiers, createCommentVNode, normalizeStyle } from 'vue';
import { p as placementsPositions, u as usePopover, e as pick_1 } from './usePopover.js';
import { u as useBem } from './useBem.js';
import { u as useCaptureEvent } from './useCaptureEvent.js';
import './global-config.js';
import 'colortranslator';
import { d as debounce_1 } from './debounce.js';
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from './useStateful.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { u as useTextColor } from './useTextColor.js';
import './VaConfig.js';
import './isSymbol.js';
import './ssr-utils.js';
import './_createCompounder.js';
import './global-properties.js';
import './toNumber.js';

const checkIfElementChild = (parent, child) => {
    if (!child) {
        return false;
    }
    if (child.parentElement === parent) {
        return true;
    }
    return parent.contains(child);
};
const safeArray = (a) => Array.isArray(a) ? a : [a];
const useClickOutside = (elements, cb) => {
    useCaptureEvent('click', (event) => {
        const clickTarget = event.target;
        const isClickInside = safeArray(elements)
            .some((element) => unref(element) && checkIfElementChild(unref(element), clickTarget));
        if (!isClickInside) {
            cb(clickTarget);
        }
    });
};

/** Used for debounced callbacks. Can be used to show cb near debounce call in code structure. */
const useDebounceFn = (timeout) => {
    let callback = null;
    const createDebounced = () => {
        return debounce_1(() => {
            callback === null || callback === void 0 ? void 0 : callback();
            callback = null;
        }, unref(timeout));
    };
    let debounced = createDebounced();
    if (isRef(timeout)) {
        watch(timeout, () => { debounced = createDebounced(); });
    }
    return {
        // todo check if we need to create proxy here
        debounced: (cb) => { callback = cb; debounced(); },
        cancel: () => debounced.cancel(),
    };
};

var script$1 = defineComponent({
    name: 'VaDropdown',
    props: {
        ...useStatefulProps,
        stateful: { default: true },
        modelValue: { type: Boolean, default: false },
        disabled: { type: Boolean },
        readonly: { type: Boolean },
        anchorSelector: { type: String, default: '' },
        attachElement: { type: String, default: 'body' },
        disableAttachment: { type: Boolean, default: false },
        keepAnchorWidth: { type: Boolean, default: false },
        isContentHoverable: { type: Boolean, default: true },
        closeOnContentClick: { type: Boolean, default: true },
        closeOnClickOutside: { type: Boolean, default: true },
        closeOnAnchorClick: { type: Boolean, default: true },
        hoverOverTimeout: { type: Number, default: 30 },
        hoverOutTimeout: { type: Number, default: 200 },
        offset: { type: [Array, Number], default: 0 },
        trigger: {
            type: String,
            default: 'click',
            validator: (value) => ['click', 'hover', 'none'].includes(value),
        },
        placement: {
            type: String,
            default: 'bottom',
            validator: (value) => placementsPositions.includes(value),
        },
    },
    emits: [...useStatefulEmits, 'anchor-click', 'dropdown-content-click', 'click-outside'],
    setup(props, { emit }) {
        const anchorRef = shallowRef();
        const contentRef = shallowRef();
        const { valueComputed: statefulVal } = useStateful(props, emit);
        const valueComputed = computed({
            get: () => statefulVal.value && !props.disabled && !props.readonly,
            set(val) { statefulVal.value = val; },
        });
        const computedClass = useBem('va-dropdown', () => pick_1(props, ['disabled']));
        // to be able to select specific anchor element inside anchorRef
        const computedAnchorRef = computed(() => (anchorRef.value && props.anchorSelector
            ? anchorRef.value.querySelector(props.anchorSelector) || anchorRef.value
            : anchorRef.value));
        usePopover(computedAnchorRef, contentRef, computed(() => ({
            placement: props.placement,
            keepAnchorWidth: props.keepAnchorWidth,
            offset: props.offset,
            stickToEdges: true,
            autoPlacement: true,
            root: props.attachElement,
        })));
        const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, 'hoverOverTimeout'));
        const onMouseEnter = () => {
            if (props.trigger !== 'hover' || props.disabled) {
                return;
            }
            debounceHover(() => { valueComputed.value = true; });
            cancelUnHoverDebounce();
        };
        const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, 'hoverOutTimeout'));
        const onMouseLeave = () => {
            if (props.trigger !== 'hover' || props.disabled) {
                return;
            }
            if (props.isContentHoverable) {
                debounceUnHover(() => { valueComputed.value = false; });
            }
            else {
                valueComputed.value = false;
            }
            cancelHoverDebounce();
        };
        const emitAndClose = (eventName, close) => {
            emit(eventName);
            if (close) {
                valueComputed.value = false;
            }
        };
        const onAnchorClick = () => {
            if (props.trigger !== 'click' || props.disabled) {
                return;
            }
            if (valueComputed.value) {
                emitAndClose('anchor-click', props.closeOnAnchorClick);
            }
            else {
                valueComputed.value = true;
                emit('anchor-click');
            }
        };
        useClickOutside([anchorRef, contentRef], () => {
            if (props.closeOnClickOutside && valueComputed.value) {
                emitAndClose('click-outside', props.closeOnClickOutside);
            }
        });
        return {
            valueComputed,
            anchorRef,
            contentRef,
            computedClass,
            emitAndClose,
            onAnchorClick,
            onMouseEnter,
            onMouseLeave,
        };
    },
});

const _hoisted_1 = ["aria-disabled", "aria-expanded"];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    "aria-haspopup": "listbox",
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed
  }, [
    createElementVNode("div", {
      ref: "anchorRef",
      class: "va-dropdown__anchor",
      onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.onAnchorClick && _ctx.onAnchorClick(...args))),
      onMouseenter: _cache[1] || (_cache[1] = (...args) => (_ctx.onMouseEnter && _ctx.onMouseEnter(...args))),
      onMouseleave: _cache[2] || (_cache[2] = (...args) => (_ctx.onMouseLeave && _ctx.onMouseLeave(...args)))
    }, [
      renderSlot(_ctx.$slots, "anchor")
    ], 544 /* HYDRATE_EVENTS, NEED_PATCH */),
    (_ctx.valueComputed)
      ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: _ctx.attachElement,
          disabled: _ctx.disableAttachment
        }, [
          createElementVNode("div", {
            ref: "contentRef",
            class: "va-dropdown__content-wrapper",
            onMouseover: _cache[3] || (_cache[3] = $event => (_ctx.$props.isContentHoverable && _ctx.onMouseEnter())),
            onMouseout: _cache[4] || (_cache[4] = (...args) => (_ctx.onMouseLeave && _ctx.onMouseLeave(...args))),
            onClick: _cache[5] || (_cache[5] = withModifiers($event => (_ctx.emitAndClose('dropdown-content-click', _ctx.closeOnContentClick)), ["stop"]))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 544 /* HYDRATE_EVENTS, NEED_PATCH */)
        ], 8 /* PROPS */, ["to", "disabled"]))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1))
}

script$1.render = render$1;
script$1.__file = "src/components/va-dropdown/VaDropdown.vue";

var script = defineComponent({
    name: 'VaDropdownContent',
    props: {
        noPadding: { type: Boolean, default: false },
        background: { type: String, default: 'white' },
        textColor: { type: String },
    },
    setup(props) {
        const { getColor } = useColors();
        const { textColorComputed } = useTextColor(toRef(props, 'background'));
        const computedStyle = computed(() => ({
            background: getColor(props.background, undefined, true),
            color: textColorComputed.value,
            padding: props.noPadding ? 0 : undefined,
        }));
        return { computedStyle };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4 /* STYLE */))
}

script.render = render;
script.__file = "src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.vue";

const VaDropdownContent = withConfigTransport(script);

const VaDropdown = withConfigTransport(script$1);

export { VaDropdown, VaDropdownContent };
//# sourceMappingURL=index27.js.map
