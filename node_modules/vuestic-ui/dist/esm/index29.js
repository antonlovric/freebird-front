import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, ref, provide, onMounted, inject, nextTick, onUnmounted, openBlock, createBlock, resolveDynamicComponent, withCtx, renderSlot } from 'vue';
import { F as FormServiceKey } from './consts.js';
import './VaConfig.js';
import './global-config.js';
import './global-properties.js';

const isVaForm = (value) => !!value.focusInvalid;
var script = defineComponent({
    name: 'VaForm',
    emits: ['validation'],
    props: {
        autofocus: { type: Boolean, default: false },
        tag: { type: String, default: 'div' },
    },
    setup(props, { emit }) {
        const nestedFormElements = ref([]);
        const parentFormProvider = () => inject(FormServiceKey, undefined);
        provide(FormServiceKey, {
            onChildMounted: (child) => childMountedHandler(child),
            onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild),
        });
        const childMountedHandler = (child) => {
            nestedFormElements.value.push(child);
        };
        const childUnmountedHandler = (removableChild) => {
            nestedFormElements.value = nestedFormElements.value.filter(child => child !== removableChild);
        };
        /** @public */
        const reset = () => {
            nestedFormElements.value
                .filter(({ reset }) => reset)
                .forEach((item) => { item.reset(); });
        };
        const resetValidation = () => {
            nestedFormElements.value
                .filter(({ resetValidation }) => resetValidation)
                .forEach((item) => { item.resetValidation(); });
        };
        const focus = () => { var _a; (_a = nestedFormElements.value.find(({ focus }) => focus)) === null || _a === void 0 ? void 0 : _a.focus(); };
        const focusInvalid = () => {
            const invalidComponent = nestedFormElements.value
                .find((item) => !isVaForm(item) && item.hasError());
            if (invalidComponent) {
                invalidComponent.focus();
            }
            else {
                nestedFormElements.value
                    .forEach(item => isVaForm(item) && item.focusInvalid());
            }
        };
        // validation for every nested child
        const validate = () => {
            const formValid = nestedFormElements.value
                .filter(({ validate }) => validate)
                .map((child) => child.validate()) // more readable than with 'forEach'
                .every((isValid) => isValid);
            emit('validation', formValid);
            return formValid;
        };
        const publicMethods = {
            reset,
            resetValidation,
            focus,
            focusInvalid,
            validate,
        };
        onMounted(() => {
            var _a, _b;
            (_b = (_a = parentFormProvider()) === null || _a === void 0 ? void 0 : _a.onChildMounted) === null || _b === void 0 ? void 0 : _b.call(_a, publicMethods);
            if (props.autofocus) {
                nextTick(focus);
            }
        });
        onUnmounted(() => {
            var _a, _b;
            (_b = (_a = parentFormProvider()) === null || _a === void 0 ? void 0 : _a.onChildUnmounted) === null || _b === void 0 ? void 0 : _b.call(_a, publicMethods);
        });
        return publicMethods;
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3 /* FORWARDED */
  }))
}

script.render = render;
script.__file = "src/components/va-form/VaForm.vue";

const VaForm = withConfigTransport(script);

export { VaForm };
//# sourceMappingURL=index29.js.map
