import { _ as _Symbol, i as isArray_1, b as _MapCache, d as _assignValue, e as _isIndex, f as isObject_1, g as isArguments_1, h as isLength_1, j as _arrayPush, k as _overRest, l as _setToString } from './global-config.js';
import { i as isSymbol_1 } from './isSymbol.js';
import { ref, onMounted, onBeforeUnmount, watch, computed, unref } from 'vue';
import { i as isServer } from './ssr-utils.js';

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$1(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap$1;

var Symbol$1 = _Symbol,
    arrayMap = _arrayMap,
    isArray$4 = isArray_1,
    isSymbol$2 = isSymbol_1;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$4(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString$1) + '';
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _baseToString = baseToString$1;

var baseToString = _baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : baseToString(value);
}

var toString_1 = toString$1;

/** Returns cb result only on client. Returns null on server  */
const useClientOnly = (cb) => {
    if (isServer()) {
        const result = ref(null);
        onMounted(() => { result.value = cb(); });
        return result;
    }
    return ref(cb());
};

const useRequestAnimationFrame = (cb) => {
    let animationFrameRequest = -1;
    const observe = () => {
        animationFrameRequest = requestAnimationFrame(observe);
        cb();
    };
    onMounted(() => { observe(); });
    onBeforeUnmount(() => { cancelAnimationFrame(animationFrameRequest); });
};

const keys = ['x', 'y', 'width', 'height', 'top', 'left', 'right', 'bottom'];
const isDomRectEqual = (a, b) => {
    for (let i = 0; i < keys.length; i++) {
        if (a[keys[i]] !== b[keys[i]]) {
            return false;
        }
    }
    return true;
};
const useDomRect = (target) => {
    const domRect = ref(null);
    let prev = {};
    useRequestAnimationFrame(() => {
        if (!target.value) {
            return;
        }
        const rect = target.value.getBoundingClientRect();
        if (!isDomRectEqual(rect, prev)) {
            domRect.value = rect;
        }
        prev = rect;
    });
    watch(target, (newVal) => {
        if (newVal) {
            domRect.value = newVal.getBoundingClientRect();
        }
        else {
            domRect.value = null;
        }
    });
    return {
        domRect,
    };
};

var isArray$3 = isArray_1,
    isSymbol$1 = isSymbol_1;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$1(value, object) {
  if (isArray$3(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey$1;

var MapCache = _MapCache;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize$1.Cache = MapCache;

var memoize_1 = memoize$1;

var memoize = memoize_1;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped$1;

var memoizeCapped = _memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath$1;

var isArray$2 = isArray_1,
    isKey = _isKey,
    stringToPath = _stringToPath,
    toString = toString_1;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$4(value, object) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

var _castPath = castPath$4;

var isSymbol = isSymbol_1;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$3(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

var _toKey = toKey$3;

var castPath$3 = _castPath,
    toKey$2 = _toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet$1(object, path) {
  path = castPath$3(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey$2(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet$1;

var assignValue = _assignValue,
    castPath$2 = _castPath,
    isIndex$1 = _isIndex,
    isObject = isObject_1,
    toKey$1 = _toKey;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet$1(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath$2(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey$1(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex$1(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

var _baseSet = baseSet$1;

var baseGet = _baseGet,
    baseSet = _baseSet,
    castPath$1 = _castPath;

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy$1(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath$1(path, object), value);
    }
  }
  return result;
}

var _basePickBy = basePickBy$1;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn$1;

var castPath = _castPath,
    isArguments$1 = isArguments_1,
    isArray$1 = isArray_1,
    isIndex = _isIndex,
    isLength = isLength_1,
    toKey = _toKey;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath$1(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

var _hasPath = hasPath$1;

var baseHasIn = _baseHasIn,
    hasPath = _hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

var hasIn_1 = hasIn$1;

var basePickBy = _basePickBy,
    hasIn = hasIn_1;

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

var _basePick = basePick$1;

var Symbol = _Symbol,
    isArguments = isArguments_1,
    isArray = isArray_1;

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable$1(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable$1;

var arrayPush = _arrayPush,
    isFlattenable = _isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten$1;

var baseFlatten = _baseFlatten;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

var flatten_1 = flatten$1;

var flatten = flatten_1,
    overRest = _overRest,
    setToString = _setToString;

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest$1(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

var _flatRest = flatRest$1;

var basePick = _basePick,
    flatRest = _flatRest;

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

var pick_1 = pick;

const mapObject = (o, cb) => {
    const copy = {};
    Object.keys(o)
        .forEach((key) => {
        copy[key] = cb(o[key], key);
    });
    return copy;
};

const placementsPositions = ['top', 'bottom', 'left', 'right']
    .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto']);
const coordsToCss = ({ x, y }) => ({ left: `${x}px`, top: `${y}px` });
const parsePlacement = (placement) => {
    const [position, align] = placement.split('-');
    return { position, align: align || 'center' };
};
const parseOffset = (offset) => {
    return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
const calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
    if (align === 'start') {
        return anchorStart;
    }
    if (align === 'end') {
        return anchorStart + anchorSize - contentSize;
    }
    return anchorStart + (anchorSize - contentSize) / 2;
};
const calculateContentCoords = (placement, anchor, content) => {
    const { position, align } = parsePlacement(placement);
    const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
    const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
    switch (position) {
        case 'top': return { x: alignmentX, y: anchor.top - content.height };
        case 'left': return { y: alignmentY, x: anchor.left - content.width };
        case 'right': return { y: alignmentY, x: anchor.right };
        case 'bottom':
        default: return { x: alignmentX, y: anchor.bottom };
    }
};
const calculateOffsetCoords = (placement, offset) => {
    const { position } = parsePlacement(placement);
    const { main, cross } = parseOffset(offset);
    switch (position) {
        case 'left': return { y: cross, x: -main };
        case 'right': return { y: cross, x: main };
        case 'top': return { y: -main, x: cross };
        case 'bottom':
        default: return { y: main, x: cross };
    }
};
/** Returns how much content overflow */
const calculateContentOverflow = (coords, content, root) => {
    const xMax = root.right;
    const yMax = root.bottom;
    const xMin = root.left;
    const yMin = root.top;
    return {
        top: Math.max(yMin - coords.y, 0),
        bottom: Math.max((coords.y + content.height) - yMax, 0),
        left: Math.max(xMin - coords.x, 0),
        right: Math.max((coords.x + content.width) - xMax, 0),
    };
};
const clamp = (min, v, max) => Math.max(Math.min(v, max), min);
const calculateClipToEdge = (coords, offsetCoords, content, anchor, root) => {
    const { top, bottom, left, right } = calculateContentOverflow(coords, content, root);
    // Add left overflow, sub right overflow so content always stick to edge
    const x = coords.x - right + left;
    const y = coords.y - bottom + top;
    const { x: offsetX, y: offsetY } = offsetCoords;
    return {
        // Clamp content position near anchor, so any content edge should touch anchor edge
        x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),
        y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),
    };
};
const getAutoPlacement = (placement, coords, content, root) => {
    const { position, align } = parsePlacement(placement);
    const overflow = calculateContentOverflow(coords, content, root);
    const newPlacements = {
        top: ['bottom', align].join('-'),
        bottom: ['top', align].join('-'),
        right: ['left', align].join('-'),
        left: ['right', align].join('-'),
    };
    return overflow[position] ? newPlacements[position] : placement;
};
/**
 * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`
 * @param options make options reactive if you want popover to react on options change.
 */
const usePopover = (anchorRef, contentRef, options) => {
    const documentRef = useClientOnly(() => document);
    const rootRef = computed(() => {
        if (!documentRef.value) {
            return undefined;
        }
        const { root } = unref(options);
        if (root) {
            return documentRef.value.querySelector(root);
        }
        return documentRef.value.body;
    });
    const { domRect: anchorDomRect } = useDomRect(anchorRef);
    const { domRect: contentDomRect } = useDomRect(contentRef);
    const css = {
        width: 'max-content',
        position: 'absolute',
    };
    const updateContentCSS = () => {
        if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
            return;
        }
        let offsetCoords = { x: 0, y: 0 };
        const { placement, keepAnchorWidth, offset, autoPlacement, stickToEdges } = unref(options);
        // calculate coords (x and y) of content left-top corner
        let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
            offsetCoords = calculateOffsetCoords(placement, offset);
            coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
        }
        if (keepAnchorWidth) {
            const { width } = anchorDomRect.value;
            Object.assign(css, { width: `${width}px`, maxWidth: `${width}px` });
        }
        const rootRect = rootRef.value.getBoundingClientRect();
        if (autoPlacement) {
            const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, rootRect);
            if (newPlacement !== placement) {
                coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
                if (offset) {
                    offsetCoords = calculateOffsetCoords(newPlacement, offset);
                    coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
                }
            }
        }
        if (stickToEdges) {
            coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, rootRect);
        }
        if (contentRef.value) {
            Object.assign(contentRef.value.style, {
                ...css,
                ...coordsToCss(coords),
            });
        }
    };
    watch(anchorDomRect, updateContentCSS);
    watch(contentDomRect, updateContentCSS);
    watch(options, updateContentCSS, { deep: true });
    return {
        anchorDomRect,
        contentDomRect,
    };
};

export { _baseGet as _, _toKey as a, _castPath as b, _arrayMap as c, _flatRest as d, pick_1 as e, flatten_1 as f, placementsPositions as p, toString_1 as t, usePopover as u };
//# sourceMappingURL=usePopover.js.map
