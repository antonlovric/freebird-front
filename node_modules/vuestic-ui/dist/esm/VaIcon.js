import { defineComponent, computed, openBlock, createBlock, resolveDynamicComponent, mergeProps, withCtx, renderSlot, createElementBlock, Fragment, createTextVNode, toDisplayString, createCommentVNode } from 'vue';
import { _ as _baseGet, a as _toKey, b as _castPath, c as _arrayMap, d as _flatRest } from './usePopover.js';
import { n as isPlainObject_1, o as _copyObject, p as _getAllKeysIn, q as _baseClone, r as merge_1, u as useGlobalConfig } from './global-config.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { u as useSizeProps, a as useSize } from './useSize.js';

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */

function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

var last_1 = last$1;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */

function baseSlice$1(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice$1;

var baseGet = _baseGet,
    baseSlice = _baseSlice;

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

var _parent = parent$1;

var castPath$1 = _castPath,
    last = last_1,
    parent = _parent,
    toKey = _toKey;

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

var _baseUnset = baseUnset$1;

var isPlainObject = isPlainObject_1;

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone$1(value) {
  return isPlainObject(value) ? undefined : value;
}

var _customOmitClone = customOmitClone$1;

var arrayMap = _arrayMap,
    baseClone = _baseClone,
    baseUnset = _baseUnset,
    castPath = _castPath,
    copyObject = _copyObject,
    customOmitClone = _customOmitClone,
    flatRest = _flatRest,
    getAllKeysIn = _getAllKeysIn;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

var omit_1 = omit;

const isMatchRegex = (str, regex) => {
    return regex.test(str);
};
/**
 * Return values from regex groups
 * @example
 * ```
 * "fa-phone-o", /fa-(.*)-(.*)/ -> ["phone", "o"]
 * "any string", /(.*)/ -> ["any string"]
 * "global regex test", /global (regex) (test)/g -> [['regex', 'test']]
 * ```
 */
const regexGroupsValues = (str, regex) => {
    if (typeof regex !== 'string' && regex.global) {
        // Global regex can return multiple matches array. So we need to map this all matches and remove non group values.
        return [...str.matchAll(regex)].map(g => g.slice(1));
    }
    const match = str.match(regex) || [];
    if (!match) {
        return [];
    }
    /**
     * If there is groups in result - we need to slice first match
     * ```
     * "test".match(/(s)/)
     * > Array [ "s", "s" ]
     * ```
     */
    if (match.length > 1) {
        return match.slice(1);
    }
    return match;
};

const dynamicSegmentRegex = /{[^}]*}/g; // match {any-thing}, {even with space}
/**
 * Replace {anything} to regex (.*) group
 * @example
 * ```
 * "fa-{code}" -> "fa-(.*)"
 * "fa-{code}-{suffix}" -> "fa-(.*)-(.*)"
 * ```
 */
const dynamicSegmentStringToRegex = (template) => {
    return template.replace(dynamicSegmentRegex, '(.*)');
};
/**
 Returns content from string in {}
 @example
 ```
 "fa-{code}-{suffix}" -> ['code', 'suffix']
 ```
 */
const dynamicSegmentsNames = (template) => {
    return (template.match(dynamicSegmentRegex) || []) // 'fa-{code}-{suffix}' -> ['{code}', '{suffix}']
        .map((g) => g.replace(/{|}/g, '')); // ['{code}', '{suffix}'] -> ['code', 'suffix']
};
/**
 * Transform template to regex and returns regex group values
 * @example
 * ```
 * "fa-clock-o", "fa-{code}-{suffix}" -> ["clock", "o"]
 * ```
 */
const dynamicSegmentsValues = (str, template) => {
    return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
/**
 * Returns object with param name from template and match value from str
 * @example
 * ```
 * "fa-phone", "fa-{icon code}" -> { 'icon code': 'phone' }
 * "fa4 clock-o", "fa4 {icon-code}-{suffix}" -> { 'icon-code': 'clock', 'suffix': 'o' }
 * "fa4 clock-o", "fa4 {icon-code}" -> { 'icon-code': 'clock-o' }
 * ```
 */
const dynamicSegments = (str, template) => {
    const params = dynamicSegmentsNames(template);
    const values = dynamicSegmentsValues(str, template);
    return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {});
};
/**
 * Returns true if match string equals to input `str`
 * @example
 * ```
 * "vuestic-home-open", /vuestic-(.*)-o/ -> false
 * "vuestic-home-open", /vuestic-(.*)-open/ -> true
 * ```
 */
const strictMatch = (str, regex) => {
    return (str.match(regex) || [])[0] === str;
};
/**
 * Returns true if str match template
 * @example
 *  ```
 * "fa-phone", "fa-{icon code}" -> true
 * "fa4 clock-o", "fa4 {icon-code}-{suffix}" -> true
 * "fa4 clock-o", "fa4 {icon-code}" -> false
 * ```
 */
const isMatchDynamicSegments = (str, template) => {
    const templateRegex = dynamicSegmentStringToRegex(template);
    return strictMatch(str, new RegExp(templateRegex));
};

const isIconConfigurationString = (config) => {
    return typeof config.name === 'string';
};
const isIconConfigurationRegex = (config) => {
    return config.name instanceof RegExp;
};

const isMatchConfiguration = (iconName, iconConfiguration) => {
    if (isIconConfigurationString(iconConfiguration)) {
        return isMatchDynamicSegments(iconName, iconConfiguration.name);
    }
    if (isIconConfigurationRegex(iconConfiguration)) {
        return isMatchRegex(iconName, iconConfiguration.name);
    }
    return false;
};
const resolveIconConfigurationString = (iconName, iconConfiguration) => {
    const args = dynamicSegments(iconName, iconConfiguration.name);
    return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
const resolveIconConfigurationRegex = (iconName, iconConfig) => {
    if (iconConfig.name.global) {
        throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
    }
    const args = regexGroupsValues(iconName, iconConfig.name);
    return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
const resolveIconConfiguration = (iconName, iconConfiguration) => {
    if (isIconConfigurationString(iconConfiguration)) {
        return resolveIconConfigurationString(iconName, iconConfiguration);
    }
    if (isIconConfigurationRegex(iconConfiguration)) {
        return resolveIconConfigurationRegex(iconName, iconConfiguration);
    }
    throw Error('Unknown icon config');
};
const findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
    const matchedConfig = globalIconConfig.find((config) => {
        if (namesToIgnore.includes(config.name.toString())) {
            return false;
        }
        return isMatchConfiguration(iconName, config);
    });
    if (!matchedConfig) {
        throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
    }
    return matchedConfig;
};
const findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
    if (!iconName) {
        return;
    }
    const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
    const resolvedIconConfiguration = merge_1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
    namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
    return merge_1(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);
};
/** Removes name, to, resolveFromRegex and resolve from IconConfiguration */
const iconPropsFromIconConfiguration = (iconConfiguration) => {
    const junkKeys = ['name', 'to', 'resolve', 'resolveFromRegex'];
    const configuration = iconConfiguration;
    junkKeys.forEach((key) => { delete configuration[key]; });
    return configuration;
};
const getIconConfiguration = (name, iconConfig) => {
    const configuration = findIconConfiguration(name, iconConfig);
    if (configuration === undefined) {
        return {};
    }
    return iconPropsFromIconConfiguration(configuration);
};

const useIcons = (props) => {
    const { getGlobalConfig } = useGlobalConfig();
    const getIconConfig = () => {
        return getGlobalConfig().icons || [];
    };
    return {
        // TODO: export here function that can dynamically change icons config
        getIcon: (name) => getIconConfiguration(name, getIconConfig()),
    };
};

var script = defineComponent({
    name: 'VaIcon',
    props: {
        ...useSizeProps,
        name: { type: String, default: '' },
        tag: { type: String },
        component: { type: Object },
        color: { type: String },
        rotation: { type: [String, Number] },
        spin: { type: [String, Boolean] },
        flip: {
            type: String,
            default: 'off',
            validator: (value) => ['off', 'horizontal', 'vertical', 'both'].includes(value),
        },
    },
    setup(props, { attrs }) {
        const { getColor } = useColors();
        const { sizeComputed } = useSize(props);
        const { getIcon } = useIcons();
        const iconConfig = computed(() => getIcon(props.name));
        const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || 'i');
        const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit_1(attrs, ['class']) }));
        const getSpinClass = (spin) => {
            if (spin === undefined || spin === false) {
                return;
            }
            return spin === 'counter-clockwise' ? 'va-icon--spin-reverse' : 'va-icon--spin';
        };
        const computedClass = computed(() => {
            var _a;
            return [
                iconConfig.value.class,
                getSpinClass((_a = props.spin) !== null && _a !== void 0 ? _a : iconConfig.value.spin),
            ];
        });
        const transformStyle = computed(() => {
            const rotation = props.rotation ? `rotate(${props.rotation}deg)` : '';
            const flipY = (props.flip === 'vertical' || props.flip === 'both') ? -1 : 1;
            const flipX = (props.flip === 'horizontal' || props.flip === 'both') ? -1 : 1;
            const scale = props.flip === 'off' ? '' : `scale(${flipY}, ${flipX})`;
            return `${scale} ${rotation}`.trim();
        });
        const computedStyle = computed(() => ({
            transform: transformStyle.value,
            cursor: attrs.onClick ? 'pointer' : null,
            color: props.color ? getColor(props.color, undefined, true) : iconConfig.value.color,
            fontSize: sizeComputed.value,
        }));
        return {
            iconConfig,
            computedTag,
            computedAttrs,
            computedClass,
            computedStyle,
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    "aria-hidden": "true",
    style: _ctx.computedStyle
  }, _ctx.computedAttrs, { notranslate: "" }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        (_ctx.iconConfig.content)
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.iconConfig.content), 1 /* TEXT */)
            ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
          : createCommentVNode("v-if", true)
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["class", "style"]))
}

script.render = render;
script.__file = "src/components/va-icon/VaIcon.vue";

export { _baseSlice as _, omit_1 as o, script as s, useIcons as u };
//# sourceMappingURL=VaIcon.js.map
