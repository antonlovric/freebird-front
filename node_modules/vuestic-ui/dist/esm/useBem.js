import { computed, unref } from 'vue';
import { w as isFunction_1 } from './global-config.js';
import { _ as _createCompounder } from './_createCompounder.js';
import { _ as __DEV__ } from './global-utils.js';

var createCompounder = _createCompounder;

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

var kebabCase_1 = kebabCase;

/**
 * @description creates BEM modifiers based on transferred prefix (base BEM class) & modifiers list.
 * camelCase modifiers names will be transformed to the kebab-case.
 * @param prefix string that classes start with (base BEM class).
 * @param modifiers list of options that will serve as state BEM modifiers.
 * @returns computed classes starting with "prefix" and ending with form state BEM modifier.
 * @example
 *  const result = useBem('va-component', computed(() => pick(props, ['success, noError'])))
 *  // if success & noError are `true`
 *  { ...result }: { 'va-component--success': true, va-component--no-error: true }
 *  result.asObject.value: { 'va-component--success': true, va-component--no-error: true }
 *  result.asArray.value: ['va-component--success', 'va-component--no-error']
 *  result.asString.value: 'va-component--success va-component--no-error'
 */
const useBem = (prefix, modifiers) => {
    if (__DEV__ && !prefix) {
        console.warn('You must pass the @param "prefix" to the useBem hook!');
    }
    const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));
    const computedBemClassesObject = computed(() => {
        return Object
            .entries(unref(modifiersList))
            .reduce((classesObj, [modifierName, value]) => {
            if (value) {
                classesObj[`${prefix}--${kebabCase_1(modifierName)}`] = true;
            }
            return classesObj;
        }, {});
    });
    const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
    const computedBemClassesString = computed(() => computedBemClassesArray.value.join(' '));
    return new Proxy({}, {
        ownKeys() {
            return Reflect.ownKeys(computedBemClassesObject.value);
        },
        getOwnPropertyDescriptor(_, key) {
            return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
        },
        get(_, key, receiver) {
            switch (key) {
                case 'asArray':
                    return computedBemClassesArray;
                case 'asString':
                    return computedBemClassesString;
                case 'asObject':
                    return computedBemClassesObject;
                default:
                    return Reflect.get(computedBemClassesObject.value, key, receiver);
            }
        },
    });
};

export { kebabCase_1 as k, useBem as u };
//# sourceMappingURL=useBem.js.map
