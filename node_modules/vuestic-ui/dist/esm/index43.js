import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, computed, openBlock, createElementBlock, mergeProps, createElementVNode, normalizeStyle, renderSlot, createCommentVNode } from 'vue';
import { c as clamp_1 } from './clamp.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { u as useSizeProps, a as useSize } from './useSize.js';
import './VaConfig.js';
import './toNumber.js';
import './isSymbol.js';
import './global-properties.js';
import './ssr-utils.js';
import 'colortranslator';

var script = defineComponent({
    name: 'VaProgressCircle',
    props: {
        ...useSizeProps,
        modelValue: { type: Number, default: 0 },
        indeterminate: { type: Boolean, default: false },
        thickness: { type: Number, default: 0.06 },
        color: { type: String, default: 'primary' },
    },
    setup(props) {
        const { getColor } = useColors();
        const { sizeComputed } = useSize(props);
        const cappedThickness = computed(() => clamp_1(props.thickness, 0, 1) / 2 * 100);
        const radius = computed(() => 20 - (20 * cappedThickness.value / 100));
        const dasharray = computed(() => 2 * Math.PI * radius.value);
        const dashoffset = computed(() => dasharray.value * (1 - clamp_1(props.modelValue, 0, 100) / 100));
        const colorComputed = computed(() => getColor(props.color, undefined, true));
        return {
            infoStyle: computed(() => ({ color: colorComputed.value })),
            rootStyle: computed(() => ({
                width: sizeComputed.value,
                height: sizeComputed.value,
            })),
            rootClass: computed(() => ({
                'va-progress-circle--indeterminate': props.indeterminate,
            })),
            ariaAttributesComputed: computed(() => ({
                role: 'progressbar',
                ariaLabel: 'progress state',
                ariaValuenow: !props.indeterminate ? props.modelValue : undefined,
            })),
            colorComputed,
            radius,
            dasharray,
            dashoffset,
            cappedThickness,
        };
    },
});

const _hoisted_1 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
const _hoisted_2 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_1, [
      createElementVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + '%',
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8 /* PROPS */, _hoisted_2)
    ])),
    (_ctx.$slots.default)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.infoStyle),
          class: "va-progress-circle__info"
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script.render = render;
script.__file = "src/components/va-progress-circle/VaProgressCircle.vue";

const VaProgressCircle = withConfigTransport(script);

export { VaProgressCircle };
//# sourceMappingURL=index43.js.map
