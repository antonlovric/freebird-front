import { computed, getCurrentInstance, shallowReadonly } from 'vue';
import { u as useLocalConfig } from './VaConfig.js';
import { u as useGlobalConfig } from './global-config.js';

const useComponentConfigProps = (component) => {
    const localConfig = useLocalConfig();
    const { globalConfig } = useGlobalConfig();
    return computed(() => {
        var _a;
        const globalConfigProps = {
            ...globalConfig.value.componentsAll,
            ...(_a = globalConfig.value.components) === null || _a === void 0 ? void 0 : _a[component.name],
        };
        const localConfigProps = localConfig.value
            .reduce((finalConfig, config) => config[component.name]
            ? { ...finalConfig, ...config[component.name] }
            : finalConfig, {});
        const props = { ...globalConfigProps, ...localConfigProps };
        return props;
    });
};

/**
 * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.
 * @returns new props object, where some props replaced with props from config.
 */
const createPropsWithCustomConfig = (instance, propsFromConfig) => {
    /**
     * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.
     * It is a default props that passed to setup function.
     */
    const instanceProps = instance.props;
    return new Proxy(instanceProps, {
        get: (target, key) => {
            /**
             * Props passed to VNode. Not compiled at all and not reactive.
             * VNode props contained only props passed from parent.
             */
            const incommingProps = instance.vnode.props || {};
            /**
             * Make sure to access both original and from config prop in get.
             * Since instanceProps and propsFromConfig both are reactive, we need to know that both of
             * this objects are dependency of effect where proxy is used.
             * If original prop will not be accessed vue will not track reactivity for original props object.
             */
            const originalProp = target[key];
            const propFromConfig = propsFromConfig.value[key];
            // Return prop from config only if user didn't pass props manually
            if (incommingProps[key] === undefined && propFromConfig !== undefined) {
                return propFromConfig;
            }
            return originalProp;
        },
    });
};
/**
 * Patch instance props with Proxy.
 * This will change props object during render and in Devtools.
 */
const patchInstanceProps = (instance, props) => {
    instance.props = props;
};
const createProxyComponent = (component) => {
    const customSetup = (originalProps, ctx) => {
        var _a;
        const instance = getCurrentInstance(); // Not null during setup call
        const propsFromConfig = useComponentConfigProps(component);
        const props = createPropsWithCustomConfig(instance, propsFromConfig);
        patchInstanceProps(instance, props);
        return (_a = component.setup) === null || _a === void 0 ? void 0 : _a.call(component, shallowReadonly(props), ctx);
    };
    return new Proxy(component, {
        get(target, key) {
            if (key === 'setup') {
                return customSetup;
            }
            return target[key];
        },
    });
};

const CLASS_COMPONENT_KEY = '__c';
const patchClassComponent = (component) => {
    component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
    return component;
};
/** Allows props to be passed from vuestic config if they were not provided */
const withConfigTransport = (component) => {
    if ('setup' in component) {
        return createProxyComponent(component);
    }
    else if (CLASS_COMPONENT_KEY in component) {
        // TODO: Remove this. We don't want to use class components
        return patchClassComponent(component);
    }
    else {
        // Options api. We need to transform it to Composition API and then create proxy.
        component.setup = () => ({ /* Fake setup function */});
        return createProxyComponent(component);
    }
};

export { withConfigTransport as w };
//# sourceMappingURL=withConfigTransport.js.map
