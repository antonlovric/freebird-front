import { w as withConfigTransport } from './withConfigTransport.js';
import { onMounted, onBeforeUnmount, defineComponent, shallowRef, ref, computed, watch, resolveComponent, openBlock, createBlock, resolveDynamicComponent, normalizeClass, withCtx, renderSlot, createElementVNode, createVNode, createCommentVNode } from 'vue';
import { d as debounce_1 } from './debounce.js';
import { s as sleep } from './utils.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { VaProgressCircle } from './index43.js';
import './VaConfig.js';
import './toNumber.js';
import './isSymbol.js';
import './global-properties.js';
import './ssr-utils.js';
import 'colortranslator';
import './clamp.js';
import './useSize.js';

const useScroll = (props, element, handler) => {
    const addScrollListener = () => {
        var _a;
        (_a = element.value) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', handler.value, { passive: true });
    };
    const removeScrollListener = () => {
        var _a;
        (_a = element.value) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', handler.value);
    };
    onMounted(() => {
        if (!element.value) {
            return;
        }
        element.value.style.overflowY = 'scroll';
        if (props.reverse) {
            element.value.scrollTop = element.value.scrollHeight;
        }
        addScrollListener();
    });
    onBeforeUnmount(removeScrollListener);
    return {
        addScrollListener,
        removeScrollListener,
    };
};

var script = defineComponent({
    name: 'VaInfiniteScroll',
    components: { VaProgressCircle },
    props: {
        load: { type: Function, required: true },
        offset: { type: Number, default: 500 },
        reverse: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        scrollTarget: { type: [String, Object], default: undefined },
        debounce: { type: Number, default: 100 },
        tag: { type: String, default: 'div' },
    },
    emits: ['onload', 'onerror'],
    setup(props, { emit }) {
        const element = shallowRef();
        const spinnerSlotContainer = shallowRef();
        const fetching = ref(false);
        const error = ref(false);
        const forcedScrolling = ref(false);
        const debouncedLoad = ref();
        const notScrolledContentBeforeLoad = ref(0);
        const prevScrollTop = ref(0);
        const scrollTargetElement = computed(() => {
            var _a;
            let target;
            if (typeof props.scrollTarget === 'string') {
                target = document.querySelector(props.scrollTarget);
            }
            else {
                target = props.scrollTarget || ((_a = element.value) === null || _a === void 0 ? void 0 : _a.parentElement);
            }
            return (target || document.body);
        });
        const { addScrollListener, removeScrollListener, } = useScroll(props, scrollTargetElement, debouncedLoad);
        const { getColor } = useColors();
        const spinnerColor = computed(() => {
            return error.value ? getColor('danger') : getColor('primary');
        });
        const spinnerHeight = computed(() => {
            var _a;
            return ((_a = spinnerSlotContainer.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
        });
        const computedOffset = computed(() => {
            return props.offset + spinnerHeight.value;
        });
        const stop = () => {
            if (props.disabled) {
                return;
            }
            fetching.value = false;
            removeScrollListener();
        };
        const resume = () => {
            if (props.disabled) {
                return;
            }
            addScrollListener();
        };
        const onLoad = () => {
            const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
            notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
            const scrollDelta = scrollTop - prevScrollTop.value;
            prevScrollTop.value = scrollTop;
            if (props.disabled || error.value || fetching.value) {
                return;
            }
            if (forcedScrolling.value) {
                forcedScrolling.value = false;
                return;
            }
            const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0);
            if (isReverseScrollDirection) {
                return;
            }
            const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
            if (offset > computedOffset.value) {
                return;
            }
            fetching.value = true;
            props.load()
                .then(finishLoading)
                .catch(onError);
        };
        const forceSetScrollTopToTarget = (value) => {
            forcedScrolling.value = true;
            scrollTargetElement.value.scrollTop = value;
        };
        const updateTargetElementScrollTop = () => {
            const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
            if (props.reverse) {
                const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
                const isSpinnerHidden = scrollTop >= spinnerHeight.value;
                if (isScrolledUp && isSpinnerHidden) {
                    return;
                }
                (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)
                    ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)
                    : forceSetScrollTopToTarget(spinnerHeight.value);
            }
            if (!props.reverse) {
                const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
                !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
            }
        };
        const finishLoading = () => {
            updateTargetElementScrollTop();
            fetching.value = false;
            emit('onload');
        };
        const stopErrorDisplay = () => {
            updateTargetElementScrollTop();
            forcedScrolling.value = false;
            error.value = false;
            fetching.value = false;
            emit('onerror');
        };
        const onError = () => {
            stop();
            error.value = true;
            sleep(1200)
                .then(stopErrorDisplay)
                .then(resume);
        };
        watch(() => props.debounce, (value) => {
            debouncedLoad.value = debounce_1(onLoad, value);
        }, { immediate: true });
        watch(() => props.disabled, (value) => {
            value ? stop() : resume();
        });
        return {
            element,
            spinnerSlotContainer,
            spinnerColor,
            fetching,
        };
    },
});

const _hoisted_1 = { class: "va-infinite-scroll__spinner__default" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");

  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { 'va-infinite-scroll--reversed': _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createElementVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { 'va-infinite-scroll__spinner--invisible': !_ctx.fetching }])
      }, [
        (!_ctx.$props.disabled)
          ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
              createElementVNode("div", _hoisted_1, [
                createVNode(_component_va_progress_circle, {
                  size: "small",
                  thickness: 0.15,
                  color: _ctx.spinnerColor,
                  indeterminate: ""
                }, null, 8 /* PROPS */, ["thickness", "color"])
              ])
            ])
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */)
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["class", "aria-busy"]))
}

script.render = render;
script.__file = "src/components/va-infinite-scroll/VaInfiniteScroll.vue";

const VaInfiniteScroll = withConfigTransport(script);

export { VaInfiniteScroll };
//# sourceMappingURL=index33.js.map
