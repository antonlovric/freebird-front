import { ref, computed, unref, watch, defineComponent, openBlock, createElementBlock, normalizeClass, withKeys, withModifiers, renderSlot, toRefs, resolveComponent, mergeProps, Fragment, renderList, createTextVNode, toDisplayString, createCommentVNode, createVNode, withCtx, createElementVNode, normalizeProps, guardReactiveProps, shallowRef, onMounted, createBlock, nextTick, normalizeStyle, createSlots } from 'vue';
import { e as extractComponentProps, f as filterComponentProps, a as extractComponentEmits } from './child-props.js';
import { t as _baseGetTag, v as isObjectLike_1, x as _nodeUtil, y as _baseUnary } from './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from './useStateful.js';
import { VaButton } from './index12.js';

var baseGetTag = _baseGetTag,
    isObjectLike = isObjectLike_1;

/** `Object#toString` result references. */
var dateTag = '[object Date]';

/**
 * The base implementation of `_.isDate` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 */
function baseIsDate$1(value) {
  return isObjectLike(value) && baseGetTag(value) == dateTag;
}

var _baseIsDate = baseIsDate$1;

var baseIsDate = _baseIsDate,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;

/* Node.js helper references. */
var nodeIsDate = nodeUtil && nodeUtil.isDate;

/**
 * Checks if `value` is classified as a `Date` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 * @example
 *
 * _.isDate(new Date);
 * // => true
 *
 * _.isDate('Mon April 23 2012');
 * // => false
 */
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

var isDate_1 = isDate;

const isDatesDayEqual = (date1, date2) => (date1 === null || date1 === void 0 ? void 0 : date1.toDateString()) === (date2 === null || date2 === void 0 ? void 0 : date2.toDateString());
const isDatesYearEqual = (date1, date2) => {
    return (date1 === null || date1 === void 0 ? void 0 : date1.getFullYear()) === (date2 === null || date2 === void 0 ? void 0 : date2.getFullYear());
};
const isDatesMonthEqual = (date1, date2) => {
    return isDatesYearEqual(date1, date2) && (date1 === null || date1 === void 0 ? void 0 : date1.getMonth()) === (date2 === null || date2 === void 0 ? void 0 : date2.getMonth());
};
const createYearDate = (year) => {
    const date = new Date();
    date.setFullYear(year);
    return date;
};
const isRange = (value) => {
    return typeof value === 'object' && ('start' in value || 'end' in value);
};
const isSingleDate = (value) => isDate_1(value);
const isDates = (value) => Array.isArray(value);

const JANUARY_MONTH_INDEX = 0;
const DECEMBER_MONTH_INDEX = 11;
const addMonth = (view) => {
    if (view.month === DECEMBER_MONTH_INDEX) {
        return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
    }
    else {
        return { ...view, month: view.month + 1 };
    }
};
const subMonth = (view) => {
    if (view.month === JANUARY_MONTH_INDEX) {
        return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
    }
    else {
        return { ...view, month: view.month - 1 };
    }
};
const getDefaultDate = (modelValue) => {
    if (isDate_1(modelValue)) {
        return modelValue;
    }
    if (isDate_1(modelValue === null || modelValue === void 0 ? void 0 : modelValue.start)) {
        return modelValue.start;
    }
    if (Array.isArray(modelValue) && isDate_1(modelValue[0])) {
        return modelValue[0];
    }
    return new Date();
};
const useView = (props, emit, defaultOverride) => {
    const defaultDate = getDefaultDate(props.modelValue);
    const defaultView = {
        type: 'day',
        year: defaultDate.getFullYear(),
        month: defaultDate.getMonth(),
        ...defaultOverride,
    };
    const statefulView = ref(defaultView);
    const syncView = computed({
        get() {
            // Merge default view and user view prop
            return { ...statefulView.value, ...props.view };
        },
        set(view) {
            statefulView.value = view;
            emit('update:view', view);
        },
    });
    const next = () => {
        if (syncView.value.type === 'day') {
            syncView.value = addMonth(syncView.value);
        }
        else if (syncView.value.type === 'month') {
            syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
        }
    };
    const prev = () => {
        if (syncView.value.type === 'day') {
            syncView.value = subMonth(syncView.value);
        }
        else if (syncView.value.type === 'month') {
            syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
        }
    };
    return {
        syncView,
        next,
        prev,
    };
};

function isUndefined(t) {
    return t === undefined;
}
const useGridKeyboardNavigation = ({ rowSize, start, end, onSelected, onFocusIndex, }) => {
    const focusedCellIndex = ref(-1);
    let previouslyClicked = false;
    const onMousedown = () => { previouslyClicked = true; };
    const onFocus = () => {
        if (previouslyClicked) {
            return;
        }
        previouslyClicked = false;
        const index = onFocusIndex === undefined ? unref(start) || 0 : unref(onFocusIndex);
        focusedCellIndex.value = index;
    };
    const onBlur = () => {
        previouslyClicked = false;
        focusedCellIndex.value = -1;
    };
    const onKeydown = (e) => {
        if (['ArrowRight', 'ArrowLeft', 'ArrowDown', 'ArrowUp', 'Enter', 'Space'].includes(e.key)) {
            // Prevent default for arrow keys and enter. Do not prevent default for tab! :)
            e.preventDefault();
        }
        if (e.key === 'Enter' || e.key === 'Space') {
            if (onSelected === undefined) {
                return;
            }
            onSelected(focusedCellIndex.value);
            return;
        }
        if (e.key === 'ArrowRight') {
            focusedCellIndex.value += 1;
        }
        if (e.key === 'ArrowLeft') {
            focusedCellIndex.value -= 1;
        }
        if (e.key === 'ArrowDown') {
            focusedCellIndex.value += rowSize;
        }
        if (e.key === 'ArrowUp') {
            focusedCellIndex.value -= rowSize;
        }
        if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
            focusedCellIndex.value = unref(start);
        }
        if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
            focusedCellIndex.value = unref(end) - 1;
        }
    };
    const containerAttributes = {
        onFocus, onKeydown, onBlur, onMousedown, tabindex: 0,
    };
    return {
        focusedCellIndex, containerAttributes,
    };
};

const modeInitialValue = (date, mode) => {
    if (mode === 'single') {
        return date;
    }
    else if (mode === 'range') {
        return { start: date, end: null };
    }
    else if (mode === 'multiple') {
        return [date];
    }
    else if (mode === 'auto') {
        return date;
    }
    throw new Error('Unknown mode');
};
const throwIncorrectModelValueError = (modelValue, mode) => {
    throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
const modeFromModelValue = (modelValue) => {
    if (isSingleDate(modelValue)) {
        return 'single';
    }
    else if (isRange(modelValue)) {
        return 'range';
    }
    else if (isDates(modelValue)) {
        return 'multiple';
    }
    return throwIncorrectModelValueError(modelValue, 'auto');
};
const sortRange = (modelValue) => {
    if (modelValue.start && modelValue.end) {
        if (modelValue.start > modelValue.end) {
            return { start: modelValue.end, end: modelValue.start };
        }
    }
    return modelValue;
};
const useDatePickerModelValue = (props, emit, dateEqual) => {
    const updateModelValue = (date) => {
        if (!props.modelValue) {
            emit('update:modelValue', modeInitialValue(date, props.mode));
            return;
        }
        const mode = props.mode === 'auto' ? modeFromModelValue(props.modelValue) : props.mode;
        if (mode === 'single') {
            if (!isSingleDate(props.modelValue)) {
                return throwIncorrectModelValueError(props.modelValue, mode);
            }
            emit('update:modelValue', date);
        }
        else if (mode === 'range') {
            if (!isRange(props.modelValue)) {
                return throwIncorrectModelValueError(props.modelValue, mode);
            }
            if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
                return emit('update:modelValue', { start: props.modelValue.start, end: null });
            }
            if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
                return emit('update:modelValue', { start: null, end: props.modelValue.end });
            }
            if (props.modelValue.end === null) {
                return emit('update:modelValue', sortRange({ start: props.modelValue.start, end: date }));
            }
            if (props.modelValue.start === null) {
                return emit('update:modelValue', sortRange({ end: props.modelValue.end, start: date }));
            }
            emit('update:modelValue', { start: date, end: null });
        }
        else if (mode === 'multiple') {
            if (!isDates(props.modelValue)) {
                return throwIncorrectModelValueError(props.modelValue, mode);
            }
            const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date));
            if (isDatesIncludesDate) {
                emit('update:modelValue', props.modelValue.filter((d) => !dateEqual(d, date)));
            }
            else {
                emit('update:modelValue', [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));
            }
        }
    };
    return {
        updateModelValue,
    };
};

const getDateEqualFunction = (type) => {
    return {
        month: isDatesMonthEqual,
        day: isDatesDayEqual,
        year: isDatesYearEqual,
    }[type];
};
const useDatePicker = (type, dates, props, emit) => {
    const datesEqual = getDateEqualFunction(type);
    const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
    const isDateDisabled = (date) => isAllowedDate === undefined ? false : !isAllowedDate(date);
    const hoveredIndex = ref(-1);
    const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
    const { updateModelValue } = useDatePickerModelValue(props, emit, datesEqual);
    const onClick = (date) => {
        if (props.readonly || isDateDisabled(date)) {
            return;
        }
        updateModelValue(date);
        emit(`click:${type}`, date);
    };
    const isToday = (date) => {
        const today = new Date();
        return datesEqual(today, date);
    };
    const isSelected = (date) => {
        if (!props.modelValue) {
            return false;
        }
        if (isSingleDate(props.modelValue)) {
            return datesEqual(props.modelValue, date);
        }
        else if (isDates(props.modelValue)) {
            return !!props.modelValue.find((d) => datesEqual(d, date));
        }
        else if (isRange(props.modelValue)) {
            return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
        }
        return false;
    };
    const isInRange = (date) => {
        if (!props.modelValue) {
            return false;
        }
        if (!isRange(props.modelValue)) {
            return false;
        }
        if (props.modelValue.start && props.modelValue.end) {
            return props.modelValue.start < date && props.modelValue.end > date;
        }
        const selectedDate = props.modelValue.start || props.modelValue.end;
        if (selectedDate) {
            if (!hoveredValue.value) {
                return false;
            }
            return selectedDate < date
                ? (hoveredValue.value >= date)
                : (hoveredValue.value <= date);
        }
        return false;
    };
    watch(hoveredValue, (date) => { emit(`hover:${type}`, date); });
    return {
        hoveredIndex,
        hoveredValue,
        onClick,
        isToday,
        isSelected,
        isInRange,
    };
};

/** Returns last day of previous month */
const getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
const getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
/** Returns array from 1 to length */
const getNumbersArray = (length) => Array.from(Array(length).keys()).map((k) => k + 1);
const useVaDatePickerCalendar = (view, options) => {
    const CALENDAR_ROWS_COUNT = 6; // Need 6 rows if first day of a month is Saturday and the last day is Monday 31th.
    const localizeWeekday = (weekdayNumber) => {
        var _a;
        if (options && ((_a = options.firstWeekday) === null || _a === void 0 ? void 0 : _a.value) === 'Monday') {
            // Set Sunday as 7th day of the week and Monday as first day of the week.
            return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
        }
        return weekdayNumber;
    };
    const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
    const getPreviousDates = () => {
        if (currentMonthStartWeekday.value === 0) {
            return [];
        }
        const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
        const prevMonthDays = getNumbersArray(prevMonthDaysCount);
        return prevMonthDays
            .slice(-currentMonthStartWeekday.value)
            .map((d) => new Date(view.value.year, view.value.month - 1, d));
    };
    const getCurrentDates = () => {
        const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
        return currentMonthDays.map((d) => new Date(view.value.year, view.value.month, d));
    };
    const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
    const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
    const calendarDates = computed(() => {
        const days = prevAndCurrentDays.value;
        const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
        const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
        const nextMonthDays = getNumbersArray(nextMonthDaysCount);
        return [
            ...days,
            ...nextMonthDays
                .slice(0, daysRemaining)
                .map((d) => new Date(view.value.year, view.value.month + 1, d)),
        ];
    });
    return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

var script$5 = defineComponent({
    name: 'VaDatePickerCell',
    props: {
        otherMonth: { type: Boolean, default: false },
        today: { type: Boolean, default: false },
        inRange: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        selected: { type: Boolean, default: false },
        weekend: { type: Boolean, default: false },
        hidden: { type: Boolean, default: false },
        focused: { type: Boolean, default: false },
        highlightWeekend: { type: Boolean, default: false },
        highlightToday: { type: Boolean, default: false },
        readonly: { type: Boolean, default: false },
    },
    emits: ['click'],
    setup(props, { emit }) {
        const onClick = () => {
            if (!props.disabled) {
                emit('click');
            }
        };
        return {
            onClick,
        };
    },
});

const _hoisted_1$4 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (_ctx.hidden)
    ? (openBlock(), createElementBlock("div", _hoisted_1$4))
    : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["va-date-picker-cell", {
      'va-date-picker-cell_other-month': _ctx.otherMonth,
      'va-date-picker-cell_today': _ctx.highlightToday && _ctx.today,
      'va-date-picker-cell_in-range': _ctx.inRange,
      'va-date-picker-cell_disabled': _ctx.disabled,
      'va-date-picker-cell_highlighted-weekend': _ctx.highlightWeekend && _ctx.weekend,
      'va-date-picker-cell_selected': _ctx.selected,
      'va-date-picker-cell_focused': _ctx.focused,
      'va-date-picker-cell_readonly': _ctx.readonly,
    }]),
        onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.onClick && _ctx.onClick(...args))),
        onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => (_ctx.onClick && _ctx.onClick(...args)), ["prevent","stop"]), ["space","enter"]))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$5.render = render$5;
script$5.__file = "src/components/va-date-picker/components/VaDatePickerCell.vue";

const VaDatePickerCellProps = extractComponentProps(script$5, ['date', 'selectedValue', 'focusedDate', 'focused']);
var script$4 = defineComponent({
    name: 'VaDayPicker',
    components: { VaDatePickerCell: script$5 },
    props: {
        ...VaDatePickerCellProps,
        monthNames: { type: Array, required: true },
        weekdayNames: { type: Array, required: true },
        firstWeekday: { type: String, default: 'Sunday' },
        hideWeekDays: { type: Boolean, default: false },
        view: { type: Object, default: () => ({ type: 'day' }) },
        modelValue: { type: [Date, Array, Object] },
        mode: { type: String, default: 'auto' },
        showOtherMonths: { type: Boolean, default: false },
        allowedDays: { type: Function },
        weekends: { type: Function },
        highlightWeekend: { type: Boolean, default: false },
        highlightToday: { type: Boolean, default: false },
        readonly: { type: Boolean, default: false },
    },
    emits: ['update:modelValue', 'hover:day', 'click:day'],
    setup(props, { emit }) {
        const { firstWeekday, weekdayNames, view } = toRefs(props);
        const VaDayPickerCellPropValues = filterComponentProps(props, VaDatePickerCellProps);
        const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
        const weekdayNamesComputed = computed(() => {
            return firstWeekday.value === 'Sunday'
                ? weekdayNames.value
                : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
        });
        const { hoveredIndex, onClick, isToday, isSelected, isInRange, } = useDatePicker('day', calendarDates, props, emit);
        const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
        const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
        const { focusedCellIndex, containerAttributes, } = useGridKeyboardNavigation({
            rowSize: 7,
            start: gridStartIndex,
            end: gridEndIndex,
            onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue]),
        });
        watch(focusedCellIndex, (index) => { hoveredIndex.value = index; });
        watch(hoveredIndex, (index) => { focusedCellIndex.value = index; });
        const isOtherMonth = (date) => props.view.month !== date.getMonth();
        const isDateDisabled = (date) => props.allowedDays === undefined ? false : !props.allowedDays(date);
        const isDateWeekend = (date) => {
            if (props.weekends === undefined) {
                return date.getDay() === 6 || date.getDay() === 0; // 0 - Sunday, 6 - Saturday
            }
            return props.weekends(date);
        };
        return {
            hoveredIndex,
            calendarDates,
            onClick,
            isToday,
            isSelected,
            isInRange,
            isOtherMonth,
            isDateDisabled,
            isDateWeekend,
            containerAttributes,
            weekdayNamesComputed,
            VaDayPickerCellPropValues,
            focusedCellIndex,
        };
    },
});

const _hoisted_1$3 = ["onMouseenter"];
const _hoisted_2$1 = { class: "va-date-picker-cell__day" };

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");

  return (openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    (!_ctx.hideWeekDays)
      ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
          return (openBlock(), createElementBlock("div", {
            key: weekday,
            class: "va-day-picker__weekday"
          }, [
            renderSlot(_ctx.$slots, "weekday", {}, () => [
              createTextVNode(toDisplayString(weekday), 1 /* TEXT */)
            ])
          ]))
        }), 128 /* KEYED_FRAGMENT */))
      : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return (openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: $event => (_ctx.hoveredIndex = index),
        onMouseleave: _cache[0] || (_cache[0] = $event => (_ctx.hoveredIndex = -1))
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.readonly,
          onClick: $event => {_ctx.onClick(date); _ctx.focusedCellIndex = index;}
        }, {
          default: withCtx(() => [
            createElementVNode("span", _hoisted_2$1, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1 /* TEXT */)
              ])
            ])
          ]),
          _: 2 /* DYNAMIC */
        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "onClick"])
      ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$3))
    }), 128 /* KEYED_FRAGMENT */))
  ], 16 /* FULL_PROPS */))
}

script$4.render = render$4;
script$4.__file = "src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue";

var script$3 = defineComponent({
    name: 'VaDatePickerHeader',
    components: { VaButton },
    emits: ['update:view'],
    props: {
        monthNames: { type: Array, required: true },
        view: { type: Object },
        color: { type: String, default: undefined },
        disabled: { type: Boolean, default: false },
    },
    setup(props, { emit }) {
        const { syncView, prev, next } = useView(props, emit);
        const switchView = () => {
            if (syncView.value.type === 'day') {
                syncView.value = { ...syncView.value, type: 'month' };
            }
            else if (syncView.value.type === 'month') {
                syncView.value = { ...syncView.value, type: 'year' };
            }
        };
        const changeView = (view) => {
            syncView.value = view;
        };
        return { prev, next, changeView, switchView, syncView };
    },
});

const _hoisted_1$2 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
const _hoisted_2 = { class: "va-date-picker__header__text" };
const _hoisted_3 = { class: "ml-1" };

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");

  return (_ctx.syncView.type !== 'year')
    ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
        renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
          createVNode(_component_va_button, {
            disabled: _ctx.$props.disabled,
            icon: "chevron_left",
            flat: "",
            size: "small",
            color: _ctx.color,
            textColor: "dark",
            "aria-label": "next period",
            onClick: _ctx.prev
          }, null, 8 /* PROPS */, ["disabled", "color", "onClick"])
        ]),
        createElementVNode("div", _hoisted_2, [
          renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
            createVNode(_component_va_button, {
              disabled: _ctx.$props.disabled,
              flat: "",
              size: "small",
              rounded: false,
              color: _ctx.color,
              textColor: "dark",
              "aria-label": "switch view",
              onClick: _ctx.switchView
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
                  createTextVNode(toDisplayString(_ctx.syncView.year), 1 /* TEXT */)
                ]),
                (_ctx.syncView.type === 'day')
                  ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
                      createElementVNode("span", _hoisted_3, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1 /* TEXT */)
                    ])
                  : createCommentVNode("v-if", true)
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["disabled", "color", "onClick"])
          ])
        ]),
        renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
          createVNode(_component_va_button, {
            disabled: _ctx.$props.disabled,
            icon: "chevron_right",
            flat: "",
            size: "small",
            color: _ctx.color,
            textColor: "dark",
            "aria-label": "previous period",
            onClick: _ctx.next
          }, null, 8 /* PROPS */, ["disabled", "color", "onClick"])
        ])
      ]))
    : createCommentVNode("v-if", true)
}

script$3.render = render$3;
script$3.__file = "src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.vue";

var script$2 = defineComponent({
    name: 'VaMonthPicker',
    components: { VaDatePickerCell: script$5 },
    props: {
        modelValue: { type: [Date, Array, Object] },
        monthNames: { type: Array, required: true },
        view: { type: Object, default: () => ({ type: 'month' }) },
        allowedMonths: { type: Function, default: undefined },
        highlightToday: { type: Boolean, default: true },
        mode: { type: String, default: 'auto' },
        readonly: { type: Boolean, default: false },
    },
    emits: ['update:modelValue', 'hover:month', 'click:month'],
    setup(props, { emit }) {
        const { view } = toRefs(props);
        const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
        const { hoveredIndex, onClick, isToday, isSelected, isInRange, } = useDatePicker('month', months, props, emit);
        const isDisabled = (date) => props.allowedMonths === undefined ? false : !props.allowedMonths(date);
        const { focusedCellIndex, containerAttributes, } = useGridKeyboardNavigation({
            rowSize: 3,
            start: 0,
            end: months.value.length,
            onSelected: (selectedIndex) => onClick(months.value[selectedIndex]),
        });
        watch(focusedCellIndex, (index) => { hoveredIndex.value = index; });
        watch(hoveredIndex, (index) => { focusedCellIndex.value = index; });
        return {
            months,
            hoveredIndex,
            onClick,
            isToday,
            isSelected,
            isInRange,
            isDisabled,
            containerAttributes,
            focusedCellIndex,
        };
    },
});

const _hoisted_1$1 = ["onMouseenter"];

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");

  return (openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return (openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: $event => (_ctx.hoveredIndex = monthIndex),
        onMouseleave: _cache[0] || (_cache[0] = $event => (_ctx.hoveredIndex = -1))
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.readonly,
          onClick: $event => {_ctx.onClick(month); _ctx.focusedCellIndex = monthIndex;}
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1 /* TEXT */)
            ])
          ]),
          _: 2 /* DYNAMIC */
        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick"])
      ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$1))
    }), 128 /* KEYED_FRAGMENT */))
  ], 16 /* FULL_PROPS */))
}

script$2.render = render$2;
script$2.__file = "src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.vue";

var script$1 = defineComponent({
    name: 'VaYearPicker',
    components: { VaDatePickerCell: script$5 },
    props: {
        modelValue: { type: [Date, Array, Object] },
        allowedYears: { type: Function, default: undefined },
        highlightToday: { type: Boolean, default: true },
        startYear: { type: Number, default: 1970 },
        mode: { type: String, default: 'auto' },
        view: { type: Object, default: () => ({ type: 'year' }) },
        endYear: { type: Number, default: () => new Date().getFullYear() + 50 },
        readonly: { type: Boolean, default: false },
    },
    emits: ['update:modelValue', 'hover:year', 'click:year'],
    setup(props, { emit }) {
        const rootNode = shallowRef();
        const { view } = toRefs(props);
        const generateYearsArray = (start, end) => {
            const yearsCount = end - start + 1;
            return Array.from(Array(yearsCount).keys())
                .map((i) => createYearDate(start + i));
        };
        const years = computed(() => generateYearsArray(props.startYear, props.endYear));
        const scrollIntoYearIndex = (index) => {
            if (!rootNode.value) {
                return;
            }
            const scrollHeight = rootNode.value.scrollHeight;
            const rootNodeHeight = rootNode.value.offsetHeight;
            const currentYearOffset = scrollHeight / years.value.length * index;
            const cellSize = scrollHeight / years.value.length;
            const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
            if (relativeScrollPosition < 0) {
                // First element in view
                rootNode.value.scrollTo({ top: currentYearOffset });
            }
            else if (relativeScrollPosition > rootNodeHeight) {
                // Last element in view
                rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
            }
        };
        const scrollIntoYearIndexCenter = (index) => {
            if (!rootNode.value) {
                return;
            }
            const scrollHeight = rootNode.value.scrollHeight;
            const rootNodeHeight = rootNode.value.offsetHeight;
            const currentYearOffset = scrollHeight / years.value.length * index;
            rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
        };
        onMounted(() => {
            const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
            scrollIntoYearIndexCenter(currentYearIndex);
        });
        const { hoveredIndex, onClick, isToday, isSelected, isInRange, } = useDatePicker('year', years, props, emit);
        const isYearDisabled = (year) => props.allowedYears === undefined ? false : !props.allowedYears(year);
        const { focusedCellIndex, containerAttributes, } = useGridKeyboardNavigation({
            rowSize: 1,
            start: 0,
            end: years.value.length,
            onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
            onSelected: (selectedIndex) => onClick(years.value[selectedIndex]),
        });
        watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
        watch(focusedCellIndex, (index) => { hoveredIndex.value = index; });
        watch(hoveredIndex, (index) => { focusedCellIndex.value = index; });
        return {
            hoveredIndex,
            years,
            rootNode,
            onClick,
            isToday,
            isSelected,
            isInRange,
            isYearDisabled,
            focusedCellIndex,
            containerAttributes,
        };
    },
});

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");

  return (openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {}, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return (openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.readonly,
        onClick: $event => {_ctx.onClick(year); _ctx.focusedCellIndex = index;},
        onMouseenter: $event => (_ctx.hoveredIndex = index),
        onMouseleave: _cache[0] || (_cache[0] = $event => (_ctx.hoveredIndex = -1))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1 /* TEXT */)
        ]),
        _: 2 /* DYNAMIC */
      }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick", "onMouseenter"]))
    }), 128 /* KEYED_FRAGMENT */))
  ], 16 /* FULL_PROPS */))
}

script$1.render = render$1;
script$1.__file = "src/components/va-date-picker/components/VaYearPicker/VaYearPicker.vue";

const DEFAULT_MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const DEFAULT_WEEKDAY_NAMES = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
var script = defineComponent({
    name: 'VaDatePicker',
    components: { VaDayPicker: script$4, VaDatePickerHeader: script$3, VaMonthPicker: script$2, VaYearPicker: script$1 },
    props: {
        ...useStatefulProps,
        ...extractComponentProps(script$3),
        ...extractComponentProps(script$4),
        ...extractComponentProps(script$2),
        ...extractComponentProps(script$1),
        modelValue: { type: [Date, Array, Object] },
        monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
        weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
        view: { type: Object },
        type: { type: String, default: 'day' },
        readonly: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        // Colors
        color: { type: String, default: undefined },
        weekendsColor: { type: String, default: undefined },
    },
    emits: [
        ...useStatefulEmits,
        ...extractComponentEmits(script$3),
        ...extractComponentEmits(script$1),
        ...extractComponentEmits(script$4),
        ...extractComponentEmits(script$2),
    ],
    setup(props, { emit }) {
        const currentPicker = ref();
        const { valueComputed } = useStateful(props, emit);
        const { syncView } = useView(props, emit, { type: props.type });
        const classComputed = computed(() => ({
            'va-date-picker_without-week-days': props.hideWeekDays,
            'va-date-picker_disabled': props.disabled,
        }));
        const onDayModelValueUpdate = (modelValue) => {
            if (props.readonly) {
                return;
            }
            // Do not update model value if we just want to change view (We can change it for now, but later we can add here timepicker)
            if (props.type === 'day') {
                valueComputed.value = modelValue;
            }
        };
        const onMonthClick = (date) => {
            emit('click:month', date);
            const year = date.getFullYear();
            const month = date.getMonth();
            if (props.type !== 'month') {
                syncView.value = { type: 'day', year, month };
            }
        };
        const onMonthModelValueUpdate = (modelValue) => {
            // Do not update model value if we just want to change view
            if (props.type === 'month') {
                valueComputed.value = modelValue;
            }
        };
        const onYearClick = (date) => {
            emit('click:year', date);
            const year = date.getFullYear();
            if (props.type !== 'year') {
                syncView.value = { type: 'month', year, month: syncView.value.month };
            }
        };
        const onYearModelValueUpdate = (modelValue) => {
            // Do not update model value if we just want to change view
            if (props.type === 'year') {
                valueComputed.value = modelValue;
            }
        };
        const { colorsToCSSVariable } = useColors();
        const colorsStyle = colorsToCSSVariable({
            color: props.color,
            'weekends-color': props.weekendsColor,
        }, 'va-date-picker');
        const focusCurrentPicker = () => { var _a; return (_a = currentPicker.value) === null || _a === void 0 ? void 0 : _a.$el.focus(); };
        watch(syncView, (newValue, prevValue) => {
            // Don't focus new picker if user does not change type
            if (newValue.type === prevValue.type) {
                return;
            }
            nextTick(focusCurrentPicker);
        });
        const isPickerReadonly = (pickerName) => {
            return props.readonly && props.type === pickerName;
        };
        return {
            dayPickerProps: filterComponentProps(props, extractComponentProps(script$4)),
            headerProps: filterComponentProps(props, extractComponentProps(script$3)),
            monthPickerProps: filterComponentProps(props, extractComponentProps(script$2)),
            yearPickerProps: filterComponentProps(props, extractComponentProps(script$1)),
            syncView,
            classComputed,
            valueComputed,
            onDayModelValueUpdate,
            onMonthClick,
            onMonthModelValueUpdate,
            onYearClick,
            onYearModelValueUpdate,
            colorsStyle,
            currentPicker,
            focusCurrentPicker,
            isPickerReadonly,
        };
    },
});

const _hoisted_1 = { class: "va-date-picker__picker-wrapper" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.colorsStyle)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = $event => ((_ctx.syncView) = $event))
    }), createSlots({ _: 2 /* DYNAMIC */ }, [
      renderList(_ctx.$slots, (_, name) => {
        return {
          name: name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        }
      })
    ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["view"]),
    createElementVNode("div", _hoisted_1, [
      (_ctx.syncView.type === 'day')
        ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
            key: 0,
            ref: "currentPicker"
          }, _ctx.dayPickerProps, {
            "model-value": _ctx.valueComputed,
            view: _ctx.syncView,
            readonly: _ctx.$props.disabled || _ctx.isPickerReadonly('day'),
            "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
            "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit('hover:day', value)),
            "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit('click:day', value))
          }), createSlots({ _: 2 /* DYNAMIC */ }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name: name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              }
            })
          ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["model-value", "view", "readonly", "onUpdate:modelValue"]))
        : createCommentVNode("v-if", true),
      (_ctx.syncView.type === 'month')
        ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
            key: 1,
            ref: "currentPicker"
          }, _ctx.monthPickerProps, {
            view: _ctx.syncView,
            "model-value": _ctx.valueComputed,
            readonly: _ctx.$props.disabled || _ctx.isPickerReadonly('month'),
            "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
            "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit('hover:month', value)),
            "onClick:month": _ctx.onMonthClick
          }), createSlots({ _: 2 /* DYNAMIC */ }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name: name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              }
            })
          ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"]))
        : createCommentVNode("v-if", true),
      (_ctx.syncView.type === 'year')
        ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
            key: 2,
            ref: "currentPicker"
          }, _ctx.yearPickerProps, {
            view: _ctx.syncView,
            "model-value": _ctx.valueComputed,
            readonly: _ctx.$props.disabled || _ctx.isPickerReadonly('year'),
            "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit('hover:year', value)),
            "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
            "onClick:year": _ctx.onYearClick
          }), createSlots({ _: 2 /* DYNAMIC */ }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name: name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              }
            })
          ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"]))
        : createCommentVNode("v-if", true)
    ])
  ], 6 /* CLASS, STYLE */))
}

script.render = render;
script.__file = "src/components/va-date-picker/VaDatePicker.vue";

export { isDates as a, isSingleDate as b, isRange as c, isDate_1 as i, script as s };
//# sourceMappingURL=VaDatePicker.js.map
