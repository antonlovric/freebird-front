import { w as withConfigTransport } from './withConfigTransport.js';
import { computed, ref, watch, defineComponent, toRefs, nextTick, resolveComponent, openBlock, createElementBlock, createVNode, withCtx, renderSlot, normalizeProps, guardReactiveProps, mergeProps, toHandlers, withKeys, withModifiers, createSlots, createBlock, createCommentVNode, renderList } from 'vue';
import { e as extractComponentProps, a as extractComponentEmits, f as filterComponentProps } from './child-props.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useClearableEmits, a as useClearable } from './VaInput.js';
import 'colortranslator';
import { u as useStatefulEmits, b as useStateful } from './useStateful.js';
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from './index67.js';
import { i as isDate_1, s as script$1, a as isDates, b as isSingleDate, c as isRange$1 } from './VaDatePicker.js';
import { VaDropdown, VaDropdownContent } from './index27.js';
import { VaInput } from './index35.js';
import { VaIcon } from './index31.js';
import './VaConfig.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './VaIcon.js';
import './useColors.js';
import './useSize.js';
import './useFocus.js';
import './useEmitProxy.js';
import './useCaptureEvent.js';
import './useForm.js';
import './useBem.js';
import './_createCompounder.js';
import 'cleave.js';
import './VaInputWrapper.js';
import './useCSSVariables.js';
import './useSyncProp.js';
import './consts.js';
import './index12.js';
import './VaButton.js';
import './useLoading.js';
import './useRouterLink.js';
import './useTextColor.js';
import './index43.js';
import './clamp.js';
import './toNumber.js';
import './debounce.js';
import './VaMessageListWrapper.js';

const useParsable = (parsable, parse, format) => {
    const text = computed({
        get() {
            const value = parsable.value;
            if (typeof value === 'string') {
                return value;
            }
            return format(value);
        },
        set(v) {
            if (typeof parsable.value === 'string') {
                parsable.value = v;
            }
            else {
                parsable.value = parse(v);
            }
        },
    });
    const value = computed({
        get() {
            if (typeof parsable.value === 'string') {
                return parse(parsable.value);
            }
            return parsable.value;
        },
        set(v) {
            if (typeof parsable.value === 'string') {
                parsable.value = format(v);
            }
            else {
                parsable.value = v;
            }
        },
    });
    return {
        text,
        value,
    };
};

function useSyncProp(propRef, propName, emit, defaultValue) {
    if (defaultValue === undefined) {
        return {
            syncProp: computed({
                set(value) {
                    emit(`update:${propName}`, value);
                },
                get() {
                    return propRef.value;
                },
            }),
        };
    }
    const statefulValue = ref(defaultValue);
    return {
        syncProp: computed({
            set(value) {
                statefulValue.value = value;
                emit(`update:${propName}`, value);
            },
            get() {
                return ((propRef === null || propRef === void 0 ? void 0 : propRef.value) === undefined ? (statefulValue.value) : propRef.value);
            },
        }),
    };
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */

function isNil(value) {
  return value == null;
}

var isNil_1 = isNil;

const defaultParseDateFunction = (text) => new Date(Date.parse(text));
const isValidDate = (d) => isDate_1(d) && !isNaN(d.getTime());
const useDateParser = (props) => {
    const isMultipleDates = (text) => text.includes(props.delimiter);
    const isRange = (text) => text.includes(props.rangeDelimiter);
    const isValid = ref(true);
    const parseDate = (text) => {
        const date = (props.parseDate || defaultParseDateFunction)(text);
        isValid.value = isValidDate(date);
        return date;
    };
    const parseDateInputValue = (text) => {
        isValid.value = true;
        if (props.parse) {
            return props.parse(text, isValid);
        }
        if (isMultipleDates(text)) {
            return text.split(props.delimiter).map(parseDate);
        }
        if (isRange(text)) {
            const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
            return { start, end };
        }
        return parseDate(text);
    };
    return {
        parseDateInputValue,
        isValid,
    };
};

const isRange = (date) => {
    return typeof date === 'object' && ('start' in date || 'end' in date);
};
const parseSingleDate = (date) => typeof date === 'string'
    ? defaultParseDateFunction(date)
    : new Date(date);
const parseModelValue = (date) => {
    if (Array.isArray(date)) {
        return date.map(parseSingleDate);
    }
    if (isRange(date)) {
        return {
            start: isNil_1(date.start) ? date.start : parseSingleDate(date.start),
            end: isNil_1(date.end) ? date.end : parseSingleDate(date.end),
        };
    }
    return parseSingleDate(date);
};

/**
 * This guard is used to prevent updating modelValue if range end is not specified.
 * This guard provides reset method, that allow us to reset VaDateInput value if dropdown is closed.
 */
const useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
    const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
    const valueComputed = computed({
        get: () => bufferValue.value,
        set: (value) => {
            if (disabled.value) {
                modelValue.value = value;
            }
            if (!value) {
                modelValue.value = value;
                return;
            }
            if (isRange(value)) {
                if (value.end !== null) {
                    modelValue.value = value;
                }
            }
            else {
                modelValue.value = value;
            }
            bufferValue.value = value;
        },
    });
    watch(modelValue, (newValue) => {
        bufferValue.value = newValue;
    });
    const reset = () => {
        if (bufferValue.value && isRange(bufferValue.value)) {
            bufferValue.value = modelValue.value && parseValue(modelValue.value);
        }
    };
    return {
        valueComputed,
        reset,
    };
};

const VaInputProps = extractComponentProps(VaInput, [
    'mask', 'returnRaw', 'autosize', 'minRows', 'maxRows', 'type', 'inputmode', 'counter', 'maxLength',
]);
const VaDatePickerProps = extractComponentProps(script$1);
var script = defineComponent({
    name: 'VaDateInput',
    components: {
        VaDropdown,
        VaDropdownContent,
        VaDatePicker: script$1,
        VaInput,
        VaIcon,
    },
    props: {
        ...VaInputProps,
        ...VaDatePickerProps,
        ...useValidationProps,
        clearValue: { type: Date, default: undefined },
        modelValue: { type: [Date, Array, Object, String, Number] },
        resetOnClose: { type: Boolean, default: true },
        isOpen: { type: Boolean, default: undefined },
        format: { type: Function },
        formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
        parse: { type: Function },
        parseDate: { type: Function },
        parseValue: { type: Function },
        delimiter: { type: String, default: ', ' },
        rangeDelimiter: { type: String, default: ' ~ ' },
        manualInput: { type: Boolean, default: false },
        color: { type: String, default: 'primary' },
        leftIcon: { type: Boolean, default: false },
        icon: { type: String, default: 'calendar_today' },
    },
    emits: [
        ...extractComponentEmits(script$1),
        ...useClearableEmits,
        ...useValidationEmits,
        ...useStatefulEmits,
        'update:is-open',
        'update:text',
    ],
    setup(props, { emit, slots }) {
        const input = ref();
        const datePicker = ref();
        const { isOpen, resetOnClose } = toRefs(props);
        const { valueComputed: statefulValue } = useStateful(props, emit);
        const { syncProp: isOpenSync } = useSyncProp(isOpen, 'is-open', emit, false);
        const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
        const { valueComputed, reset: resetInvalidRange, } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
        watch(isOpenSync, (isOpened) => {
            if (!isOpened && !isRangeModelValueGuardDisabled.value) {
                resetInvalidRange();
            }
        });
        const dateOrNothing = (date) => date ? props.formatDate(date) : '...';
        const { parseDateInputValue, isValid } = useDateParser(props);
        watch(valueComputed, () => {
            isValid.value = true;
        });
        const modelValueToString = (value) => {
            if (props.format) {
                return props.format(valueComputed.value);
            }
            if (isDates(value)) {
                return value.map((d) => props.formatDate(d)).join(props.delimiter);
            }
            if (isSingleDate(value)) {
                return props.formatDate(value);
            }
            if (isRange$1(value)) {
                return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
            }
            throw new Error('VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }');
        };
        const { text, value: valueWithoutText, } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
        const valueText = computed(() => {
            if (!isValid.value) {
                return '';
            }
            if (!valueComputed.value) {
                if (!props.clearValue) {
                    return '';
                }
                return modelValueToString(props.clearValue);
            }
            return text.value;
        });
        const onInputTextChanged = ({ target }) => {
            const parsedValue = parseDateInputValue(target.value);
            if (isValid.value) {
                valueComputed.value = parsedValue;
            }
        };
        const reset = () => {
            statefulValue.value = props.clearValue;
            emit('clear');
        };
        const focus = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const hideAndFocus = () => {
            isOpenSync.value = false;
            focus();
        };
        const focusDatePicker = () => {
            nextTick(() => { var _a; return (_a = datePicker.value) === null || _a === void 0 ? void 0 : _a.focusCurrentPicker(); });
        };
        const focusInputOrPicker = () => {
            isOpenSync.value ? focusDatePicker() : focus();
        };
        const showDropdown = () => {
            isOpenSync.value = true;
            nextTick(focusInputOrPicker);
        };
        const toggleDropdown = () => {
            isOpenSync.value = !isOpenSync.value;
            nextTick(focusInputOrPicker);
        };
        const showAndFocus = (event) => {
            if (props.manualInput) {
                return;
            }
            isOpenSync.value = true;
            focusDatePicker();
            event.preventDefault();
        };
        const blur = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
        };
        const { computedError, computedErrorMessages, listeners } = useValidation(props, emit, reset, focus);
        const hasError = computed(() => (!isValid.value && valueComputed.value !== props.clearValue) || computedError.value);
        const filterSlots = computed(() => {
            const slotsWithIcons = [
                props.leftIcon && 'prependInner',
                (!props.leftIcon || props.clearable) && 'icon',
            ];
            return Object.keys(slots).filter(slot => !slotsWithIcons.includes(slot));
        });
        const { canBeCleared, clearIconProps, onFocus, onBlur, } = useClearable(props, valueComputed);
        const iconProps = computed(() => ({
            name: props.icon,
            color: props.color,
            size: 'small',
            class: 'va-date-input__icon',
        }));
        const computedInputProps = computed(() => ({
            ...filterComponentProps(props, VaInputProps).value,
            clearable: false,
            rules: [],
            error: hasError.value,
            errorMessages: computedErrorMessages.value,
            readonly: props.readonly || !props.manualInput,
        }));
        const computedInputListeners = computed(() => ({
            focus: () => {
                onFocus();
                listeners.onFocus();
            },
            blur: () => {
                onBlur();
                listeners.onBlur();
            },
        }));
        return {
            datePicker,
            valueText,
            valueWithoutText,
            valueComputed,
            isOpenSync,
            onInputTextChanged,
            input,
            inputProps: computedInputProps,
            inputListeners: computedInputListeners,
            datePickerProps: filterComponentProps(props, extractComponentProps(script$1)),
            filterSlots,
            canBeCleared,
            clearIconProps,
            iconProps,
            hideAndFocus,
            showAndFocus,
            toggleDropdown,
            showDropdown,
            focusInputOrPicker,
            reset,
            focus,
            blur,
        };
    },
});

const _hoisted_1 = { class: "va-date-input" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");

  return (openBlock(), createElementBlock("div", _hoisted_1, [
    createVNode(_component_va_dropdown, {
      modelValue: _ctx.isOpenSync,
      "onUpdate:modelValue": _cache[13] || (_cache[13] = $event => ((_ctx.isOpenSync) = $event)),
      trigger: "none",
      anchorSelector: ".va-input-wrapper__field",
      offset: [2, 0],
      "close-on-content-click": false,
      stateful: false,
      disabled: _ctx.disabled
    }, {
      anchor: withCtx(() => [
        renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputProps: _ctx.inputProps, inputListeners: _ctx.inputListeners })), () => [
          createVNode(_component_va_input, mergeProps({
            ref: "input",
            class: "va-date-input__input"
          }, _ctx.inputProps, toHandlers(_ctx.inputListeners), {
            "model-value": _ctx.valueText,
            "aria-label": "selected date",
            onChange: _ctx.onInputTextChanged,
            onClick: _cache[3] || (_cache[3] = $event => (_ctx.toggleDropdown())),
            onKeydown: [
              withKeys(withModifiers(_ctx.showAndFocus, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.showAndFocus, ["stop"]), ["space"])
            ]
          }), createSlots({
            prependInner: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              (_ctx.$props.leftIcon)
                ? (openBlock(), createBlock(_component_va_icon, normalizeProps(mergeProps({ key: 0 }, _ctx.iconProps)), null, 16 /* FULL_PROPS */))
                : createCommentVNode("v-if", true)
            ]),
            icon: withCtx(() => [
              (_ctx.canBeCleared)
                ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                    key: 0,
                    "aria-hiden": "false",
                    role: "button",
                    "aria-label": "reset",
                    tabindex: "0",
                    class: "va-date-input__clear-icon"
                  }, _ctx.clearIconProps, {
                    onClick: _cache[0] || (_cache[0] = $event => (_ctx.reset())),
                    onKeydown: [
                      _cache[1] || (_cache[1] = withKeys(withModifiers($event => (_ctx.reset()), ["stop"]), ["enter"])),
                      _cache[2] || (_cache[2] = withKeys(withModifiers($event => (_ctx.reset()), ["stop"]), ["space"]))
                    ]
                  }), null, 16 /* FULL_PROPS */))
                : (!_ctx.$props.leftIcon)
                  ? (openBlock(), createBlock(_component_va_icon, mergeProps({ key: 1 }, _ctx.iconProps, {
                      tabindex: "0",
                      onKeydown: [
                        withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                        withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
                      ]
                    }), null, 16 /* FULL_PROPS */, ["onKeydown"]))
                  : createCommentVNode("v-if", true)
            ]),
            _: 2 /* DYNAMIC */
          }, [
            renderList(_ctx.filterSlots, (name) => {
              return {
                name: name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              }
            })
          ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["model-value", "onChange", "onKeydown"])
        ])
      ]),
      default: withCtx(() => [
        createVNode(_component_va_dropdown_content, {
          onKeydown: _cache[12] || (_cache[12] = withKeys(withModifiers($event => (_ctx.hideAndFocus()), ["stop","prevent"]), ["esc"]))
        }, {
          default: withCtx(() => [
            createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
              modelValue: _ctx.valueWithoutText,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((_ctx.valueWithoutText) = $event)),
              "onClick:day": _cache[5] || (_cache[5] = $event => (_ctx.$emit('click:day', $event))),
              "onClick:month": _cache[6] || (_cache[6] = $event => (_ctx.$emit('click:month', $event))),
              "onClick:year": _cache[7] || (_cache[7] = $event => (_ctx.$emit('click:year', $event))),
              "onHover:day": _cache[8] || (_cache[8] = $event => (_ctx.$emit('hover:day', $event))),
              "onHover:month": _cache[9] || (_cache[9] = $event => (_ctx.$emit('hover:month', $event))),
              "onHover:year": _cache[10] || (_cache[10] = $event => (_ctx.$emit('hover:year', $event))),
              "onUpdate:view": _cache[11] || (_cache[11] = $event => (_ctx.$emit('update:view', $event)))
            }), createSlots({ _: 2 /* DYNAMIC */ }, [
              renderList(_ctx.$slots, (_, name) => {
                return {
                  name: name,
                  fn: withCtx((bind) => [
                    renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                  ])
                }
              })
            ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["modelValue"])
          ]),
          _: 3 /* FORWARDED */
        })
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["modelValue", "disabled"])
  ]))
}

script.render = render;
script.__file = "src/components/va-date-input/VaDateInput.vue";

const VaDateInput = withConfigTransport(script);

export { VaDateInput };
//# sourceMappingURL=index24.js.map
