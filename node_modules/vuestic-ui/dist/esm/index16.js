import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, computed, toRef, resolveComponent, openBlock, createBlock, resolveDynamicComponent, normalizeClass, normalizeStyle, withCtx, createElementVNode, mergeProps, toHandlers, createCommentVNode, renderSlot, withModifiers, withKeys } from 'vue';
import { b as useColorProps, u as useColors, g as getBoxShadowColor, c as getFocusColor, d as getHoverColor } from './useColors.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useHover } from './useHover.js';
import { u as useKeyboardOnlyFocus } from './useKeyboardOnlyFocus.js';
import { u as useRouterLinkProps, a as useRouterLink } from './useRouterLink.js';
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from './useStateful.js';
import { u as useTextColor } from './useTextColor.js';
import { VaIcon } from './index31.js';
import './VaConfig.js';
import 'colortranslator';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './VaIcon.js';
import './useSize.js';

var script = defineComponent({
    name: 'VaChip',
    components: { VaIcon },
    emits: [...useStatefulEmits, 'focus'],
    props: {
        ...useRouterLinkProps,
        ...useColorProps,
        ...useStatefulProps,
        modelValue: { type: Boolean, default: true },
        closeable: { type: Boolean, default: false },
        outline: { type: Boolean, default: false },
        disabled: { type: Boolean, default: false },
        square: { type: Boolean, default: false },
        shadow: { type: Boolean, default: false },
        flat: { type: Boolean, default: false },
        icon: { type: String, default: '' },
        tag: { type: String, default: 'span' },
        size: {
            type: String,
            default: 'medium',
            validator: (value) => ['small', 'medium', 'large'].includes(value),
        },
    },
    setup(props, { emit }) {
        const { getColor } = useColors();
        const colorComputed = computed(() => getColor(props.color));
        const borderColor = computed(() => props.outline ? colorComputed.value : '');
        const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
        const { textColorComputed } = useTextColor(toRef(props, 'color'), isTransparentBackground);
        const size = {
            small: '0.875rem',
            medium: '1rem',
            large: '1.25rem',
        };
        const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
        const shadowStyle = computed(() => {
            if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
                return;
            }
            return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
        });
        const { valueComputed } = useStateful(props, emit);
        const { tagComputed, hrefComputed } = useRouterLink(props);
        const { isHovered, onMouseEnter, onMouseLeave } = useHover();
        return {
            keyboardFocusListeners,
            valueComputed,
            hrefComputed,
            tagComputed,
            onMouseEnter,
            onMouseLeave,
            isHovered,
            close: () => {
                if (!props.disabled) {
                    valueComputed.value = false;
                }
            },
            iconSize: computed(() => size[props.size]),
            tabIndexComputed: computed(() => props.disabled ? -1 : 0),
            computedClass: computed(() => ({
                'va-chip--small': props.size === 'small',
                'va-chip--large': props.size === 'large',
                'va-chip--square': props.square,
                'va-chip--disabled': props.disabled,
            })),
            computedStyle: computed(() => {
                const result = {
                    color: textColorComputed.value,
                    borderColor: borderColor.value,
                    background: '',
                    boxShadow: shadowStyle.value,
                };
                if (props.outline || props.flat) {
                    if (hasKeyboardFocus.value) {
                        result.background = getFocusColor(colorComputed.value);
                    }
                    else if (isHovered.value) {
                        result.background = getHoverColor(colorComputed.value);
                    }
                }
                else {
                    result.background = colorComputed.value;
                }
                return result;
            }),
        };
    },
});

const _hoisted_1 = { class: "va-chip__content" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");

  return (_ctx.valueComputed)
    ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
        key: 0,
        class: normalizeClass(["va-chip", _ctx.computedClass]),
        href: _ctx.hrefComputed,
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        style: normalizeStyle(_ctx.computedStyle)
      }, {
        default: withCtx(() => [
          createElementVNode("span", mergeProps({ class: "va-chip__inner" }, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = $event => (_ctx.$emit('focus'))),
            onMouseenter: _cache[1] || (_cache[1] = (...args) => (_ctx.onMouseEnter && _ctx.onMouseEnter(...args))),
            onMouseleave: _cache[2] || (_cache[2] = (...args) => (_ctx.onMouseLeave && _ctx.onMouseLeave(...args)))
          }), [
            (_ctx.icon)
              ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  class: "va-chip__icon",
                  name: _ctx.icon,
                  size: _ctx.iconSize
                }, null, 8 /* PROPS */, ["name", "size"]))
              : createCommentVNode("v-if", true),
            createElementVNode("span", _hoisted_1, [
              renderSlot(_ctx.$slots, "default")
            ]),
            (_ctx.closeable)
              ? (openBlock(), createBlock(_component_va_icon, {
                  key: 1,
                  class: "va-chip__close-icon",
                  name: "close",
                  role: "button",
                  "aria-label": "close",
                  "aria-hidden": "false",
                  tabindex: _ctx.tabIndexComputed,
                  size: _ctx.iconSize,
                  onClick: withModifiers(_ctx.close, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
                    withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
                  ]
                }, null, 8 /* PROPS */, ["tabindex", "size", "onClick", "onKeydown"]))
              : createCommentVNode("v-if", true)
          ], 16 /* FULL_PROPS */)
        ]),
        _: 3 /* FORWARDED */
      }, 8 /* PROPS */, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]))
    : createCommentVNode("v-if", true)
}

script.render = render;
script.__file = "src/components/va-chip/VaChip.vue";

const VaChip = withConfigTransport(script);

export { VaChip };
//# sourceMappingURL=index16.js.map
