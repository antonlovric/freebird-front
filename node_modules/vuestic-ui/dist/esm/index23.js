import { w as withConfigTransport } from './withConfigTransport.js';
import { computed, watch, ref, defineComponent, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createElementVNode, createElementBlock, renderSlot, normalizeProps, guardReactiveProps, createCommentVNode, normalizeClass, Fragment, renderList, normalizeStyle, withModifiers, withKeys, toDisplayString, createVNode, TransitionGroup, createTextVNode } from 'vue';
import { _ as _baseSlice, o as omit_1 } from './VaIcon.js';
import { t as toString_1, e as pick_1 } from './usePopover.js';
import { _ as _createCompounder } from './_createCompounder.js';
import { r as merge_1 } from './global-config.js';
import { a as getValueByPath } from './utils.js';
import { s as safeCSSLength } from './css-utils.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { VaInnerLoading } from './index34.js';
import { VaCheckbox } from './index15.js';
import { VaIcon } from './index31.js';
import './VaConfig.js';
import './useSize.js';
import './isSymbol.js';
import './ssr-utils.js';
import './global-properties.js';
import 'colortranslator';
import './useLoading.js';
import './useKeyboardOnlyFocus.js';
import './useSelectable.js';
import './useStateful.js';
import './index67.js';
import './useSyncProp.js';
import './useFocus.js';
import './consts.js';
import './useTextColor.js';
import './VaMessageListWrapper.js';

var baseSlice = _baseSlice;

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

var _castSlice = castSlice$1;

/** Used to compose unicode character classes. */

var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$1 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}

var _hasUnicode = hasUnicode$2;

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function asciiToArray$1(string) {
  return string.split('');
}

var _asciiToArray = asciiToArray$1;

/** Used to compose unicode character classes. */

var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}

var _unicodeToArray = unicodeToArray$1;

var asciiToArray = _asciiToArray,
    hasUnicode$1 = _hasUnicode,
    unicodeToArray = _unicodeToArray;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray$1(string) {
  return hasUnicode$1(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

var _stringToArray = stringToArray$1;

var castSlice = _castSlice,
    hasUnicode = _hasUnicode,
    stringToArray = _stringToArray,
    toString = toString_1;

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

var _createCaseFirst = createCaseFirst$1;

var createCaseFirst = _createCaseFirst;

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst$1 = createCaseFirst('toUpperCase');

var upperFirst_1 = upperFirst$1;

var createCompounder = _createCompounder,
    upperFirst = upperFirst_1;

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst(word);
});

var startCase_1 = startCase;

const buildTableColumn = (source, initialIndex) => {
    const input = typeof source === 'string' ? { key: source } : source;
    return {
        source,
        initialIndex,
        key: input.key,
        name: input.name || input.key,
        label: input.label || startCase_1(input.key),
        thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),
        sortable: input.sortable || false,
        sortingFn: input.sortingFn,
        thAlign: input.thAlign || input.alignHead || 'left',
        thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || 'middle',
        tdAlign: input.tdAlign || input.align || 'left',
        tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || 'middle',
        width: input.width,
        tdClass: input.tdClass || input.classes,
        thClass: input.thClass || input.headerClasses,
        tdStyle: input.tdStyle || input.style,
        thStyle: input.thStyle || input.headerStyle,
    };
};
const buildColumnsFromItems = (items) => {
    return Object.keys(merge_1({}, ...items)).map(buildTableColumn);
};
const buildNormalizedColumns = (columns) => {
    return columns.map(buildTableColumn);
};
function useColumns(props) {
    const columnsComputed = computed(() => {
        if (props.columns.length === 0) {
            // if no column definitions provided then build them based on provided rawItems
            // e.g. if provided items look like `[{a: 1}, {b: 2}]` then there should be 2 columns: A and B
            return buildColumnsFromItems(props.items);
        }
        else {
            return buildNormalizedColumns(props.columns);
        }
    });
    return {
        columnsComputed,
    };
}

const getItemKey = (source, itemsTrackBy) => (typeof itemsTrackBy === 'function'
    ? itemsTrackBy(source)
    : getValueByPath(source, itemsTrackBy) || source);
const buildTableCell = (rowIndex, rowKey, rowData, column) => {
    var _a;
    const source = getValueByPath(rowData, column.key);
    return {
        rowIndex,
        rowKey,
        rowData,
        column,
        source,
        value: ((_a = source === null || source === void 0 ? void 0 : source.toString) === null || _a === void 0 ? void 0 : _a.call(source)) || '',
    };
};
const buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
    const itemKey = getItemKey(source, itemsTrackBy);
    return {
        initialIndex,
        itemKey,
        source,
        cells: columns.map(column => buildTableCell(initialIndex, itemKey, source, column)),
    };
};
function useRows(columns, props) {
    const rowsComputed = computed(() => props.items
        .map((rawItem, index) => buildTableRow(rawItem, index, props.itemsTrackBy, columns.value)));
    return {
        rowsComputed,
    };
}

function useFilterable(rawRows, props, emit) {
    const filteredRows = computed(() => {
        if (!rawRows.value.length) {
            return rawRows.value;
        }
        if (props.filter === '' && !props.filterMethod) {
            return rawRows.value;
        }
        return rawRows.value.filter(row => row.cells.some(cell => {
            return typeof props.filterMethod === 'function'
                ? props.filterMethod(cell.source)
                : cell.value.toLowerCase().includes(props.filter.toLowerCase());
        }));
    });
    watch(filteredRows, () => {
        emit('filtered', {
            items: filteredRows.value.map(row => row.source),
            itemsIndexes: filteredRows.value.map(row => row.initialIndex),
        });
    });
    return {
        filteredRows,
    };
}

function useSortable(columns, filteredRows, props, emit) {
    const sortByFallback = ref('');
    const sortBySync = computed({
        get() {
            if (props.sortBy === undefined) {
                return sortByFallback.value;
            }
            else {
                return props.sortBy;
            }
        },
        set(value) {
            if (props.sortBy === undefined) {
                sortByFallback.value = value;
            }
            emit('update:sortBy', value);
        },
    });
    const sortingOrderFallback = ref(null);
    const sortingOrderSync = computed({
        get() {
            if (props.sortingOrder === undefined) {
                return sortingOrderFallback.value;
            }
            else {
                return props.sortingOrder;
            }
        },
        set(value) {
            if (props.sortingOrder === undefined) {
                sortingOrderFallback.value = value;
            }
            emit('update:sortingOrder', value);
        },
    });
    // sorts by string-value of a given row's cell (depending on by which column the table is sorted) if no sortingFn is
    // provided. Otherwise uses that very sortingFn. If sortingOrder is `null` then restores the initial sorting order of
    // the rows.
    const sortedRows = computed(() => {
        if (filteredRows.value.length <= 1) {
            return filteredRows.value;
        }
        const column = columns.value.find(column => column.name === sortBySync.value);
        if (!column || !column.sortable) {
            return filteredRows.value;
        }
        const columnIndex = columns.value.indexOf(column);
        return [...filteredRows.value].sort((a, b) => {
            const firstValue = a.cells[columnIndex].value;
            const secondValue = b.cells[columnIndex].value;
            const firstSource = a.cells[columnIndex].source;
            const secondSource = b.cells[columnIndex].source;
            if (sortingOrderSync.value === null) {
                return a.initialIndex - b.initialIndex;
            }
            else {
                const sortingOrderRatio = sortingOrderSync.value === 'desc' ? -1 : 1;
                return sortingOrderRatio * (typeof column.sortingFn === 'function'
                    ? column.sortingFn(firstSource, secondSource)
                    : firstValue.localeCompare(secondValue));
            }
        });
    });
    // sort each time the sortBy or sortingOrder is changed (and also initially). Also if columns definitions are changed
    // (because that potentially means that the user runtime-introduced a custom sorting function for a specific column)
    watch(sortedRows, () => {
        emit('sorted', {
            sortBy: sortBySync.value,
            sortingOrder: sortingOrderSync.value,
            items: sortedRows.value.map(row => row.source),
            itemsIndexes: sortedRows.value.map(row => row.initialIndex),
        });
    });
    // a function to invoke when a heading of the table is clicked.
    // Sets the clicked heading's column as a one to sort by and toggles the sorting order from "asc" to "desc" to `null`
    // (un-sorted) if the same column is clicked again or sets sorting order to "asc" if some other column is chosen.
    function toggleSorting(column) {
        if (column.name === sortBySync.value) {
            if (sortingOrderSync.value === null) {
                sortingOrderSync.value = 'asc';
            }
            else if (sortingOrderSync.value === 'asc') {
                sortingOrderSync.value = 'desc';
            }
            else {
                sortingOrderSync.value = null;
            }
        }
        else {
            sortBySync.value = column.name;
            sortingOrderSync.value = 'asc';
        }
    }
    return {
        sortBySync,
        sortingOrderSync,
        toggleSorting,
        sortedRows,
    };
}

function usePaginatedRows$1(sortedRows, props) {
    const paginatedRows = computed(() => {
        if (!props.perPage || props.perPage < 0) {
            return sortedRows.value;
        }
        if (!props.currentPage || props.currentPage < 0) {
            return sortedRows.value.slice(0, props.perPage);
        }
        const pageStartIndex = props.perPage * (props.currentPage - 1);
        return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
    });
    return {
        paginatedRows,
    };
}

function useSelectableRow(paginatedRows, props, emit) {
    const selectedItemsFallback = ref([]);
    const selectedItemsSync = computed({
        get() {
            if (props.modelValue === undefined) {
                return selectedItemsFallback.value;
            }
            else {
                return props.modelValue;
            }
        },
        set(modelValue) {
            if (props.modelValue === undefined) {
                selectedItemsFallback.value = modelValue;
            }
            emit('update:modelValue', modelValue);
        },
    });
    const prevSelectedRowIndex = ref(-1);
    // clear all the selected rows when the `select-mode`'s value changes from multiple to single
    // (though it's safe enough to leave a selected item when changing from single to multiple
    watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
        if (newSelectMode === 'single' && oldSelectMode === 'multiple') {
            selectedItemsSync.value = [];
            setPrevSelectedRowIndex(-1);
        }
    });
    // watch for rows changes (happens when filtering is applied e.g.)
    watch(paginatedRows, () => { setPrevSelectedRowIndex(-1); });
    // emit the "selection-change" event each time the selection changes
    watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
        emit('selectionChange', {
            currentSelectedItems,
            previousSelectedItems,
        });
    }, { immediate: true });
    // if user provide `props.itemsTrackBy !== ''` than `selectedItemsSync` and `props.modelValue`
    // would be the array with keys (received from `props.itemsTrackBy`)
    // else they would be the array with source (`DataTableItem` type)
    const getKey = (source) => getItemKey(source, props.itemsTrackBy);
    const noRowsSelected = computed(() => (!paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source)))));
    const allRowsSelected = computed(() => {
        if (paginatedRows.value.length === 0) {
            return false;
        }
        return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
    });
    const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
    function isRowSelected(row) {
        return selectedItemsSync.value.includes(getKey(row.source));
    }
    function selectAllRows() {
        selectedItemsSync.value = [...new Set([
                ...selectedItemsSync.value,
                ...paginatedRows.value.map(row => getKey(row.source)),
            ])];
    }
    function unselectAllRows() {
        const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source));
        selectedItemsSync.value = selectedItemsSync.value
            .filter((item) => !paginatedRowsKeys.includes(item));
    }
    // The one calling this function must guarantee that the row isn't already selected
    function selectRow(row) {
        selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
    }
    function selectOnlyRow(row) {
        selectedItemsSync.value = [getKey(row.source)];
    }
    // The one calling this function must guarantee that the row is selected
    function unselectRow(row) {
        const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source));
        selectedItemsSync.value = [
            ...selectedItemsSync.value.slice(0, index),
            ...selectedItemsSync.value.slice(index + 1),
        ];
    }
    function setPrevSelectedRowIndex(rowInitialIndex) {
        if (rowInitialIndex === -1) {
            prevSelectedRowIndex.value = -1;
        }
        else {
            const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex);
            prevSelectedRow
                ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow)
                : prevSelectedRowIndex.value = -1;
        }
    }
    function getRowsToSelect(targetIndex) {
        let start;
        let end;
        if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
            start = Math.min(prevSelectedRowIndex.value, targetIndex);
            end = Math.max(prevSelectedRowIndex.value, targetIndex);
        }
        else {
            start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
            end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
        }
        return paginatedRows.value.slice(start, end + 1);
    }
    function mergeSelection(rowsToSelect) {
        const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source));
        if (noRowsSelected.value) {
            selectedItemsSync.value = rowsToSelectedItems;
            return;
        }
        const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item));
        if (isInternalSelection) {
            selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item));
            return;
        }
        selectedItemsSync.value = [...new Set([
                ...selectedItemsSync.value,
                ...rowsToSelectedItems,
            ])];
    }
    function toggleRowSelection(row) {
        if (!props.selectable) {
            return;
        }
        if (isRowSelected(row)) {
            unselectRow(row);
            props.selectMode === 'single' ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
        }
        else {
            props.selectMode === 'single' ? selectOnlyRow(row) : selectRow(row);
            setPrevSelectedRowIndex(row.initialIndex);
        }
    }
    function ctrlSelectRow(row) {
        if (!props.selectable) {
            return;
        }
        toggleRowSelection(row);
    }
    function shiftSelectRows(row) {
        if (!props.selectable) {
            return;
        }
        if (props.selectMode === 'single' || prevSelectedRowIndex.value === -1) {
            return toggleRowSelection(row);
        }
        const targetIndex = paginatedRows.value.indexOf(row);
        mergeSelection(getRowsToSelect(targetIndex));
        setPrevSelectedRowIndex(-1);
    }
    function toggleBulkSelection() {
        if (allRowsSelected.value) {
            unselectAllRows();
        }
        else {
            selectAllRows();
        }
        setPrevSelectedRowIndex(-1);
    }
    return {
        ctrlSelectRow,
        shiftSelectRows,
        toggleRowSelection,
        toggleBulkSelection,
        isRowSelected,
        noRowsSelected,
        severalRowsSelected,
        allRowsSelected,
    };
}

const prefix = '--va-data-table';
const isFunction$1 = (val) => typeof val === 'function';
const getClass = (classes) => isFunction$1(classes) ? classes() : classes;
const getStyle = (styles) => isFunction$1(styles) ? styles() : styles;
function useStyleable(props) {
    const { getColor, getFocusColor, getHoverColor, shiftHSLAColor } = useColors();
    const color = computed(() => getColor(props.selectedColor));
    const rowCSSVariables = computed(() => ({
        [`${prefix}-hover-color`]: getHoverColor(color.value),
        [`${prefix}-selected-color`]: props.selectable ? getFocusColor(color.value) : undefined,
    }));
    const stickyCSSVariables = computed(() => ({
        [`${prefix}-scroll-table-color`]: (props.height || props.stickyHeader || props.stickyFooter) && shiftHSLAColor(color.value, { l: 40 }),
        [`${prefix}-scroll-table-height`]: props.height ? safeCSSLength(props.height) : undefined,
    }));
    const getHeaderCSSVariables = (column) => ({
        [`${prefix}-width`]: column.width && safeCSSLength(column.width),
        [`${prefix}-align`]: column.thAlign,
        [`${prefix}-vertical-align`]: column.thVerticalAlign,
        [`${prefix}-cursor`]: column.sortable ? 'pointer' : 'default',
    });
    const getCellCSSVariables = (cell) => ({
        [`${prefix}-align`]: cell.column.tdAlign,
        [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign,
    });
    const getFooterCSSVariables = (column) => ({
        [`${prefix}-align`]: column.thAlign,
        [`${prefix}-vertical-align`]: column.thVerticalAlign,
        [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? 'pointer' : 'default',
    });
    return {
        rowCSSVariables,
        stickyCSSVariables,
        getHeaderCSSVariables,
        getCellCSSVariables,
        getFooterCSSVariables,
        getClass,
        getStyle,
    };
}

const isFunction = (val) => typeof val === 'function';
const isObject = (val) => val !== null && typeof val === 'object';
function useBinding(props) {
    const getRowBind = (row) => (isFunction(props.rowBind)
        ? props.rowBind(row.source, row.initialIndex)
        : isObject(props.rowBind)
            ? props.rowBind
            : {});
    const getCellBind = (cell, row) => (isFunction(props.cellBind)
        ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex)
        : isObject(props.cellBind)
            ? props.cellBind
            : {});
    return {
        getRowBind,
        getCellBind,
    };
}

function usePaginatedRows(props, rows) {
    const animationName = ref('table-transition-shuffle');
    const oldRowsLength = ref(rows.value.length);
    const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
    watch(rows, (newRows) => {
        const animationType = isDifferentRowLength.value || newRows.length > 50 ? 'fade' : 'shuffle';
        animationName.value = props.animated ? `table-transition-${animationType}` : '';
        oldRowsLength.value = newRows.length;
    });
    watch(() => props.currentPage, () => {
        if (!isDifferentRowLength.value) {
            animationName.value = props.animated ? 'table-transition-shuffle' : '';
        }
    });
    return animationName;
}

/*
  TODO: consider a possibility to lazy-load the hooks with dynamic imports based on respective props' values. E.G.

  if (selectable.value) {
    const { default: useSelectableRow } = await import("./hooks/useSelectableRow");
  }

  // Would be a cool feature (if possible at all).
*/
var script = defineComponent({
    name: 'VaDataTable',
    components: {
        VaInnerLoading,
        VaCheckbox,
        VaIcon,
    },
    inheritAttrs: false,
    props: {
        columns: { type: Array, default: () => [] },
        items: { type: Array, default: () => [] },
        itemsTrackBy: { type: [String, Function], default: '' },
        modelValue: { type: Array },
        sortingOrder: { type: String },
        sortBy: { type: String },
        filter: { type: String, default: '' },
        filterMethod: { type: Function },
        hoverable: { type: Boolean, default: false },
        clickable: { type: Boolean, default: false },
        animated: { type: Boolean, default: true },
        selectable: { type: Boolean, default: false },
        selectMode: { type: String, default: 'multiple' },
        selectedColor: { type: String, default: 'primary' },
        perPage: { type: Number },
        currentPage: { type: Number },
        loading: { type: Boolean, default: false },
        loadingColor: { type: String, default: 'primary' },
        noDataHtml: { type: String, default: 'No items' },
        noDataFilteredHtml: { type: String, default: 'No items match the provided filtering condition' },
        hideDefaultHeader: { type: Boolean, default: false },
        footerClone: { type: Boolean, default: false },
        allowFooterSorting: { type: Boolean, default: false },
        striped: { type: Boolean, default: false },
        stickyHeader: { type: Boolean, default: false },
        stickyFooter: { type: Boolean, default: false },
        height: { type: [String, Number] },
        rowBind: { type: null },
        cellBind: { type: null },
    },
    emits: [
        'update:modelValue',
        'update:sortBy',
        'update:sortingOrder',
        'filtered',
        'sorted',
        'selectionChange',
        'row:click',
        'row:dblclick',
        'row:contextmenu',
    ],
    setup(props, { attrs, emit }) {
        const { columnsComputed } = useColumns(props);
        const { rowsComputed } = useRows(columnsComputed, props);
        const { filteredRows } = useFilterable(rowsComputed, props, emit);
        const { sortBySync, sortingOrderSync, toggleSorting, sortedRows, } = useSortable(columnsComputed, filteredRows, props, emit);
        const { paginatedRows } = usePaginatedRows$1(sortedRows, props);
        const { ctrlSelectRow, shiftSelectRows, toggleBulkSelection, isRowSelected, severalRowsSelected, allRowsSelected, } = useSelectableRow(paginatedRows, props, emit);
        const { rowCSSVariables, stickyCSSVariables, getHeaderCSSVariables, getCellCSSVariables, getFooterCSSVariables, getClass, getStyle, } = useStyleable(props);
        const { getRowBind, getCellBind } = useBinding(props);
        const animationName = usePaginatedRows(props, paginatedRows);
        const showNoDataHtml = computed(() => props.items.length === 0);
        const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
        const onRowClickHandler = (name, event, row) => {
            if (props.clickable) {
                emit(name, {
                    event,
                    item: row.source,
                    itemIndex: row.initialIndex,
                });
            }
        };
        const computedAttributes = computed(() => ({
            class: [
                { 'va-data-table--sticky': props.stickyHeader || props.stickyFooter },
                { 'va-data-table--scroll': !!props.height },
                attrs.class,
            ],
            style: [stickyCSSVariables.value, attrs.style],
        }));
        const computedTableAttributes = computed(() => ({
            ...omit_1(attrs, ['class', 'style']),
            class: pick_1(props, ['striped', 'selectable', 'hoverable', 'clickable']),
        }));
        const getColumnAriaSortOrder = (columnName) => sortingOrderSync.value && sortBySync.value === columnName
            ? sortingOrderSync.value === 'asc' ? 'ascending' : 'descending'
            : 'none';
        return {
            columnsComputed,
            rows: paginatedRows,
            ctrlSelectRow,
            shiftSelectRows,
            toggleBulkSelection,
            isRowSelected,
            severalRowsSelected,
            allRowsSelected,
            sortBySync,
            sortingOrderSync,
            toggleSorting,
            rowCSSVariables,
            getHeaderCSSVariables,
            getCellCSSVariables,
            getFooterCSSVariables,
            getClass,
            getStyle,
            showNoDataHtml,
            showNoDataFilteredHtml,
            onRowClickHandler,
            computedAttributes,
            computedTableAttributes,
            animationName,
            getColumnAriaSortOrder,
            getRowBind,
            getCellBind,
        };
    },
});

const _hoisted_1 = { key: 0 };
const _hoisted_2 = {
  key: 0,
  class: "va-data-table__table-tr"
};
const _hoisted_3 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
const _hoisted_4 = ["aria-sort", "aria-label", "title", "onClick", "onKeydown"];
const _hoisted_5 = ["tabindex"];
const _hoisted_6 = { key: 0 };
const _hoisted_7 = { key: "showNoDataHtml" };
const _hoisted_8 = ["colspan", "innerHTML"];
const _hoisted_9 = { key: "showNoDataFilteredHtml" };
const _hoisted_10 = ["colspan", "innerHTML"];
const _hoisted_11 = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_12 = {
  key: 0,
  class: "va-data-table__table-tr"
};
const _hoisted_13 = {
  key: 0,
  class: "va-data-table__table-th"
};
const _hoisted_14 = ["title", "aria-label", "onClick", "onKeydown"];
const _hoisted_15 = ["tabindex"];
const _hoisted_16 = { key: 0 };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");

  return (openBlock(), createBlock(_component_va_inner_loading, mergeProps({
    class: "va-data-table",
    "aria-live": "polite"
  }, _ctx.computedAttributes, {
    loading: _ctx.loading,
    color: _ctx.loadingColor
  }), {
    default: withCtx(() => [
      createElementVNode("table", mergeProps({ class: "va-data-table__table" }, _ctx.computedTableAttributes), [
        ('colgroup' in _ctx.$slots)
          ? (openBlock(), createElementBlock("colgroup", _hoisted_1, [
              renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
            ]))
          : createCommentVNode("v-if", true),
        createElementVNode("thead", {
          class: normalizeClass(["va-data-table__table-thead", { 'va-data-table__table-thead--sticky': _ctx.$props.stickyHeader }])
        }, [
          renderSlot(_ctx.$slots, "headerPrepend"),
          (!_ctx.hideDefaultHeader)
            ? (openBlock(), createElementBlock("tr", _hoisted_2, [
                (_ctx.selectable)
                  ? (openBlock(), createElementBlock("th", _hoisted_3, [
                      (_ctx.selectMode === 'multiple')
                        ? (openBlock(), createBlock(_component_va_checkbox, {
                            key: 0,
                            "aria-label": "select all rows",
                            "model-value": _ctx.severalRowsSelected ? 'idl' : _ctx.allRowsSelected,
                            "true-value": true,
                            "false-value": false,
                            color: _ctx.selectedColor,
                            "indeterminate-value": "idl",
                            indeterminate: "",
                            "onUpdate:modelValue": _ctx.toggleBulkSelection
                          }, null, 8 /* PROPS */, ["model-value", "color", "onUpdate:modelValue"]))
                        : createCommentVNode("v-if", true)
                    ]))
                  : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
                  return (openBlock(), createElementBlock("th", {
                    key: column.name,
                    scope: "col",
                    "aria-sort": _ctx.getColumnAriaSortOrder(column.name),
                    "aria-label": column.sortable ? `sort column by ${column.label}` : undefined,
                    title: column.thTitle,
                    class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                    style: normalizeStyle([_ctx.getHeaderCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                    onClick: withModifiers($event => (column.sortable && _ctx.toggleSorting(column)), ["exact"]),
                    onKeydown: withKeys(withModifiers($event => (column.sortable && _ctx.toggleSorting(column)), ["stop"]), ["enter"])
                  }, [
                    createElementVNode("div", {
                      class: "va-data-table__table-th-wrapper",
                      tabindex: column.sortable ? 0 : -1
                    }, [
                      (`header(${column.name})` in _ctx.$slots)
                        ? (openBlock(), createElementBlock("span", _hoisted_6, [
                            renderSlot(_ctx.$slots, `header(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                          ]))
                        : renderSlot(_ctx.$slots, "header", normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
                            createElementVNode("span", null, toDisplayString(column.label), 1 /* TEXT */)
                          ]),
                      (column.sortable)
                        ? (openBlock(), createElementBlock("div", {
                            key: 2,
                            class: "va-data-table__table-th-sorting",
                            "aria-hidden": "true",
                            onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"]))
                          }, [
                            createVNode(_component_va_icon, {
                              name: _ctx.sortingOrderSync === 'asc' ? 'expand_less' : 'expand_more',
                              size: "small",
                              class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                            }, null, 8 /* PROPS */, ["name", "class"])
                          ], 32 /* HYDRATE_EVENTS */))
                        : createCommentVNode("v-if", true)
                    ], 8 /* PROPS */, _hoisted_5)
                  ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_4))
                }), 128 /* KEYED_FRAGMENT */))
              ]))
            : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "headerAppend")
        ], 2 /* CLASS */),
        createElementVNode("tbody", {
          class: "va-data-table__table-tbody",
          style: normalizeStyle(_ctx.rowCSSVariables)
        }, [
          renderSlot(_ctx.$slots, "bodyPrepend"),
          createVNode(TransitionGroup, {
            name: _ctx.animationName,
            appear: ""
          }, {
            default: withCtx(() => [
              (_ctx.showNoDataHtml)
                ? (openBlock(), createElementBlock("tr", _hoisted_7, [
                    createElementVNode("td", {
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataHtml,
                      class: "no-data"
                    }, null, 8 /* PROPS */, _hoisted_8)
                  ]))
                : (_ctx.showNoDataFilteredHtml)
                  ? (openBlock(), createElementBlock("tr", _hoisted_9, [
                      createElementVNode("td", {
                        colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                        innerHTML: _ctx.noDataFilteredHtml,
                        class: "no-data"
                      }, null, 8 /* PROPS */, _hoisted_10)
                    ]))
                  : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row) => {
                return (openBlock(), createElementBlock("tr", mergeProps({
                  key: `table-row_${row.initialIndex}`,
                  class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row) }]]
                }, _ctx.getRowBind(row), {
                  onClick: $event => (_ctx.onRowClickHandler('row:click', $event, row)),
                  onDblclick: $event => (_ctx.onRowClickHandler('row:dblclick', $event, row)),
                  onContextmenu: $event => (_ctx.onRowClickHandler('row:contextmenu', $event, row))
                }), [
                  (_ctx.selectable)
                    ? (openBlock(), createElementBlock("td", {
                        class: "va-data-table__table-td va-data-table__table-cell-select",
                        key: `selectable_${row.initialIndex}`,
                        onSelectstart: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"]))
                      }, [
                        createVNode(_component_va_checkbox, {
                          "model-value": _ctx.isRowSelected(row),
                          color: _ctx.selectedColor,
                          "aria-label": `select row ${row.initialIndex}`,
                          onClick: [
                            withModifiers($event => (_ctx.shiftSelectRows(row)), ["shift","exact","stop"]),
                            withModifiers($event => (_ctx.ctrlSelectRow(row)), ["ctrl","exact","stop"]),
                            withModifiers($event => (_ctx.ctrlSelectRow(row)), ["exact","stop"])
                          ]
                        }, null, 8 /* PROPS */, ["model-value", "color", "aria-label", "onClick"])
                      ], 32 /* HYDRATE_EVENTS */))
                    : createCommentVNode("v-if", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell) => {
                    return (openBlock(), createElementBlock("td", mergeProps({
                      key: `table-cell_${cell.column.name + cell.rowIndex}`,
                      class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                      style: [_ctx.getCellCSSVariables(cell), _ctx.getStyle(cell.column.tdStyle)]
                    }, _ctx.getCellBind(cell, row)), [
                      (`cell(${cell.column.name})` in _ctx.$slots)
                        ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, cell)))
                        : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, cell)), () => [
                            createTextVNode(toDisplayString(cell.value), 1 /* TEXT */)
                          ])
                    ], 16 /* FULL_PROPS */))
                  }), 128 /* KEYED_FRAGMENT */))
                ], 16 /* FULL_PROPS */, _hoisted_11))
              }), 128 /* KEYED_FRAGMENT */))
            ]),
            _: 3 /* FORWARDED */
          }, 8 /* PROPS */, ["name"]),
          renderSlot(_ctx.$slots, "bodyAppend")
        ], 4 /* STYLE */),
        (_ctx.footerClone)
          ? (openBlock(), createElementBlock("tfoot", {
              key: 1,
              class: normalizeClass(["va-data-table__table-tfoot", { 'va-data-table__table-tfoot--sticky': _ctx.$props.stickyFooter }])
            }, [
              renderSlot(_ctx.$slots, "footerPrepend"),
              (!_ctx.hideDefaultHeader)
                ? (openBlock(), createElementBlock("tr", _hoisted_12, [
                    (_ctx.selectable)
                      ? (openBlock(), createElementBlock("th", _hoisted_13, [
                          (_ctx.selectMode === 'multiple')
                            ? (openBlock(), createBlock(_component_va_checkbox, {
                                key: 0,
                                "aria-label": "select all rows",
                                "model-value": _ctx.severalRowsSelected ? 'idl' : _ctx.allRowsSelected,
                                "true-value": true,
                                "false-value": false,
                                color: _ctx.selectedColor,
                                "indeterminate-value": "idl",
                                indeterminate: "",
                                "onUpdate:modelValue": _ctx.toggleBulkSelection
                              }, null, 8 /* PROPS */, ["model-value", "color", "onUpdate:modelValue"]))
                            : createCommentVNode("v-if", true)
                        ]))
                      : createCommentVNode("v-if", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
                      return (openBlock(), createElementBlock("th", {
                        key: column.name,
                        title: column.thTitle,
                        "aria-label": _ctx.allowFooterSorting && column.sortable ? `sort column by ${column.label}` : undefined,
                        class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                        style: normalizeStyle([_ctx.getFooterCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                        onClick: withModifiers($event => (_ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column)), ["exact"]),
                        onKeydown: withKeys(withModifiers($event => (_ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column)), ["stop"]), ["enter"])
                      }, [
                        createElementVNode("div", {
                          class: "va-data-table__table-th-wrapper",
                          tabindex: _ctx.allowFooterSorting && column.sortable ? 0 : -1
                        }, [
                          (`footer(${column.name})` in _ctx.$slots)
                            ? (openBlock(), createElementBlock("span", _hoisted_16, [
                                renderSlot(_ctx.$slots, `footer(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                              ]))
                            : renderSlot(_ctx.$slots, "footer", normalizeProps(mergeProps({ key: 1 }, column)), () => [
                                createElementVNode("span", null, toDisplayString(column.label), 1 /* TEXT */)
                              ]),
                          (_ctx.allowFooterSorting && column.sortable)
                            ? (openBlock(), createElementBlock("div", {
                                key: 2,
                                class: "va-data-table__table-th-sorting",
                                onSelectstart: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"]))
                              }, [
                                createVNode(_component_va_icon, {
                                  name: _ctx.sortingOrderSync === 'asc' ? 'expand_less' : 'expand_more',
                                  size: "small",
                                  class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                                }, null, 8 /* PROPS */, ["name", "class"])
                              ], 32 /* HYDRATE_EVENTS */))
                            : createCommentVNode("v-if", true)
                        ], 8 /* PROPS */, _hoisted_15)
                      ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_14))
                    }), 128 /* KEYED_FRAGMENT */))
                  ]))
                : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "footerAppend")
            ], 2 /* CLASS */))
          : createCommentVNode("v-if", true)
      ], 16 /* FULL_PROPS */)
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["loading", "color"]))
}

script.render = render;
script.__file = "src/components/va-data-table/VaDataTable.vue";

const VaDataTable = withConfigTransport(script);

export { VaDataTable };
//# sourceMappingURL=index23.js.map
