import { w as withConfigTransport } from './withConfigTransport.js';
import { getCurrentInstance, provide, toRef, inject, ref, defineComponent, computed, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, renderSlot, shallowRef, createBlock, resolveDynamicComponent, mergeProps, toHandlers, withCtx } from 'vue';
import { u as useColors, a as getGradientBackground } from './useColors.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useTextColor } from './useTextColor.js';
import { u as useHover } from './useHover.js';
import { u as useKeyboardOnlyFocus } from './useKeyboardOnlyFocus.js';
import { u as useRouterLinkProps, a as useRouterLink } from './useRouterLink.js';
import './VaConfig.js';
import 'colortranslator';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';

const key = Symbol('VaSidebar');
const useSidebar = () => {
    const { props } = getCurrentInstance();
    provide(key, {
        color: toRef(props, 'color'),
    });
};
const useSidebarItem = () => {
    const { color } = inject(key, { color: ref('white') });
    return {
        sidebarColor: color,
    };
};

var script$3 = defineComponent({
    name: 'VaSidebar',
    props: {
        color: { type: String, default: 'background' },
        textColor: { type: String },
        gradient: { type: Boolean, default: false },
        minimized: { type: Boolean, default: false },
        hoverable: { type: Boolean, default: false },
        position: {
            type: String,
            default: 'left',
            validator: (v) => ['left', 'right'].includes(v),
        },
        width: { type: String, default: '16rem' },
        minimizedWidth: { type: String, default: '4rem' },
        modelValue: { type: Boolean, default: true },
    },
    setup(props) {
        const { getColor } = useColors();
        useSidebar();
        const isHovered = ref(false);
        const isMinimized = computed(() => props.minimized || (props.hoverable && !isHovered.value));
        const computedWidth = computed(() => {
            if (!props.modelValue) {
                return 0;
            }
            return isMinimized.value ? props.minimizedWidth : props.width;
        });
        const { textColorComputed } = useTextColor();
        const computedStyle = computed(() => {
            const backgroundColor = getColor(props.color);
            const background = props.gradient ? getGradientBackground(backgroundColor) : backgroundColor;
            const color = textColorComputed.value;
            return {
                color,
                background,
                width: computedWidth.value,
            };
        });
        const computedClass = computed(() => ({
            'va-sidebar--minimized': isMinimized.value,
            'va-sidebar--right': props.position === 'right',
        }));
        const updateHoverState = (newHoverState) => {
            isHovered.value = props.hoverable && newHoverState;
        };
        return {
            computedClass,
            computedStyle,
            updateHoverState,
        };
    },
});

const _hoisted_1$2 = { class: "va-sidebar__menu" };

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("aside", {
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = $event => (_ctx.updateHoverState(true))),
    onMouseleave: _cache[1] || (_cache[1] = $event => (_ctx.updateHoverState(false)))
  }, [
    createElementVNode("div", _hoisted_1$2, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */))
}

script$3.render = render$3;
script$3.__file = "src/components/va-sidebar/VaSidebar.vue";

var script$2 = defineComponent({
    name: 'VaSidebarItem',
    props: {
        ...useRouterLinkProps,
        active: { type: Boolean, default: false },
        textColor: { type: String, default: undefined },
        activeColor: { type: String, default: 'primary' },
        hoverColor: { type: String, default: undefined },
        borderColor: { type: String, default: undefined },
    },
    setup(props) {
        const anchor = shallowRef();
        const { isHovered } = useHover(anchor);
        const { getColor, getHoverColor, getFocusColor } = useColors();
        const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
        const { sidebarColor } = useSidebarItem();
        const backgroundColorComputed = computed(() => {
            if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
                return getColor(props.activeColor);
            }
            return getColor(sidebarColor.value);
        });
        const { textColorComputed } = useTextColor(backgroundColorComputed);
        const computedStyle = computed(() => {
            const style = {
                color: props.textColor,
            };
            if (props.active) {
                style.backgroundColor = backgroundColorComputed.value;
                style.color = textColorComputed.value;
                style.borderColor = getColor(props.borderColor || props.activeColor);
            }
            if (hasKeyboardFocus.value) {
                style.backgroundColor = getFocusColor(getColor(props.hoverColor || props.activeColor));
            }
            if (isHovered.value) {
                style.backgroundColor = getHoverColor(getColor(props.hoverColor || props.activeColor));
            }
            return style;
        });
        const { tagComputed, hrefComputed } = useRouterLink(props);
        return {
            anchor,
            computedStyle,
            keyboardFocusListeners,
            tagComputed,
            hrefComputed,
            isHovered,
        };
    },
});

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "anchor",
    class: ["va-sidebar__item va-sidebar-item", { 'va-sidebar-item--active': _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["class", "style", "href", "to"]))
}

script$2.render = render$2;
script$2.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItem.vue";

var script$1 = defineComponent({
    name: 'VaSidebarItemContent',
});

const _hoisted_1$1 = { class: "va-sidebar__item__content va-sidebar-item-content" };

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1$1, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$1.render = render$1;
script$1.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.vue";

var script = defineComponent({
    name: 'VaSidebarItemTitle',
});

const _hoisted_1 = { class: "va-sidebar__title va-sidebar-item-title" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script.render = render;
script.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.vue";

const VaSidebarItemContent = withConfigTransport(script$1);
const VaSidebarItemTitle = withConfigTransport(script);
const VaSidebarItem = withConfigTransport(script$2);

const VaSidebar = withConfigTransport(script$3);

export { VaSidebar, VaSidebarItem, VaSidebarItemContent, VaSidebarItemTitle };
//# sourceMappingURL=index47.js.map
