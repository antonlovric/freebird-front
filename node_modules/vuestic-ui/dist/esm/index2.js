import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, shallowRef, computed, ref, onMounted, nextTick, onBeforeUnmount, openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot, normalizeClass, createCommentVNode } from 'vue';
import { g as getWindow } from './ssr-utils.js';
import { d as debounce_1 } from './debounce.js';
import { f as isObject_1 } from './global-config.js';
import './VaConfig.js';
import './toNumber.js';
import './isSymbol.js';
import './global-properties.js';

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */

function noop() {
  // No operation performed.
}

var noop_1 = noop;

var debounce = debounce_1,
    isObject = isObject_1;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle;

function getWindowHeight() {
    return document.documentElement.clientHeight ||
        window.innerHeight ||
        document.body.clientHeight;
}
function computeAffixedState({ coordinates, offsetTop, offsetBottom, target, }) {
    let isTopAffixed = false;
    let isBottomAffixed = false;
    const windowHeight = getWindowHeight();
    if (offsetTop != null && windowHeight) {
        if (target === window) {
            isTopAffixed = coordinates.top <= offsetTop;
        }
        else {
            const { top } = target.getBoundingClientRect();
            isTopAffixed = coordinates.top - top <= offsetTop;
        }
    }
    if (offsetBottom != null && windowHeight) {
        if (target === window) {
            isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
        }
        else {
            const { bottom } = target.getBoundingClientRect();
            isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
        }
    }
    return {
        isTopAffixed,
        isBottomAffixed,
    };
}
function checkAffixedStateChange(currentState, nextState) {
    return currentState.isTopAffixed !== nextState.isTopAffixed ||
        currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
    const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
    if (!element) {
        return;
    }
    const isInitialCall = !eventName;
    const coordinates = element.getBoundingClientRect();
    const options = {
        offsetBottom,
        offsetTop,
        target,
    };
    const nextState = isInitialCall && initialPosition
        ? computeAffixedState({ coordinates: initialPosition, ...options })
        : computeAffixedState({ coordinates, ...options });
    const prevState = getState();
    if (checkAffixedStateChange(prevState, nextState)) {
        setState({ ...nextState, width: coordinates.width });
    }
    else if (prevState.width !== coordinates.width) {
        setState({ ...prevState, width: coordinates.width });
    }
}
function useCaptureDefault(eventName) {
    // This event type must bubble to the Window object only when dispatched on the Document element
    // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll
    return eventName === 'scroll';
}
function useEventsHandlerWithThrottle(events, { handler, useCapture = useCaptureDefault, wait = 50, }) {
    const clearHandlersArray = events.map(eventName => {
        const _handler = throttle_1((event) => handler(eventName, event), wait);
        window.addEventListener(eventName, _handler, useCapture(eventName));
        return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
    });
    return () => clearHandlersArray.forEach(clear => clear());
}

var script = defineComponent({
    name: 'VaAffix',
    emits: ['change'],
    props: {
        offsetTop: { type: Number, default: undefined },
        offsetBottom: { type: Number, default: undefined },
        target: { type: [Object, Function], default: getWindow },
    },
    setup(props, { emit }) {
        const element = shallowRef();
        const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target);
        const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
        const state = ref({
            isTopAffixed: false,
            isBottomAffixed: false,
        });
        const getState = () => state.value;
        const setState = (newState) => {
            state.value = newState;
            emit('change', isAffixed);
        };
        const calculateTop = () => {
            const target = getTargetElement();
            if (!target) {
                return 0;
            }
            if (props.offsetTop === undefined) {
                return;
            }
            if (!(target instanceof Window)) {
                const { top } = target.getBoundingClientRect();
                return top + props.offsetTop;
            }
            return props.offsetTop;
        };
        const calculateBottom = () => {
            const target = getTargetElement();
            if (!target) {
                return 0;
            }
            if (props.offsetBottom === undefined) {
                return;
            }
            if (!(target instanceof Window)) {
                const { bottom } = target.getBoundingClientRect();
                const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
                const { offsetHeight, clientHeight } = target;
                const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
                return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
            }
            return props.offsetBottom;
        };
        const convertToPixels = (calculate) => {
            const result = calculate();
            return result === undefined ? undefined : `${result}px`;
        };
        const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }]);
        const computedStyle = computed(() => ({
            top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,
            bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,
            width: `${state.value.width}px`,
        }));
        const initialPosition = ref();
        const throttledEventHandler = (eventName, event) => {
            const context = {
                ...props,
                initialPosition: initialPosition.value,
                element: element.value,
                target: getTargetElement(),
                setState,
                getState,
            };
            if (!eventName || eventName === 'resize') {
                handleThrottledEvent(eventName, context);
            }
            else if (event && event.target) {
                const target = getTargetElement();
                if (target === event.target || target instanceof Window) {
                    handleThrottledEvent(eventName, context);
                }
                else {
                    // if we have a custom target but keep scrolling on another element,
                    // so just disable the affixed state
                    setState({
                        isBottomAffixed: false,
                        isTopAffixed: false,
                    });
                }
            }
        };
        let clearEventListeners = noop_1;
        onMounted(() => {
            var _a;
            initialPosition.value = (_a = element.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
            const events = ['scroll', 'resize'];
            clearEventListeners = useEventsHandlerWithThrottle(events, {
                handler: throttledEventHandler,
            });
            nextTick(() => {
                // pass `null` here to make sure it is an initial call
                throttledEventHandler(null);
            });
        });
        onBeforeUnmount(clearEventListeners);
        return {
            computedClass,
            computedStyle,
            isAffixed,
            element,
        };
    },
});

const _hoisted_1 = {
  ref: "element",
  class: "va-affix"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? 'hidden' : 'inherit' })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4 /* STYLE */),
    (_ctx.isAffixed)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.computedClass),
          style: normalizeStyle(_ctx.computedStyle)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6 /* CLASS, STYLE */))
      : createCommentVNode("v-if", true)
  ], 512 /* NEED_PATCH */))
}

script.render = render;
script.__file = "src/components/va-affix/VaAffix.vue";

const VaAffix = withConfigTransport(script);

export { VaAffix };
//# sourceMappingURL=index2.js.map
