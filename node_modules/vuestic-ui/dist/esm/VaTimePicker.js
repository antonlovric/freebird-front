import { toRefs, ref, watch, computed, defineComponent, shallowRef, onMounted, nextTick, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, normalizeClass, renderSlot, normalizeProps, guardReactiveProps, createTextVNode, toDisplayString, resolveComponent, normalizeStyle, createBlock } from 'vue';
import { w as withConfigTransport } from './withConfigTransport.js';
import { d as debounce_1 } from './debounce.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useFocusEmits, a as useFocus } from './useFocus.js';
import 'colortranslator';
import { u as useSyncProp } from './useSyncProp.js';
import { u as useArrayRefs } from './useArrayRefs.js';
import { u as useCSSVariables } from './useCSSVariables.js';
import { u as useFormProps, a as useForm } from './useForm.js';
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from './useStateful.js';

// Use safeModelValue if we need to update model value
const safeModelValue = (m) => m.value ? m.value : new Date(new Date().setHours(0, 0, 0, 0));
const createNumbersArray = (length) => Array.from(Array(length).keys());
/**
 * Convert 00:00 -> 12:00 am, 00:01 -> 01:00 am.
 * So we need to changed 12 and 0 between two formats
 */
const from24to12 = (h) => (h === 0 ? 12 : h) - Number(h > 12) * 12;
const from12to24 = (h, isAM = false) => (h === 12 ? 0 : h) + Number(isAM) * 12;
const createHoursColumn = (props, modelValue, isPM) => {
    const computedSize = computed(() => props.ampm ? 12 : 24);
    const items = computed(() => {
        let array = createNumbersArray(computedSize.value);
        if (props.hoursFilter) {
            array = array.filter((i) => props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
        }
        return array.map((n) => {
            return props.ampm ? from24to12(n) : n;
        });
    });
    const activeItem = computed({
        get: () => {
            if (!modelValue.value) {
                return -1;
            }
            if (props.ampm) {
                const h = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
                return items.value.findIndex((i) => i === h);
            }
            const h = modelValue.value.getHours();
            return items.value.findIndex((i) => i === h);
        },
        set: (newIndex) => {
            if (props.readonly) {
                return;
            }
            const hours = props.ampm ? from12to24(items.value[newIndex], isPM.value) : items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
        },
    });
    return computed(() => ({
        items: items.value,
        activeItem: activeItem,
    }));
};
const createMinutesColumn = (props, modelValue) => {
    const items = computed(() => {
        const array = createNumbersArray(60);
        if (!props.minutesFilter) {
            return array;
        }
        return array.filter(props.minutesFilter);
    });
    const activeItem = computed({
        get: () => {
            if (!modelValue.value) {
                return -1;
            }
            const m = modelValue.value.getMinutes();
            return items.value.findIndex((i) => i === m);
        },
        set: (newIndex) => {
            if (props.readonly) {
                return;
            }
            const v = items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
        },
    });
    return computed(() => ({
        items: items.value,
        activeItem: activeItem,
    }));
};
const createSecondsColumn = (props, modelValue) => {
    const items = computed(() => {
        const array = createNumbersArray(60);
        if (!props.secondsFilter) {
            return array;
        }
        return array.filter(props.secondsFilter);
    });
    const activeItem = computed({
        get: () => {
            if (!modelValue.value) {
                return -1;
            }
            const s = modelValue.value.getSeconds();
            return items.value.findIndex((i) => i === s);
        },
        set: (newIndex) => {
            if (props.readonly) {
                return;
            }
            const v = items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
        },
    });
    return computed(() => ({
        items: items.value,
        activeItem: activeItem,
    }));
};
const createPeriodColumn = (props, modelValue, isPM) => {
    return computed(() => ({
        items: ['AM', 'PM'],
        activeItem: computed({
            get: () => {
                if (!modelValue.value) {
                    return -1;
                }
                return Number(isPM.value);
            },
            set: (val) => {
                isPM.value = Boolean(val);
                const h = safeModelValue(modelValue).getHours();
                let h24 = isPM.value ? h + 12 : h;
                if (isPM.value && h <= 12) {
                    h24 = h + 12;
                }
                if (!isPM.value && h >= 12) {
                    h24 = h - 12;
                }
                // If there is no hoursFilter - it must be valid, otherwise validate hours
                const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
                if (props.periodUpdatesModelValue && isValidFilteredHour) {
                    modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
                }
            },
        }),
    }));
};
const useTimePicker = (props, modelValue) => {
    const { view } = toRefs(props);
    const isPM = ref(false);
    watch(modelValue, () => { isPM.value = safeModelValue(modelValue).getHours() >= 12; }, { immediate: true });
    const hoursColumn = createHoursColumn(props, modelValue, isPM);
    const minutesColumn = createMinutesColumn(props, modelValue);
    const secondsColumn = createSecondsColumn(props, modelValue);
    const periodColumn = createPeriodColumn(props, modelValue, isPM);
    const columns = computed(() => {
        const array = [];
        if (view.value === 'hours') {
            array.push(hoursColumn.value);
        }
        else if (view.value === 'minutes') {
            array.push(hoursColumn.value, minutesColumn.value);
        }
        else if (view.value === 'seconds') {
            array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
        }
        if (props.ampm && !props.hidePeriodSwitch) {
            array.push(periodColumn.value);
        }
        return array;
    });
    return {
        columns,
        isPM,
    };
};

var script$1 = defineComponent({
    name: 'VaTimePickerColumn',
    props: {
        items: { type: Array, default: () => [] },
        activeItemIndex: { type: Number, default: 0 },
        cellHeight: { type: Number, default: 30 },
    },
    emits: ['item-selected', 'update:activeItemIndex', ...useFocusEmits],
    setup(props, { emit }) {
        const rootElement = shallowRef();
        const { focus, blur } = useFocus(rootElement, emit);
        const [syncActiveItemIndex] = useSyncProp('activeItemIndex', props, emit);
        watch(syncActiveItemIndex, (newVal) => { scrollTo(newVal); });
        onMounted(() => scrollTo(syncActiveItemIndex.value, false));
        const scrollTo = (index, animated = true) => {
            nextTick(() => {
                rootElement.value.scrollTo({
                    behavior: animated ? 'smooth' : 'auto',
                    top: index * props.cellHeight,
                });
            });
        };
        const makeActiveByIndex = (index) => {
            syncActiveItemIndex.value = index;
            nextTick(() => scrollTo(syncActiveItemIndex.value));
        };
        const makeActiveNext = (times) => {
            syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
            nextTick(() => scrollTo(syncActiveItemIndex.value));
        };
        const makeActivePrev = (times) => {
            syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
            nextTick(() => scrollTo(syncActiveItemIndex.value));
        };
        const onCellClick = (index) => {
            syncActiveItemIndex.value = index;
        };
        const formatCell = (n) => {
            if (!Number.isInteger(n)) {
                return n;
            }
            return n < 10 ? `0${n}` : `${n}`;
        };
        const getIndex = () => {
            const scrollTop = rootElement.value.scrollTop;
            const calculatedIndex = Math.max((scrollTop - scrollTop % props.cellHeight) / props.cellHeight, scrollTop / props.cellHeight);
            if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
                return Math.ceil(calculatedIndex);
            }
            else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
                return Math.floor(calculatedIndex);
            }
            else {
                return Math.round(calculatedIndex);
            }
        };
        const onScroll = debounce_1(() => {
            if (rootElement.value && syncActiveItemIndex.value !== -1) {
                syncActiveItemIndex.value = getIndex();
            }
        }, 200);
        return {
            rootElement,
            makeActiveNext,
            makeActivePrev,
            makeActiveByIndex,
            onScroll,
            onCellClick,
            formatCell,
            focus,
            blur,
        };
    },
});

const _hoisted_1 = ["onClick"];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers($event => (_ctx.makeActiveNext()), ["stop","prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers($event => (_ctx.makeActiveNext(5)), ["stop","prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers($event => (_ctx.makeActivePrev()), ["stop","prevent"]), ["up"]))
    ],
    onScrollPassive: _cache[3] || (_cache[3] = (...args) => (_ctx.onScroll && _ctx.onScroll(...args))),
    onTouchmovePassive: _cache[4] || (_cache[4] = (...args) => (_ctx.onScroll && _ctx.onScroll(...args)))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return (openBlock(), createElementBlock("div", {
        key: item,
        class: normalizeClass(["va-time-picker-cell", { 'va-time-picker-cell--active': index === _ctx.$props.activeItemIndex }]),
        onClick: $event => (_ctx.onCellClick(index))
      }, [
        renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
          createTextVNode(toDisplayString(_ctx.formatCell(item)), 1 /* TEXT */)
        ])
      ], 10 /* CLASS, PROPS */, _hoisted_1))
    }), 128 /* KEYED_FRAGMENT */))
  ], 544 /* HYDRATE_EVENTS, NEED_PATCH */))
}

script$1.render = render$1;
script$1.__file = "src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue";

const VaTimePickerColumn = withConfigTransport(script$1);

var script = defineComponent({
    name: 'VaTimePicker',
    components: { VaTimePickerColumn },
    props: {
        ...useStatefulProps,
        ...useFormProps,
        modelValue: { type: Date, required: false },
        ampm: { type: Boolean, default: false },
        hidePeriodSwitch: { type: Boolean, default: false },
        periodUpdatesModelValue: { type: Boolean, default: true },
        view: { type: String, default: 'minutes' },
        hoursFilter: { type: Function },
        minutesFilter: { type: Function },
        secondsFilter: { type: Function },
        framed: { type: Boolean, default: false },
        cellHeight: { type: Number, default: 30 },
        visibleCellsCount: { type: Number, default: 7 },
    },
    emits: useStatefulEmits,
    setup(props, { emit }) {
        const { valueComputed } = useStateful(props, emit);
        const { columns, isPM } = useTimePicker(props, valueComputed);
        const { setItemRef, itemRefs: pickers } = useArrayRefs();
        const activeColumnIndex = ref();
        const focus = (idx = 0) => {
            var _a;
            (_a = pickers.value[idx]) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const blur = (idx) => {
            var _a;
            idx ? (_a = pickers.value[idx]) === null || _a === void 0 ? void 0 : _a.blur() : pickers.value.forEach((el) => el === null || el === void 0 ? void 0 : el.blur());
        };
        const { computedClasses: computedFormClasses } = useForm('va-time-picker', props);
        const focusNext = () => {
            const nextIndex = ((activeColumnIndex === null || activeColumnIndex === void 0 ? void 0 : activeColumnIndex.value) || 0) + 1;
            activeColumnIndex.value = nextIndex % columns.value.length;
            focus(activeColumnIndex.value);
        };
        const focusPrev = () => {
            const nextIndex = ((activeColumnIndex === null || activeColumnIndex === void 0 ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
            activeColumnIndex.value = nextIndex % columns.value.length;
            focus(activeColumnIndex.value);
        };
        const computedClasses = computed(() => ({
            ...computedFormClasses,
            'va-time-picker--framed': props.framed,
        }));
        const computedStyles = useCSSVariables('va-time-picker', () => {
            const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
            return {
                height: `${props.cellHeight * props.visibleCellsCount}px`,
                'cell-height': `${props.cellHeight}px`,
                'column-gap-height': `${gapHeight}px`,
            };
        });
        return {
            columns,
            computedStyles,
            computedClasses,
            isPM,
            pickers,
            setItemRef,
            focusNext,
            focusPrev,
            activeColumnIndex,
            focus,
            blur,
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return (openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": $event => ((column.activeItem.value) = $event),
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers($event => (_ctx.focusNext()), ["stop","prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers($event => (_ctx.focusNext()), ["exact","stop","prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers($event => (_ctx.focusPrev()), ["stop","prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers($event => (_ctx.focusPrev()), ["shift","stop","prevent"]), ["tab"]))
        ],
        onFocus: $event => (_ctx.activeColumnIndex = idx)
      }, null, 8 /* PROPS */, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]))
    }), 128 /* KEYED_FRAGMENT */))
  ], 6 /* CLASS, STYLE */))
}

script.render = render;
script.__file = "src/components/va-time-picker/VaTimePicker.vue";

export { script as s };
//# sourceMappingURL=VaTimePicker.js.map
