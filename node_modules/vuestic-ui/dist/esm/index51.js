import { w as withConfigTransport } from './withConfigTransport.js';
import { ref, defineComponent, shallowRef, computed, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, normalizeStyle, withKeys, withModifiers, withCtx, createVNode, mergeProps, toHandlers, createSlots, renderSlot, normalizeProps, guardReactiveProps, createCommentVNode, renderList } from 'vue';
import { s as script$2, o as omit_1 } from './VaIcon.js';
import { e as extractComponentProps, f as filterComponentProps } from './child-props.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { s as script$3, u as useClearableEmits, a as useClearable } from './VaInput.js';
import 'colortranslator';
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from './index67.js';
import { u as useSyncProp } from './useSyncProp.js';
import { s as script$1 } from './VaTimePicker.js';
import { VaDropdown, VaDropdownContent } from './index27.js';
import './VaConfig.js';
import './useColors.js';
import './useSize.js';
import './global-properties.js';
import './isSymbol.js';
import './ssr-utils.js';
import './useFocus.js';
import './useEmitProxy.js';
import './useCaptureEvent.js';
import './useForm.js';
import './useBem.js';
import './_createCompounder.js';
import 'cleave.js';
import './VaInputWrapper.js';
import './useCSSVariables.js';
import './index31.js';
import './consts.js';
import './debounce.js';
import './toNumber.js';
import './useArrayRefs.js';
import './useStateful.js';
import './useTextColor.js';

const parse = (text) => {
    const m = text.match(/[0-9]{1,2}/g);
    if (!m) {
        return [];
    }
    return m.map((s) => Number(s));
};
const parsePeriod = (text) => {
    const m = text.match(/pm|am/i);
    if (!m) {
        return null;
    }
    return Number(m[0].toLowerCase() === 'pm');
};
const defaultParseDateFunction = (text) => {
    const d = new Date();
    const [h, m, s] = parse(text);
    const period = parsePeriod(text);
    if (!h) {
        return null;
    }
    const is12format = period !== null && h <= 12;
    const isPM = is12format && !!period;
    // Switch 12 to 0, because of 12h format
    const fh = is12format ? (h === 12 ? 0 : h) : h;
    d.setHours(Math.min((fh || 0), is12format ? 12 : 24) + (isPM ? 12 : 0));
    d.setMinutes(Math.min(m || 0, 60));
    d.setSeconds(Math.min(s || 0, 60));
    return d;
};
const useTimeParser = (props) => {
    // const isTextIsMultipleDates = (text: string) => text.includes(props.delimiter)
    // const isTextIsDateRange = (text: string) => text.includes(props.rangeDelimiter)
    const getParseDateFn = () => props.parse || defaultParseDateFunction;
    const isValid = ref(true);
    const parseDate = (text) => {
        const parse = getParseDateFn();
        const result = parse(text);
        if (!result) {
            isValid.value = false;
        }
        return result;
    };
    const parse = (text) => {
        isValid.value = true;
        // if (props.parse) {
        //   return props.parse(text, isValid)
        // }
        // if (isTextIsMultipleDates(text)) {
        //   return text.split(props.delimiter).map((dateText) => parseDate(dateText))
        // }
        // if (isTextIsDateRange(text)) {
        //   const [start, end] = text.split(props.rangeDelimiter).map((dateText) => parseDate(dateText))
        //   return { start, end }
        // }
        return parseDate(text);
    };
    return {
        parse,
        isValid,
    };
};

const useTimeFormatter = (props) => {
    const formatDate = (date) => {
        if (!date) {
            return '';
        }
        if (props.ampm) {
            return date.toLocaleTimeString('en-US');
        }
        return date.toLocaleTimeString('en-GB');
    };
    const sliceTime = (time, start, end) => time.split(':').slice(start, end).join(':');
    const formatWithView = (date) => {
        if (props.view === 'seconds') {
            return formatDate(date);
        }
        const [time, period] = formatDate(date).split(' ');
        if (props.view === 'minutes') {
            if (!period) {
                return sliceTime(time, 0, 2);
            }
            return [sliceTime(time, 0, 2), period].join(' ');
        }
        if (props.view === 'hours') {
            if (!period) {
                return sliceTime(time, 0, 1);
            }
            return [sliceTime(time, 0, 1), period].join(' ');
        }
        return '';
    };
    return {
        format: (date) => props.format ? props.format(date) : formatWithView(date),
    };
};

const VaInputProps = extractComponentProps(script$3, [
    'mask', 'returnRaw', 'autosize', 'minRows', 'maxRows', 'type', 'inputmode', 'counter', 'maxLength',
]);
var script = defineComponent({
    name: 'VaTimeInput',
    components: { VaDropdown, VaDropdownContent, VaTimePicker: script$1, VaIcon: script$2, VaInput: script$3 },
    emits: [...useValidationEmits, ...useClearableEmits, 'update:modelValue', 'update:isOpen'],
    props: {
        ...VaInputProps,
        ...extractComponentProps(script$1),
        ...useValidationProps,
        isOpen: { type: Boolean, default: undefined },
        modelValue: { type: Date, default: undefined },
        clearValue: { type: Date, default: undefined },
        format: { type: Function },
        parse: { type: Function },
        manualInput: { type: Boolean, default: false },
        leftIcon: { type: Boolean, default: false },
        icon: { type: String, default: 'schedule' },
    },
    inheritAttrs: false,
    setup(props, { emit, attrs, slots }) {
        const input = shallowRef();
        const timePicker = shallowRef();
        const [isOpenSync] = useSyncProp('isOpen', props, emit, false);
        const [modelValueSync] = useSyncProp('modelValue', props, emit);
        const { parse, isValid } = useTimeParser(props);
        const { format } = useTimeFormatter(props);
        const valueText = computed(() => format(modelValueSync.value || props.clearValue));
        const onInputTextChanged = (val) => {
            if (!val) {
                return reset();
            }
            const v = parse(val);
            if (isValid.value && v) {
                modelValueSync.value = v;
            }
            else {
                modelValueSync.value = undefined;
                isValid.value = true;
            }
        };
        // --- not used yet ---
        // const changePeriod = (isPM: boolean) => {
        //   if (!modelValueSync.value) { return }
        //   const halfDayPeriod = 12
        //   const h = modelValueSync.value.getHours()
        //   if (isPM && h <= halfDayPeriod) {
        //     modelValueSync.value = new Date(modelValueSync.value.setHours(h + halfDayPeriod))
        //   } else if (!isPM && h >= halfDayPeriod) {
        //     modelValueSync.value = new Date(modelValueSync.value.setHours(h - halfDayPeriod))
        //   }
        // }
        // const changePeriodToPm = () => changePeriod(true)
        // const changePeriodToAm = () => changePeriod(false)
        const reset = () => {
            emit('update:modelValue', props.clearValue);
            emit('clear');
        };
        const focus = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const blur = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
        };
        const { computedError, computedErrorMessages, listeners } = useValidation(props, emit, reset, focus);
        const { canBeCleared, clearIconProps, onFocus, onBlur, } = useClearable(props, valueText);
        const canBeClearedComputed = computed(() => (canBeCleared.value && valueText.value !== format(props.clearValue)));
        const iconProps = computed(() => ({
            name: props.icon,
            color: props.color,
            size: 'small',
        }));
        const computedInputProps = computed(() => ({
            ...filterComponentProps(props, VaInputProps).value,
            clearable: false,
            rules: [],
            error: computedError.value,
            errorMessages: computedErrorMessages.value,
            readonly: props.readonly || !props.manualInput,
        }));
        const computedInputListeners = computed(() => ({
            focus: () => {
                onFocus();
                listeners.onFocus();
            },
            blur: () => {
                onBlur();
                listeners.onBlur();
            },
        }));
        const iconsTabIndexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
        const computedInputAttrs = computed(() => ({
            ariaLabel: props.label || 'selected time',
            ariaDisabled: props.disabled,
            ariaReadonly: props.readonly,
            tabindex: props.disabled ? -1 : 0,
            ...omit_1(attrs, ['class', 'style']),
        }));
        const filteredSlots = computed(() => {
            const slotsWithIcons = [
                props.leftIcon && 'prependInner',
                (!props.leftIcon || props.clearable) && 'icon',
            ];
            return Object.keys(slots).filter(slot => !slotsWithIcons.includes(slot));
        });
        const hideDropdown = () => {
            isOpenSync.value = false;
            focus();
        };
        const showDropdownWithoutFocus = () => {
            isOpenSync.value = true;
        };
        const showDropdown = (event, cancel, prevent) => {
            if (cancel) {
                return;
            }
            if (prevent) {
                event === null || event === void 0 ? void 0 : event.preventDefault();
            }
            showDropdownWithoutFocus();
            nextTick(() => { var _a; return (_a = timePicker.value) === null || _a === void 0 ? void 0 : _a.focus(); });
        };
        const toggleDropdown = () => {
            isOpenSync.value ? hideDropdown() : showDropdown();
        };
        const toggleDropdownWithoutFocus = () => {
            isOpenSync.value ? hideDropdown() : showDropdownWithoutFocus();
        };
        return {
            input,
            timePicker,
            timePickerProps: filterComponentProps(props, extractComponentProps(script$1)),
            computedInputProps,
            computedInputAttrs,
            computedInputListeners,
            iconsTabIndexComputed,
            isOpenSync,
            modelValueSync,
            valueText,
            onInputTextChanged,
            canBeClearedComputed,
            iconProps,
            clearIconProps,
            filteredSlots,
            hideDropdown,
            showDropdown,
            toggleDropdown,
            toggleDropdownWithoutFocus,
            reset,
            focus,
            blur,
            onFocus,
            onBlur,
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");

  return (openBlock(), createBlock(_component_va_dropdown, {
    class: normalizeClass(["va-time-input", _ctx.$attrs.class]),
    style: normalizeStyle(_ctx.$attrs.style),
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((_ctx.isOpenSync) = $event)),
    placement: "bottom-start",
    offset: [2, 0],
    "close-on-content-click": false,
    disabled: _ctx.$props.disabled,
    anchorSelector: ".va-input-wrapper__field",
    stateful: false,
    trigger: "none",
    onKeydown: [
      withKeys(withModifiers(_ctx.showDropdown, ["prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.showDropdown, ["prevent"]), ["down"]),
      _cache[3] || (_cache[3] = withKeys($event => (_ctx.showDropdown($event, _ctx.$props.manualInput, !_ctx.$props.manualInput)), ["space"])),
      _cache[4] || (_cache[4] = withKeys($event => (!_ctx.$props.manualInput && _ctx.showDropdown()), ["enter"])),
      withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
    ],
    onClick: _cache[5] || (_cache[5] = $event => ((!_ctx.$props.manualInput || _ctx.isOpenSync) && _ctx.toggleDropdownWithoutFocus()))
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input, mergeProps({ ref: "input" }, { ..._ctx.computedInputProps, ..._ctx.computedInputAttrs }, toHandlers(_ctx.computedInputListeners), {
        modelValue: _ctx.valueText,
        onChange: _cache[0] || (_cache[0] = $event => (_ctx.onInputTextChanged($event.target.value)))
      }), createSlots({
        prependInner: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))),
          (_ctx.$props.leftIcon)
            ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                role: "button",
                "aria-label": "toggle dropdown",
                "aria-hidden": "false",
                tabindex: _ctx.iconsTabIndexComputed
              }, _ctx.iconProps, {
                onClick: withModifiers(_ctx.toggleDropdown, ["stop"]),
                onKeydown: withKeys(withModifiers(_ctx.toggleDropdown, ["stop"]), ["enter"])
              }), null, 16 /* FULL_PROPS */, ["tabindex", "onClick", "onKeydown"]))
            : createCommentVNode("v-if", true)
        ]),
        icon: withCtx(() => [
          (_ctx.canBeClearedComputed)
            ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                role: "button",
                "aria-label": "reset",
                "aria-hidden": "false",
                tabindex: _ctx.iconsTabIndexComputed
              }, _ctx.clearIconProps, {
                onClick: withModifiers(_ctx.reset, ["stop"]),
                onKeydown: withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                onFocus: _ctx.onFocus,
                onBlur: _ctx.onBlur
              }), null, 16 /* FULL_PROPS */, ["tabindex", "onClick", "onKeydown", "onFocus", "onBlur"]))
            : (!_ctx.$props.leftIcon)
              ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                  key: 1,
                  role: "button",
                  "aria-label": "toggle dropdown",
                  "aria-hidden": "false",
                  class: "va-dropdown__icons__reset",
                  tabindex: _ctx.iconsTabIndexComputed
                }, _ctx.iconProps, {
                  onClick: withModifiers(_ctx.toggleDropdown, ["stop"]),
                  onKeydown: withKeys(withModifiers(_ctx.toggleDropdown, ["stop"]), ["enter"])
                }), null, 16 /* FULL_PROPS */, ["tabindex", "onClick", "onKeydown"]))
              : createCommentVNode("v-if", true)
        ]),
        _: 2 /* DYNAMIC */
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name: name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))
            ])
          }
        })
      ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["modelValue"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((_ctx.modelValueSync) = $event))
          }), null, 16 /* FULL_PROPS */, ["modelValue"])
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["onKeydown", "onKeypress"])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["class", "style", "modelValue", "disabled", "onKeydown"]))
}

script.render = render;
script.__file = "src/components/va-time-input/VaTimeInput.vue";

const VaTimeInput = withConfigTransport(script);

export { VaTimeInput };
//# sourceMappingURL=index51.js.map
