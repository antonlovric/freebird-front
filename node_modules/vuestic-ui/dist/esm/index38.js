import { w as withConfigTransport } from './withConfigTransport.js';
import { defineComponent, computed, onMounted, resolveComponent, openBlock, createBlock, withCtx, createElementVNode, createElementBlock, Fragment, renderList, renderSlot, normalizeProps, guardReactiveProps, mergeProps } from 'vue';
import { e as pick_1 } from './usePopover.js';
import { _ as __DEV__ } from './global-utils.js';
import { u as useArrayRefs } from './useArrayRefs.js';
import './global-config.js';
import 'colortranslator';
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from './useStateful.js';
import { u as useValidationProps, b as useValidation } from './index67.js';
import { u as useSelectableListProps, a as useSelectableList } from './useSelectableList.js';
import { VaCheckbox } from './index15.js';
import { VaRadio } from './index44.js';
import { VaSwitch } from './index49.js';
import { s as script$1 } from './VaMessageListWrapper.js';
import './VaConfig.js';
import './isSymbol.js';
import './ssr-utils.js';
import './global-properties.js';
import './useSyncProp.js';
import './useFocus.js';
import './consts.js';
import './useColors.js';
import './utils.js';
import './useKeyboardOnlyFocus.js';
import './useSelectable.js';
import './useLoading.js';
import './useTextColor.js';
import './index31.js';
import './VaIcon.js';
import './useSize.js';
import './useForm.js';
import './useBem.js';
import './_createCompounder.js';
import './index43.js';
import './clamp.js';
import './toNumber.js';

var script = defineComponent({
    name: 'VaOptionList',
    components: {
        VaRadio,
        VaCheckbox,
        VaSwitch,
        VaMessageListWrapper: script$1,
    },
    emits: [...useStatefulEmits],
    props: {
        ...useSelectableListProps,
        ...useValidationProps,
        ...useStatefulProps,
        type: {
            type: String,
            default: 'checkbox',
            validator: (type) => ['radio', 'checkbox', 'switch'].includes(type),
        },
        disabled: ({ type: Boolean, default: false }),
        readonly: ({ type: Boolean, default: false }),
        defaultValue: ({ type: [String, Number, Object, Array] }),
        name: ({ type: String, default: '' }),
        color: ({ type: String, default: 'primary' }),
        leftLabel: ({ type: Boolean, default: false }),
        modelValue: ({ type: [String, Number, Object, Array] }),
    },
    setup(props, { emit }) {
        const { valueComputed } = useStateful(props, emit, props.defaultValue);
        const { getValue, getText, getTrackBy, getDisabled } = useSelectableList(props);
        const { itemRefs, setItemRef } = useArrayRefs();
        const isRadio = computed(() => props.type === 'radio');
        const selectedValue = computed({
            get() {
                const value = isRadio.value ? null : [];
                return valueComputed.value || value;
            },
            set(value) {
                if (props.readonly) {
                    return;
                }
                if (isRadio.value && !Array.isArray(value)) {
                    valueComputed.value = value ? getValue(value) : value;
                }
                else {
                    valueComputed.value = Array.isArray(value)
                        ? value.map(getValue)
                        : [value ? getValue(value) : value];
                }
            },
        });
        const getKey = (option) => getTrackBy(option);
        const isDisabled = (option) => props.disabled || getDisabled(option);
        const reset = () => { valueComputed.value = undefined; };
        const focus = () => {
            const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find(el => !el.disabled);
            if (firstActiveEl && typeof firstActiveEl.focus === 'function') {
                firstActiveEl.focus();
            }
        };
        const { computedError, computedErrorMessages } = useValidation(props, emit, reset, focus);
        const computedProps = computed(() => pick_1(props, ['name', 'color', 'readonly', 'leftLabel']));
        onMounted(() => {
            if (__DEV__ && props.type !== 'radio' && !Array.isArray(props.modelValue)) {
                console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!\n For component property 'type = ${props.type}' it must be of type 'array'.`);
            }
        });
        return {
            selectedValue,
            computedError,
            computedErrorMessages,
            getValue,
            getText,
            getKey,
            isDisabled,
            reset,
            focus,
            setItemRef,
            computedProps,
        };
    },
});

const _hoisted_1 = { class: "va-option-list__list" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");

  return (openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createElementVNode("ul", _hoisted_1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return (openBlock(), createElementBlock("li", {
            key: _ctx.getKey(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              (_ctx.$props.type === 'radio')
                ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                    key: 0,
                    ref_for: true,
                    ref: _ctx.setItemRef,
                    modelValue: _ctx.selectedValue,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.selectedValue) = $event)),
                    label: _ctx.getText(option),
                    disabled: _ctx.isDisabled(option),
                    option: _ctx.getValue(option)
                  }, _ctx.computedProps), null, 16 /* FULL_PROPS */, ["modelValue", "label", "disabled", "option"]))
                : (_ctx.$props.type === 'checkbox')
                  ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                      key: 1,
                      ref_for: true,
                      ref: _ctx.setItemRef,
                      modelValue: _ctx.selectedValue,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((_ctx.selectedValue) = $event)),
                      label: _ctx.getText(option),
                      disabled: _ctx.isDisabled(option),
                      "array-value": _ctx.getValue(option)
                    }, _ctx.computedProps), null, 16 /* FULL_PROPS */, ["modelValue", "label", "disabled", "array-value"]))
                  : (openBlock(), createBlock(_component_va_switch, mergeProps({
                      key: 2,
                      ref_for: true,
                      ref: _ctx.setItemRef,
                      modelValue: _ctx.selectedValue,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((_ctx.selectedValue) = $event)),
                      label: _ctx.getText(option),
                      disabled: _ctx.isDisabled(option),
                      "array-value": _ctx.getValue(option)
                    }, _ctx.computedProps), null, 16 /* FULL_PROPS */, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]))
        }), 128 /* KEYED_FRAGMENT */))
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["error", "error-messages", "error-count"]))
}

script.render = render;
script.__file = "src/components/va-option-list/VaOptionList.vue";

const VaOptionList = withConfigTransport(script);

export { VaOptionList };
//# sourceMappingURL=index38.js.map
