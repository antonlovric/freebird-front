import { defineComponent, shallowRef, ref, computed, onMounted, resolveComponent, openBlock, createBlock, Transition, withCtx, withDirectives, createElementVNode, normalizeClass, normalizeStyle, createElementBlock, toDisplayString, createCommentVNode, vShow, createVNode, withModifiers, withKeys, getCurrentInstance, render as render$1 } from 'vue';
import { a as getGlobal } from './ssr-utils.js';
import { w as withConfigTransport } from './withConfigTransport.js';
import './global-config.js';
import './usePopover.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';
import { u as useTextColor } from './useTextColor.js';
import { s as script$1 } from './VaIcon.js';

const useTimer = () => {
    let timer;
    const start = (...args) => {
        timer = window.setTimeout(...args);
        return timer;
    };
    const clear = () => timer && window.clearTimeout(timer);
    return {
        start,
        clear,
    };
};

const VaToastRenderer = defineComponent({
    name: 'VaToastRenderer',
    props: {
        render: { type: Function, required: true },
    },
    setup: (props) => () => props.render(),
});
var script = defineComponent({
    name: 'VaToast',
    components: { VaIcon: script$1, VaToastRenderer },
    emits: ['on-click', 'on-close'],
    props: {
        title: { type: String, default: '' },
        offsetY: { type: Number, default: 16 },
        offsetX: { type: Number, default: 16 },
        message: { type: [String, Function], default: '' },
        dangerouslyUseHtmlString: { type: Boolean, default: false },
        icon: { type: String, default: 'close' },
        customClass: { type: String, default: '' },
        duration: { type: Number, default: 5000 },
        color: { type: String, default: '' },
        closeable: { type: Boolean, default: true },
        onClose: { type: Function },
        onClick: { type: Function },
        multiLine: { type: Boolean, default: false },
        position: {
            type: String,
            default: 'top-right',
            validator: (value) => ['top-right', 'top-left', 'bottom-right', 'bottom-left'].includes(value),
        },
        render: { type: Function },
    },
    setup(props, { emit }) {
        const rootElement = shallowRef();
        const { getColor } = useColors();
        const { textColorComputed } = useTextColor();
        const visible = ref(false);
        const positionX = computed(() => {
            return props.position.includes('right') ? 'right' : 'left';
        });
        const positionY = computed(() => {
            return props.position.includes('top') ? 'top' : 'bottom';
        });
        const toastClasses = computed(() => [
            props.customClass,
            props.multiLine ? 'va-toast--multiline' : '',
        ]);
        const toastStyles = computed(() => ({
            [positionY.value]: `${props.offsetY}px`,
            [positionX.value]: `${props.offsetX}px`,
            backgroundColor: getColor(props.color),
            color: textColorComputed.value,
        }));
        const computedMessage = computed(() => (typeof props.message === 'function') ? props.message() : props.message);
        const destroyElement = () => {
            var _a, _b;
            (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.removeEventListener('transitionend', destroyElement);
            (_b = rootElement.value) === null || _b === void 0 ? void 0 : _b.remove();
        };
        const onToastClick = () => {
            if (typeof props.onClick === 'function') {
                props.onClick();
            }
            else {
                emit('on-click');
            }
        };
        const onToastClose = () => {
            var _a;
            visible.value = false;
            (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.addEventListener('transitionend', destroyElement);
            if (typeof props.onClose === 'function') {
                props.onClose();
            }
            else {
                emit('on-close');
            }
        };
        const timer = useTimer();
        const clearTimer = timer.clear;
        const startTimer = () => {
            if (props.duration > 0) {
                timer.start(() => visible.value && onToastClose(), props.duration);
            }
        };
        onMounted(() => {
            visible.value = true;
            startTimer();
        });
        return {
            visible,
            toastClasses,
            toastStyles,
            computedMessage,
            onToastClick,
            onToastClose,
            startTimer,
            clearTimer,
        };
    },
});

const _hoisted_1 = ["role"];
const _hoisted_2 = { class: "va-toast__group" };
const _hoisted_3 = ["textContent"];
const _hoisted_4 = { class: "va-toast__content" };
const _hoisted_5 = ["innerHTML"];
const _hoisted_6 = ["textContent"];
const _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");

  return (openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? 'alertdialog' : 'alert',
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => (_ctx.clearTimer && _ctx.clearTimer(...args))),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => (_ctx.startTimer && _ctx.startTimer(...args))),
        onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.onToastClick && _ctx.onToastClick(...args)))
      }, [
        createElementVNode("div", _hoisted_2, [
          (_ctx.$props.title)
            ? (openBlock(), createElementBlock("h2", {
                key: 0,
                class: "va-toast__title",
                textContent: toDisplayString(_ctx.$props.title)
              }, null, 8 /* PROPS */, _hoisted_3))
            : createCommentVNode("v-if", true),
          withDirectives(createElementVNode("div", _hoisted_4, [
            (_ctx.$props.dangerouslyUseHtmlString)
              ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  innerHTML: _ctx.computedMessage
                }, null, 8 /* PROPS */, _hoisted_5))
              : (openBlock(), createElementBlock("p", {
                  key: 1,
                  textContent: toDisplayString(_ctx.computedMessage)
                }, null, 8 /* PROPS */, _hoisted_6))
          ], 512 /* NEED_PATCH */), [
            [vShow, _ctx.$props.message]
          ]),
          (_ctx.$props.render)
            ? (openBlock(), createElementBlock("div", _hoisted_7, [
                createVNode(_component_VaToastRenderer, {
                  render: _ctx.$props.render
                }, null, 8 /* PROPS */, ["render"])
              ]))
            : createCommentVNode("v-if", true),
          (_ctx.$props.closeable)
            ? (openBlock(), createBlock(_component_va_icon, {
                key: 2,
                class: "va-toast__close-icon",
                role: "button",
                "aria-label": "close toast",
                "aria-hidden": "false",
                tabindex: "0",
                size: "small",
                name: _ctx.$props.icon,
                onClick: withModifiers(_ctx.onToastClose, ["stop"]),
                onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
              }, null, 8 /* PROPS */, ["name", "onClick", "onKeydown"]))
            : createCommentVNode("v-if", true)
        ])
      ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1 /* STABLE */
  }))
}

script.render = render;
script.__file = "src/components/va-toast/VaToast.vue";

/** This hook can be used without plugin used */
const useToast = () => {
    var _a;
    const appContext = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.appContext;
    const createdInThisSetupContext = [];
    /**
     * @param options can be options object or message string
     */
    const init = (options) => {
        const id = createToastInstance(options, appContext);
        if (id) {
            createdInThisSetupContext.push(id);
        }
        return id;
    };
    const close = (id) => closeById(id);
    /**
     * Closes all VaToast instances in current App instance.
     * @param allApps if you have multiple vue apps on page, set allApps to true to close it for all apps.
     */
    const closeAll = (allApps = false) => closeAllNotifications(allApps ? undefined : appContext);
    /** Use this method if you need to close only toasts that created with this hook */
    const closeAllCreatedInThisHook = () => {
        createdInThisSetupContext.forEach((id) => closeById(id));
    };
    return {
        init, close, closeAll, closeAllCreatedInThisHook,
    };
};

const VaToast = withConfigTransport(script);

const GAP = 5;
let seed = 1;
getGlobal().vaToastInstances = [];
const getTranslateValue = (item, position) => {
    if (item.el) {
        const direction = position.includes('bottom') ? -1 : 1;
        return (item.el.offsetHeight + GAP) * direction;
    }
    return 0;
};
const getNewTranslateValue = (transformY, redundantHeight, position) => {
    const direction = position.includes('bottom') ? -1 : 1;
    return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
const getNodeProps = (vNode) => {
    var _a;
    return ((_a = vNode.component) === null || _a === void 0 ? void 0 : _a.props) || {};
};
const closeNotification = (targetInstance, destroyElementFn) => {
    var _a;
    if (!targetInstance) {
        return;
    }
    if (!getGlobal().vaToastInstances.length) {
        seed = 1;
        return;
    }
    const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
    if (targetInstanceIndex < 0) {
        return;
    }
    const nodeProps = getNodeProps(targetInstance);
    const { offsetX: targetOffsetX, offsetY: targetOffsetY, position: targetPosition, } = nodeProps;
    const redundantHeight = (_a = targetInstance.el) === null || _a === void 0 ? void 0 : _a.offsetHeight;
    destroyElementFn();
    getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
        if (instance === targetInstance) {
            return acc;
        }
        if (instance.component) {
            const { offsetX, offsetY, position } = getNodeProps(instance);
            const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
            if (isNextInstance && instance.el && redundantHeight) {
                const [_, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
                const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
                instance.el.style.transform = `translate(0, ${transformYNew}px)`;
            }
        }
        return [...acc, instance];
    }, []);
    if (!getGlobal().vaToastInstances.length) {
        seed = 1;
    }
};
const destroy = (el, node) => {
    if (el) {
        render$1(null, el);
        el.remove();
    }
    el = null;
};
const mount = (component, { props, children, element, appContext, } = {}) => {
    let el = element;
    // eslint-disable-next-line prefer-const
    let vNode;
    const onClose = () => {
        closeNotification(vNode, () => destroy(el));
        if (props === null || props === void 0 ? void 0 : props.onClose) {
            props.onClose();
        }
    };
    vNode = createVNode(component, { ...props, onClose }, children);
    if (appContext) {
        vNode.appContext = appContext;
    }
    if (el) {
        render$1(vNode, el);
    }
    else if (typeof document !== 'undefined') {
        render$1(vNode, el = document.createElement('div'));
    }
    return { vNode, el };
};
const closeAllNotifications = (appContext) => {
    if (!getGlobal().vaToastInstances.length) {
        seed = 1;
        return;
    }
    getGlobal().vaToastInstances.forEach(instance => {
        if (appContext && instance.appContext !== appContext) {
            return;
        }
        getNodeProps(instance).onClose();
    });
};
const closeById = (id) => {
    const targetInstance = getGlobal().vaToastInstances.find(instance => { var _a; return ((_a = instance.el) === null || _a === void 0 ? void 0 : _a.id) === id; });
    if (targetInstance) {
        const nodeProps = getNodeProps(targetInstance);
        nodeProps.onClose();
    }
};
const getToastOptions = (options) => {
    if (typeof options === 'string') {
        return {
            message: options,
        };
    }
    return options;
};
const createToastInstance = (customProps, appContext) => {
    const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
    const nodeProps = getNodeProps(vNode);
    if (el && vNode.el && nodeProps) {
        document.body.appendChild(el.childNodes[0]);
        const { offsetX, offsetY, position } = nodeProps;
        vNode.el.style.display = 'flex';
        vNode.el.id = 'notification_' + seed;
        let transformY = 0;
        getGlobal().vaToastInstances.filter(item => {
            const { offsetX: itemOffsetX, offsetY: itemOffsetY, position: itemPosition, } = getNodeProps(item);
            return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
        }).forEach((item) => {
            transformY += getTranslateValue(item, position);
        });
        vNode.el.style.transform = `translate(0, ${transformY}px)`;
        seed += 1;
        getGlobal().vaToastInstances.push(vNode);
        return vNode.el.id;
    }
    return null;
};

export { VaToast as V, closeById as a, closeAllNotifications as b, createToastInstance as c, useToast as u };
//# sourceMappingURL=toast.js.map
