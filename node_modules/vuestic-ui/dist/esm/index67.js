import { watch, inject, onMounted, onBeforeUnmount, defineComponent, computed, openBlock, createElementBlock, normalizeStyle, Fragment, renderList, toDisplayString, createCommentVNode } from 'vue';
import { f as flatten_1 } from './usePopover.js';
import { t as _baseGetTag, i as isArray_1, v as isObjectLike_1, w as isFunction_1 } from './global-config.js';
import { u as useSyncProp } from './useSyncProp.js';
import { a as useFocus } from './useFocus.js';
import { F as FormServiceKey } from './consts.js';
import { w as withConfigTransport } from './withConfigTransport.js';
import './global-utils.js';
import { u as useColors } from './useColors.js';

var baseGetTag = _baseGetTag,
    isArray = isArray_1,
    isObjectLike = isObjectLike_1;

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

var isString_1 = isString;

const normalizeValidationRules = (rules = [], callArguments = null) => {
    if (isString_1(rules)) {
        rules = [rules];
    }
    return rules
        .map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
const useValidationProps = {
    modelValue: { required: false },
    error: { type: Boolean, default: undefined },
    errorMessages: { type: [Array, String], default: undefined },
    errorCount: { type: [String, Number], default: 1 },
    rules: { type: Array, default: () => [] },
    success: { type: Boolean, default: false },
    messages: { type: [Array, String], default: () => [] },
    immediateValidation: { type: Boolean, default: false },
};
const useValidationEmits = ['update:error', 'update:errorMessages'];
const useValidation = (props, emit, reset, focus) => {
    const { isFocused, onFocus, onBlur } = useFocus();
    const [computedError] = useSyncProp('error', props, emit, false);
    const [computedErrorMessages] = useSyncProp('errorMessages', props, emit, []);
    const resetValidation = () => {
        computedError.value = false;
        computedErrorMessages.value = [];
    };
    const validate = () => {
        if (!props.rules || !props.rules.length) {
            return true;
        }
        let error = false;
        let errorMessages = [];
        const rules = flatten_1(props.rules);
        normalizeValidationRules(rules, props.modelValue)
            .forEach((validationResult) => {
            if (isString_1(validationResult)) {
                errorMessages = [...errorMessages, validationResult];
                error = true;
            }
            else if (validationResult === false) {
                error = true;
            }
        });
        computedErrorMessages.value = errorMessages;
        computedError.value = error;
        return !error;
    };
    watch(isFocused, (newVal) => !newVal && validate());
    watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
    const context = {
        resetValidation,
        focus,
        validate,
        reset,
        hasError: () => computedError.value,
    };
    const form = inject(FormServiceKey, undefined);
    onMounted(() => {
        form === null || form === void 0 ? void 0 : form.onChildMounted(context);
    });
    onBeforeUnmount(() => {
        form === null || form === void 0 ? void 0 : form.onChildUnmounted(context);
    });
    return {
        computedError,
        computedErrorMessages,
        listeners: { onFocus, onBlur },
        validate,
        resetValidation,
    };
};

var script = defineComponent({
    name: 'VaMessageList',
    props: {
        modelValue: {
            type: [String, Array],
            default: '',
        },
        limit: { type: Number, default: 1 },
        color: { type: String },
    },
    setup(props) {
        const { getColor } = useColors();
        return {
            messages: computed(() => {
                if (!props.modelValue) {
                    return [];
                }
                if (!Array.isArray(props.modelValue)) {
                    return [props.modelValue];
                }
                return props.modelValue.slice(0, props.limit);
            }),
            computedStyle: computed(() => props.color ? { color: getColor(props.color) } : {}),
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_ctx.messages.length)
    ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-message-list",
        style: normalizeStyle(_ctx.computedStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
          return (openBlock(), createElementBlock("div", {
            key: index,
            class: "va-message-list__message"
          }, toDisplayString(message), 1 /* TEXT */))
        }), 128 /* KEYED_FRAGMENT */))
      ], 4 /* STYLE */))
    : createCommentVNode("v-if", true)
}

script.render = render;
script.__file = "src/components/va-input/components/VaMessageList/VaMessageList.vue";

const VaMessageList = withConfigTransport(script);

export { VaMessageList as V, useValidationEmits as a, useValidation as b, useValidationProps as u };
//# sourceMappingURL=index67.js.map
