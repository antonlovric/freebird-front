import { computed, getCurrentInstance, shallowRef, onMounted, onUpdated, onBeforeUnmount, ref, watch, defineComponent, nextTick, openBlock, createElementBlock, mergeProps, toRefs, resolveComponent, createBlock, createSlots, withCtx, withModifiers, withKeys, createCommentVNode, renderSlot, normalizeProps, guardReactiveProps, renderList } from 'vue';
import { s as script$3, o as omit_1 } from './VaIcon.js';
import { e as pick_1 } from './usePopover.js';
import { e as extractComponentProps, f as filterComponentProps } from './child-props.js';
import './global-config.js';
import './global-utils.js';
import { a as useFocus } from './useFocus.js';
import 'colortranslator';
import { u as useEmitProxy } from './useEmitProxy.js';
import { u as useCaptureEvent } from './useCaptureEvent.js';
import { u as useFormProps } from './useForm.js';
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from './index67.js';
import Cleave from 'cleave.js';
import { s as script$2 } from './VaInputWrapper.js';

const useClearableProps = {
    clearable: { type: Boolean, default: false },
    clearableIcon: { type: String, default: 'highlight_off' },
    clearValue: { type: String, default: '' },
};
const useClearableEmits = ['clear'];
const useClearable = (props, inputValue, el, hasError) => {
    const { isFocused, onFocus, onBlur } = useFocus(el);
    const clearedValues = [null, undefined, props.clearValue];
    const canBeCleared = computed(() => (props.clearable &&
        !props.disabled &&
        !props.readonly &&
        !clearedValues.includes(inputValue.value)));
    const clearIconColor = computed(() => {
        if (isFocused === null || isFocused === void 0 ? void 0 : isFocused.value) {
            return props.color || 'primary';
        }
        if (hasError === null || hasError === void 0 ? void 0 : hasError.value) {
            return 'danger';
        }
        if (props.success) {
            return 'success';
        }
        return 'secondary';
    });
    const clearIconProps = computed(() => ({
        name: props.clearableIcon,
        color: clearIconColor.value,
        size: 'small',
    }));
    return {
        canBeCleared,
        clearIconColor,
        clearIconProps,
        onFocus,
        onBlur,
    };
};

/** Returns ref of current component instance element */
const useCurrentElement = (el) => {
    if (el) {
        return el;
    }
    const vm = getCurrentInstance();
    const currentEl = shallowRef();
    onMounted(() => { var _a; currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : undefined; });
    onUpdated(() => { var _a; currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : undefined; });
    onBeforeUnmount(() => { var _a; currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : undefined; });
    return currentEl;
};

const useActiveElement = () => {
    const activeEl = shallowRef();
    const updateActiveElement = () => {
        activeEl.value = document.activeElement;
    };
    onMounted(updateActiveElement);
    useCaptureEvent('focus', updateActiveElement);
    useCaptureEvent('blur', updateActiveElement);
    return activeEl;
};
const useFocusDeep = (el) => {
    const focused = useActiveElement();
    const current = useCurrentElement(el);
    // Cache previouslyFocusedElement, so we can simply come back to it
    let previouslyFocusedElement = null;
    return computed({
        get() {
            var _a;
            if (!focused.value) {
                return false;
            }
            if (focused.value === current.value) {
                return true;
            }
            const isFocused = (_a = current.value) === null || _a === void 0 ? void 0 : _a.contains(focused.value);
            if (isFocused) {
                previouslyFocusedElement = focused.value;
            }
            return isFocused;
        },
        set(value) {
            const target = previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : current.value;
            if (value) {
                target === null || target === void 0 ? void 0 : target.focus();
            }
            else {
                target === null || target === void 0 ? void 0 : target.blur();
            }
        },
    });
};

const DEFAULT_MASK_TOKENS = {
    creditCard: {
        creditCard: true,
    },
    date: {
        date: true,
        datePattern: ['d', 'm', 'Y'],
    },
    time: {
        time: true,
        timePattern: ['h', 'm'],
        timeFormat: '24',
    },
    numeral: {
        numeral: true,
        numeralThousandsGroupStyle: 'thousand',
    },
};
const useCleaveProps = {
    mask: { type: [String, Object], default: '' },
    returnRaw: { type: Boolean, default: true },
    modelValue: { type: String },
};
const useCleave = (element, props, emit) => {
    const cleave = ref();
    const getMask = (mask) => {
        if (typeof mask === 'string') {
            return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask] } : {};
        }
        return { ...mask };
    };
    const destroyCleave = () => {
        if (cleave.value) {
            cleave.value.destroy();
        }
    };
    const initCleave = () => {
        destroyCleave();
        if (!element.value) {
            return;
        }
        cleave.value = new Cleave(element.value, getMask(props.mask));
    };
    onMounted(() => { initCleave(); });
    onBeforeUnmount(() => { destroyCleave(); });
    watch(() => [element.value, props.mask], () => { initCleave(); });
    const computedValue = computed(() => {
        if (cleave.value) {
            if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
                return cleave.value.getFormattedValue();
            }
        }
        return props.modelValue;
    });
    const onInput = (event) => {
        const value = event.target.value;
        if (props.mask !== 'string' && !Object.keys(props.mask).length) {
            emit('update:modelValue', value);
            return;
        }
        if (cleave.value) {
            cleave.value.setRawValue(value);
            if (props.returnRaw) {
                emit('update:modelValue', cleave.value.getRawValue());
                return;
            }
        }
        emit('update:modelValue', value);
    };
    return {
        cleave,
        computedValue,
        onInput,
    };
};

const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important';
`;
const SIZING_STYLE = [
    'letter-spacing',
    'line-height',
    'padding-top',
    'padding-bottom',
    'font-family',
    'font-weight',
    'font-size',
    'text-rendering',
    'text-transform',
    'width',
    'text-indent',
    'padding-left',
    'padding-right',
    'border-width',
    'box-sizing',
];
const getNodeHeightStyles = (node) => {
    const style = window.getComputedStyle(node);
    return {
        boxSizing: style.getPropertyValue('box-sizing') ||
            style.getPropertyValue('-moz-box-sizing') ||
            style.getPropertyValue('-webkit-box-sizing'),
        padding: parseFloat(style.getPropertyValue('padding-bottom')) +
            parseFloat(style.getPropertyValue('padding-top')),
        border: parseFloat(style.getPropertyValue('border-bottom-width')) +
            parseFloat(style.getPropertyValue('border-top-width')),
        styles: SIZING_STYLE.map(name => `${name}:${style.getPropertyValue(name)}`).join(';') + ';',
        lineHeight: parseInt(style.getPropertyValue('line-height')),
    };
};
let textarea = null;
const createHiddenTextarea = (original, styles) => {
    if (!textarea) {
        textarea = document.createElement('textarea');
    }
    textarea.setAttribute('style', styles + HIDDEN_TEXTAREA_STYLE);
    textarea.value = original.value || original.placeholder || '';
    const wrap = original.getAttribute('wrap');
    if (wrap !== null) {
        textarea.setAttribute('wrap', wrap);
    }
    else {
        textarea.removeAttribute('wrap');
    }
    return textarea;
};
const useTextareaRowHeight = (textarea) => {
    const calculateRowHeight = () => {
        if (!textarea.value) {
            return 0;
        }
        return getNodeHeightStyles(textarea.value).lineHeight;
    };
    const calculateHeight = () => {
        if (!textarea.value) {
            return 0;
        }
        const { boxSizing, padding, border, styles } = getNodeHeightStyles(textarea.value);
        const hiddenTextarea = createHiddenTextarea(textarea.value, styles);
        document.body.appendChild(hiddenTextarea);
        let height = hiddenTextarea.scrollHeight;
        if (boxSizing === 'border-box') {
            height += border;
        }
        else if (boxSizing === 'content-box') {
            height -= padding;
        }
        document.body.removeChild(hiddenTextarea);
        return height;
    };
    return {
        calculateRowHeight,
        calculateHeight,
    };
};

const positiveNumberValidator = (val) => {
    if (val > 0 && (val | 0) === val) {
        return true;
    }
    throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
const { createEmits, createListeners } = useEmitProxy([
    'input', 'change', 'click', 'update:modelValue',
]);
var script$1 = defineComponent({
    name: 'VaTextarea',
    props: {
        ...useFormProps,
        modelValue: { type: [String, Number], default: '' },
        placeholder: { type: String },
        autosize: { type: Boolean, default: false },
        minRows: {
            type: Number,
            default: 1,
            validator: positiveNumberValidator,
        },
        maxRows: {
            type: Number,
            validator: positiveNumberValidator,
        },
    },
    emits: createEmits(),
    setup(props, { emit }) {
        const textarea = shallowRef();
        const rowHeight = ref(-1);
        const height = ref(-1);
        const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea);
        const isResizable = computed(() => {
            return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea.value);
        });
        const updateRowHeight = () => {
            if (isResizable.value) {
                rowHeight.value = calculateRowHeight();
            }
        };
        const updateHeight = () => {
            if (isResizable.value) {
                height.value = calculateHeight();
            }
        };
        onMounted(() => {
            updateRowHeight();
            updateHeight();
        });
        watch(() => props.modelValue, () => {
            nextTick(updateHeight);
        });
        const computedStyle = computed(() => ({
            minHeight: rowHeight.value * props.minRows + 'px',
            maxHeight: props.maxRows ? (rowHeight.value * props.maxRows + 'px') : undefined,
            height: height.value + 'px',
            resize: isResizable.value ? undefined : 'none',
        }));
        const computedProps = computed(() => ({
            ...pick_1(props, ['disabled', 'readonly', 'placeholder', 'ariaLabel']),
        }));
        const focus = () => {
            var _a;
            (_a = textarea.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const blur = () => {
            var _a;
            (_a = textarea.value) === null || _a === void 0 ? void 0 : _a.blur();
        };
        return {
            textarea,
            computedStyle,
            listeners: createListeners(emit),
            computedProps,
            focus,
            blur,
        };
    },
});

const _hoisted_1$1 = ["value"];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, { ..._ctx.computedProps, ..._ctx.listeners }, { value: _ctx.modelValue }), null, 16 /* FULL_PROPS */, _hoisted_1$1))
}

script$1.render = render$1;
script$1.__file = "src/components/va-input/components/VaTextarea/VaTextarea.vue";

const VaTextareaProps = extractComponentProps(script$1);
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(['change', 'keyup', 'keypress', 'keydown', 'focus', 'blur']);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
    'click',
    'click-prepend',
    'click-append',
    'click-prepend-inner',
    'click-append-inner',
]);
var script = defineComponent({
    name: 'VaInput',
    components: { VaInputWrapper: script$2, VaTextarea: script$1, VaIcon: script$3 },
    props: {
        ...useFormProps,
        ...useValidationProps,
        ...useClearableProps,
        ...useCleaveProps,
        ...VaTextareaProps,
        // input
        placeholder: { type: String, default: '' },
        tabindex: { type: Number, default: 0 },
        modelValue: { type: [String, Number], default: '' },
        label: { type: String, default: '' },
        type: { type: String, default: 'text' },
        loading: { type: Boolean, default: false },
        inputClass: { type: String, default: '' },
        pattern: { type: String },
        inputmode: { type: String, default: 'text' },
        ariaLabel: { type: String, default: undefined },
        counter: { type: Boolean, default: false },
        maxLength: { type: Number, default: undefined },
        // style
        color: { type: String, default: 'primary' },
        outline: { type: Boolean, default: false },
        bordered: { type: Boolean, default: false },
        requiredMark: { type: Boolean, default: false },
    },
    emits: [
        'update:modelValue',
        ...useValidationEmits,
        ...useClearableEmits,
        ...createInputEmits(),
        ...createFieldEmits(),
    ],
    inheritAttrs: false,
    setup(props, { emit, attrs, slots }) {
        const input = shallowRef();
        const isFocused = useFocusDeep();
        const reset = () => {
            emit('update:modelValue', props.clearValue);
            emit('clear');
        };
        const focus = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const blur = () => {
            var _a;
            (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
        };
        const filterSlots = computed(() => {
            const iconSlot = ['icon'];
            return Object.keys(slots).filter(slot => !iconSlot.includes(slot));
        });
        const { computedError, computedErrorMessages, listeners: validationListeners, } = useValidation(props, emit, reset, focus);
        const { modelValue } = toRefs(props);
        const { canBeCleared, clearIconProps, } = useClearable(props, modelValue, input, computedError);
        /** Use cleave only if this component is input, because it will break. */
        const computedCleaveTarget = computed(() => props.type === 'textarea'
            ? undefined
            : input.value);
        const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
        const inputListeners = createInputListeners(emit);
        /** Combine EmitProxy events with validation events to avoid events overriding */
        const onFocus = (e) => {
            inputListeners.onFocus(e);
            validationListeners.onFocus();
        };
        const onBlur = (e) => {
            inputListeners.onBlur(e);
            validationListeners.onBlur();
        };
        const inputEvents = {
            ...inputListeners,
            onFocus,
            onBlur,
            onInput,
        };
        const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
        const computedChildAttributes = computed(() => ({
            ariaLabel: props.ariaLabel || props.label,
            ariaRequired: props.requiredMark,
            ariaDisabled: props.disabled,
            ariaReadOnly: props.readonly,
            'aria-invalid': !!computedErrorMessages.value.length,
            'aria-errormessage': typeof computedErrorMessages.value === 'string'
                ? computedErrorMessages.value
                : computedErrorMessages.value.join(', '),
            tabindex: tabIndexComputed.value,
            class: props.inputClass,
            ...omit_1(attrs, ['class', 'style']),
        }));
        const computedInputAttributes = computed(() => ({
            ...computedChildAttributes.value,
            ...pick_1(props, ['type', 'disabled', 'readonly', 'placeholder', 'pattern', 'inputmode']),
        }));
        const valueLengthComputed = computed(() => props.counter && typeof computedValue.value === 'string' ? computedValue.value.length : undefined);
        return {
            input,
            inputEvents,
            valueLengthComputed,
            computedChildAttributes,
            computedInputAttributes,
            textareaProps: filterComponentProps(props, VaTextareaProps),
            computedValue,
            tabIndexComputed,
            // Validations
            computedError,
            computedErrorMessages,
            isFocused,
            // Icon
            canBeCleared,
            clearIconProps,
            fieldListeners: createFieldListeners(emit),
            filterSlots,
            reset,
            focus,
            blur,
        };
    },
});

const _hoisted_1 = ["value"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_VaInputWrapper = resolveComponent("VaInputWrapper");

  return (openBlock(), createBlock(_component_VaInputWrapper, mergeProps(_ctx.fieldListeners, {
    class: _ctx.$attrs.class,
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      (_ctx.canBeCleared)
        ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-hidden": "false",
            "aria-label": "reset",
            class: "va-input__icons__reset",
            tabindex: _ctx.tabIndexComputed
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16 /* FULL_PROPS */, ["tabindex", "onClick", "onKeydown"]))
        : createCommentVNode("v-if", true),
      (_ctx.$props.loading)
        ? (openBlock(), createBlock(_component_va_icon, {
            key: 1,
            color: _ctx.$props.color,
            size: "small",
            name: "loop",
            spin: "counter-clockwise"
          }, null, 8 /* PROPS */, ["color"]))
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      (_ctx.type === 'textarea' && !_ctx.$slots.content)
        ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
            key: 0,
            ref: "input"
          }, { ..._ctx.computedChildAttributes, ..._ctx.textareaProps, ..._ctx.inputEvents }, { class: "va-input__content__input" }), null, 16 /* FULL_PROPS */))
        : (!_ctx.$slots.content)
          ? (openBlock(), createElementBlock("input", mergeProps({
              key: 1,
              ref: "input",
              class: "va-input__content__input"
            }, { ..._ctx.computedInputAttributes, ..._ctx.inputEvents }, { value: _ctx.computedValue }), null, 16 /* FULL_PROPS */, _hoisted_1))
          : createCommentVNode("v-if", true)
    ]),
    _: 2 /* DYNAMIC */
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name: name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      }
    })
  ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["class", "style", "color", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]))
}

script.render = render;
script.__file = "src/components/va-input/VaInput.vue";

export { useClearable as a, useClearableProps as b, useFocusDeep as c, script as s, useClearableEmits as u };
//# sourceMappingURL=VaInput.js.map
