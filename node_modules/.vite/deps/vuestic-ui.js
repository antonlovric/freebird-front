import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toHandlers,
  toRef,
  toRefs,
  unref,
  vModelText,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-I6H2WNS7.js";

// node_modules/vuestic-ui/dist/esm/global-properties.js
var extractGlobalProperties = (app) => app.config.globalProperties;
var defineGlobalProperty = (app, key2, v2) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key2] = v2;
};
var getGlobalProperty = (app, key2) => {
  return extractGlobalProperties(app)[key2];
};

// node_modules/vuestic-ui/dist/esm/global-config.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data = this.__data__, index = assocIndexOf$3(data, key2);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data = this.__data__, index = assocIndexOf$2(data, key2);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value) {
  var data = this.__data__, index = assocIndexOf(data, key2);
  if (index < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$4 = root$7.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$8(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$8;
var baseGetTag$4 = _baseGetTag;
var isObject$7 = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$6 = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$6(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key2) {
  return object == null ? void 0 : object[key2];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$5 = _root;
var Map$3 = getNative$6(root$5, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key2) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key2];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key2) ? data[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$7.call(data, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key2) {
  var data = map.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result = getMapData$3(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
function assignMergeValue$2(object, key2, value) {
  if (value !== void 0 && !eq$2(object[key2], value) || value === void 0 && !(key2 in object)) {
    baseAssignValue$2(object, key2, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key2 = props[fromRight ? length : ++index];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root3 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root3.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root$4 = _root;
var Uint8Array$1 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
var isObject$5 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$5(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var getPrototype$3 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var objectProto$8 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
var _isPrototype = isPrototype$3;
var baseCreate = _baseCreate;
var getPrototype$2 = _getPrototype;
var isPrototype$2 = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$2(object) ? baseCreate(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$2;
function isObjectLike$7(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$7;
var baseGetTag$3 = _baseGetTag;
var isObjectLike$6 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$6(value) && baseGetTag$3(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$5 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$5(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isArray$4 = Array.isArray;
var isArray_1 = isArray$4;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction$1 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var isArrayLike$3 = isArrayLike_1;
var isObjectLike$4 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$4(value) && isArrayLike$3(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root3 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root3.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var baseGetTag$2 = _baseGetTag;
var getPrototype$1 = _getPrototype;
var isObjectLike$3 = isObjectLike_1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
var baseGetTag$1 = _baseGetTag;
var isLength = isLength_1;
var isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$2 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$2 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil3 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil3;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
function safeGet$2(object, key2) {
  if (key2 === "constructor" && typeof object[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object[key2];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue;
var eq$1 = eq_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function assignValue$2(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$4.call(object, key2) && eq$1(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue$1(object, key2, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue;
var baseAssignValue = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key2 = props[index];
    var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object, key2, newValue);
    } else {
      assignValue$1(object, key2, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$2;
var baseTimes = _baseTimes;
var isArguments$1 = isArguments_1;
var isArray$3 = isArray_1;
var isBuffer$2 = isBuffer$3.exports;
var isIndex$1 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$3(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$3.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex$1(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key2 in Object(object)) {
      result.push(key2);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$4 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$4(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key2 in object) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$2.call(object, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject;
var keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$4(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer$1 = _cloneBuffer.exports;
var cloneTypedArray$1 = _cloneTypedArray;
var copyArray$1 = _copyArray;
var initCloneObject$1 = _initCloneObject;
var isArguments = isArguments_1;
var isArray$2 = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer$1 = isBuffer$3.exports;
var isFunction = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key2), srcValue = safeGet$1(source, key2), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$2(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$2(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key2, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$1 = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn$3 = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key2) {
    stack || (stack = new Stack$1());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key2, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key2, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike$1 = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike$1(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$1.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike = isArrayLike_1;
function keys$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$3 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$3(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
var copyObject$2 = _copyObject;
var keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$2(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$1 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$1(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush;
var getPrototype = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$1(object));
    object = getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush = _arrayPush;
var isArray$1 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$1 = keysIn_1;
function getAllKeysIn$1(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var getNative$3 = _getNative;
var root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$1 = _root;
var Set$1 = getNative$1(root$1, "Set");
var _Set = Set$1;
var getNative = _getNative;
var root = _root;
var WeakMap$1 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map2 = _Map;
var Promise$1 = _Promise;
var Set2 = _Set;
var WeakMap2 = _WeakMap;
var baseGetTag = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap2);
var getTag$3 = baseGetTag;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map2 && getTag$3(new Map2()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set2 && getTag$3(new Set2()) != setTag$3 || WeakMap2 && getTag$3(new WeakMap2()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag;
var isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack;
var arrayEach = _arrayEach;
var assignValue = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer = _cloneBuffer.exports;
var copyArray = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject = _initCloneObject;
var isArray = isArray_1;
var isBuffer = isBuffer$3.exports;
var isMap = isMap_1;
var isObject = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key2, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key2, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key3) {
      result.set(key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result, key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1;
var CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
var getComponentsDefaultConfig = () => ({
  VaIcon: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  VaRating: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  }
});
var getComponentsAllDefaultConfig = () => ({});
var VuesticIconFonts = [
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];
var VuesticIconAliases = [
  {
    name: "arrow_back_ios",
    to: "arrow_back_ios"
  },
  {
    name: "arrow_forward_ios",
    to: "arrow_forward_ios"
  },
  {
    name: "first_page",
    to: "first_page"
  },
  {
    name: "last_page",
    to: "last_page"
  },
  {
    name: "chevron_right",
    to: "chevron_right"
  },
  {
    name: "chevron_left",
    to: "chevron_left"
  },
  {
    name: "expand_more",
    to: "expand_more"
  },
  {
    name: "expand_less",
    to: "expand_less"
  },
  {
    name: "arrow_drop_down",
    to: "arrow_drop_down"
  },
  {
    name: "arrow_drop_up",
    to: "arrow_drop_up"
  },
  {
    name: "calendar_today",
    to: "calendar_today"
  },
  {
    name: "delete_outline",
    to: "delete_outline"
  },
  {
    name: "clear",
    to: "clear"
  },
  {
    name: "check",
    to: "check"
  },
  {
    name: "warning",
    to: "warning"
  },
  {
    name: "highlight_off",
    to: "highlight_off"
  },
  {
    name: "close",
    to: "close"
  },
  {
    name: "done",
    to: "done"
  },
  {
    name: "cancel",
    to: "cancel"
  },
  {
    name: "loop",
    to: "loop"
  }
];
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};
var colorsPresets = {
  default: {
    primary: "#2C82E0",
    secondary: "#767C88",
    background: "#f4f8fa",
    success: "#40e583",
    info: "#2c82e0",
    danger: "#DE1041",
    warning: "#FFAC0A",
    gray: "#babfc2",
    dark: "#1B1A1F",
    divider: "#E1E9F8",
    white: "#ffffff",
    black: "#000000",
    focus: "#ffc700"
  }
};
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var createGlobalConfig = () => {
  const globalConfig = ref({
    colors: colorsPresets.default,
    icons: createIconsConfig({}),
    components: getComponentsDefaultConfig(),
    componentsAll: getComponentsAllDefaultConfig()
  });
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep_1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = merge_1(cloneDeep_1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
function useGlobalConfigSafe() {
  return inject(GLOBAL_CONFIG);
}
function useGlobalConfig() {
  const injected = inject(GLOBAL_CONFIG);
  if (!injected) {
    const vm = getCurrentInstance();
    if (!vm) {
      throw new Error("useGlobalConfig must be called in setup function");
    }
    const config = getGlobalProperty(vm.appContext, "$vaConfig");
    if (!config) {
      throw new Error("Vuestic GlobalConfigPlugin is not registered");
    }
    return config;
  }
  return injected;
}

// node_modules/vuestic-ui/dist/esm/isSymbol.js
var baseGetTag2 = _baseGetTag;
var isObjectLike2 = isObjectLike_1;
var symbolTag2 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
}
var isSymbol_1 = isSymbol;

// node_modules/vuestic-ui/dist/esm/ssr-utils.js
var isServer = () => typeof window === "undefined";
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/esm/usePopover.js
function arrayMap$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$12 = _Symbol;
var arrayMap = _arrayMap;
var isArray$42 = isArray_1;
var isSymbol$2 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto2 = Symbol$12 ? Symbol$12.prototype : void 0;
var symbolToString = symbolProto2 ? symbolProto2.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$42(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var useClientOnly = (cb) => {
  if (isServer()) {
    const result = ref(null);
    onMounted(() => {
      result.value = cb();
    });
    return result;
  }
  return ref(cb());
};
var useRequestAnimationFrame = (cb) => {
  let animationFrameRequest = -1;
  const observe = () => {
    animationFrameRequest = requestAnimationFrame(observe);
    cb();
  };
  onMounted(() => {
    observe();
  });
  onBeforeUnmount(() => {
    cancelAnimationFrame(animationFrameRequest);
  });
};
var keys2 = ["x", "y", "width", "height", "top", "left", "right", "bottom"];
var isDomRectEqual = (a2, b2) => {
  for (let i2 = 0; i2 < keys2.length; i2++) {
    if (a2[keys2[i2]] !== b2[keys2[i2]]) {
      return false;
    }
  }
  return true;
};
var useDomRect = (target) => {
  const domRect = ref(null);
  let prev = {};
  useRequestAnimationFrame(() => {
    if (!target.value) {
      return;
    }
    const rect = target.value.getBoundingClientRect();
    if (!isDomRectEqual(rect, prev)) {
      domRect.value = rect;
    }
    prev = rect;
  });
  watch(target, (newVal) => {
    if (newVal) {
      domRect.value = newVal.getBoundingClientRect();
    } else {
      domRect.value = null;
    }
  });
  return {
    domRect
  };
};
var isArray$32 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$32(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache2 = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache2)();
  return memoized;
}
memoize$1.Cache = MapCache2;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$22 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString = toString_1;
function castPath$4(value, object) {
  if (isArray$22(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var _castPath = castPath$4;
var isSymbol2 = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$3(value) {
  if (typeof value == "string" || isSymbol2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$3;
var castPath$3 = _castPath;
var toKey$2 = _toKey;
function baseGet$1(object, path) {
  path = castPath$3(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$2(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$1;
var assignValue2 = _assignValue;
var castPath$2 = _castPath;
var isIndex$12 = _isIndex;
var isObject2 = isObject_1;
var toKey$1 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject2(object)) {
    return object;
  }
  path = castPath$2(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key2 = toKey$1(path[index]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject2(objValue) ? objValue : isIndex$12(path[index + 1]) ? [] : {};
      }
    }
    assignValue2(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet;
var baseSet = _baseSet;
var castPath$1 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$1(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key2) {
  return object != null && key2 in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath = _castPath;
var isArguments$12 = isArguments_1;
var isArray$12 = isArray_1;
var isIndex2 = _isIndex;
var isLength2 = isLength_1;
var toKey = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key2 = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength2(length) && isIndex2(key2, length) && (isArray$12(object) || isArguments$12(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol2 = _Symbol;
var isArguments2 = isArguments_1;
var isArray2 = isArray_1;
var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush2 = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush2(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten = flatten_1;
var overRest2 = _overRest;
var setToString2 = _setToString;
function flatRest$1(func) {
  return setToString2(overRest2(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$1;
var basePick = _basePick;
var flatRest = _flatRest;
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var mapObject = (o2, cb) => {
  const copy = {};
  Object.keys(o2).forEach((key2) => {
    copy[key2] = cb(o2[key2], key2);
  });
  return copy;
};
var placementsPositions = ["top", "bottom", "left", "right"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ["auto"]);
var coordsToCss = ({ x: x2, y: y2 }) => ({ left: `${x2}px`, top: `${y2}px` });
var parsePlacement = (placement) => {
  const [position, align] = placement.split("-");
  return { position, align: align || "center" };
};
var parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
var calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
var calculateContentCoords = (placement, anchor, content) => {
  const { position, align } = parsePlacement(placement);
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
var calculateOffsetCoords = (placement, offset) => {
  const { position } = parsePlacement(placement);
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
var calculateContentOverflow = (coords, content, root3) => {
  const xMax = root3.right;
  const yMax = root3.bottom;
  const xMin = root3.left;
  const yMin = root3.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
var clamp = (min, v2, max) => Math.max(Math.min(v2, max), min);
var calculateClipToEdge = (coords, offsetCoords, content, anchor, root3) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, root3);
  const x2 = coords.x - right + left;
  const y2 = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp(anchor.left + offsetX - content.width, x2, anchor.right + offsetX),
    y: clamp(anchor.top + offsetY - content.height, y2, anchor.bottom + offsetY)
  };
};
var getAutoPlacement = (placement, coords, content, root3) => {
  const { position, align } = parsePlacement(placement);
  const overflow = calculateContentOverflow(coords, content, root3);
  const newPlacements = {
    top: ["bottom", align].join("-"),
    bottom: ["top", align].join("-"),
    right: ["left", align].join("-"),
    left: ["right", align].join("-")
  };
  return overflow[position] ? newPlacements[position] : placement;
};
var usePopover = (anchorRef, contentRef, options) => {
  const documentRef = useClientOnly(() => document);
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root: root3 } = unref(options);
    if (root3) {
      return documentRef.value.querySelector(root3);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  const updateContentCSS = () => {
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    let offsetCoords = { x: 0, y: 0 };
    const { placement, keepAnchorWidth, offset, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
    if (offset) {
      offsetCoords = calculateOffsetCoords(placement, offset);
      coords = mapObject(coords, (c2, key2) => c2 + offsetCoords[key2]);
    }
    if (keepAnchorWidth) {
      const { width } = anchorDomRect.value;
      Object.assign(css, { width: `${width}px`, maxWidth: `${width}px` });
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    if (autoPlacement) {
      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, rootRect);
      if (newPlacement !== placement) {
        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPlacement, offset);
          coords = mapObject(coords, (c2, key2) => c2 + offsetCoords[key2]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, rootRect);
    }
    if (contentRef.value) {
      Object.assign(contentRef.value.style, {
        ...css,
        ...coordsToCss(coords)
      });
    }
  };
  watch(anchorDomRect, updateContentCSS);
  watch(contentDomRect, updateContentCSS);
  watch(options, updateContentCSS, { deep: true });
  return {
    anchorDomRect,
    contentDomRect
  };
};

// node_modules/vuestic-ui/dist/esm/global-utils.js
var __DEV__ = true;

// node_modules/colortranslator/dist/esm/index.js
var t;
var e;
var r;
var n;
var i = function() {
  return i = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var i2 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
    return t2;
  }, i.apply(this, arguments);
};
function o(t2, e2, r2) {
  if (r2 || 2 === arguments.length)
    for (var n2, i2 = 0, o2 = e2.length; i2 < o2; i2++)
      !n2 && i2 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, i2)), n2[i2] = e2[i2]);
  return t2.concat(n2 || Array.prototype.slice.call(e2));
}
!function(t2) {
  t2.HEX = "HEX", t2.RGB = "RGB", t2.RGBA = "RGBA", t2.HSL = "HSL", t2.HSLA = "HSLA", t2.CMYK = "CMYK";
}(t || (t = {})), function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(e || (e = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(r || (r = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(n || (n = {}));
var u;
var a;
var s;
var c;
var d;
var f;
var h2;
var l = Object.keys(n);
var p = ((u = {})[t.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, u[t.RGB] = /^rgb\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*\)$/, u[t.RGBA] = /^rgba\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*,\s*(\d\.?\d*)\s*\)$/, u[t.HSL] = /^hsl\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%s*\)$/, u[t.HSLA] = /^hsla\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%\s*,\s*(\d\.?\d*)\s*\)$/, u[t.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)|(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*))\s*\)$/, u);
var g = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var b = /^0x([a-f\d]{1,2})$/i;
var F = "The provided string color doesn't have a correct format";
var A = "The provided color object doesn't have the proper keys or format";
var m = function(t2, e2, r2) {
  return r2 < 0 && (r2 += 6), r2 >= 6 && (r2 -= 6), r2 < 1 ? Math.round(255 * ((e2 - t2) * r2 + t2)) : r2 < 3 ? Math.round(255 * e2) : r2 < 4 ? Math.round(255 * ((e2 - t2) * (4 - r2) + t2)) : Math.round(255 * t2);
};
var y = function(t2, e2, r2) {
  e2 /= 100;
  var n2 = (r2 /= 100) <= 0.5 ? r2 * (e2 + 1) : r2 + e2 - r2 * e2, i2 = 2 * r2 - n2;
  return { r: m(i2, n2, (t2 /= 60) + 2), g: m(i2, n2, t2), b: m(i2, n2, t2 - 2) };
};
var E = function(t2, e2, r2, n2) {
  return n2 = 1 - n2, { r: Math.round(255 * (1 - t2) * n2), g: Math.round(255 * (1 - e2) * n2), b: Math.round(255 * (1 - r2) * n2) };
};
var H = function(t2, e2, r2) {
  t2 /= 255, e2 /= 255, r2 /= 255;
  var n2 = 1 - Math.max(t2, e2, r2), i2 = 1 - n2, o2 = (i2 - t2) / i2, u2 = (i2 - e2) / i2, a2 = (i2 - r2) / i2;
  return { c: Math.round(100 * o2), m: Math.round(100 * u2), y: Math.round(100 * a2), k: Math.round(100 * n2) };
};
var B = function(t2, e2, r2, n2) {
  void 0 === n2 && (n2 = 1), t2 /= 255, e2 /= 255, r2 /= 255, n2 = Math.min(n2, 1);
  var i2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), u2 = i2 - o2, a2 = 0, s2 = 0, c2 = (i2 + o2) / 2;
  if (0 === u2)
    a2 = 0, s2 = 0;
  else {
    switch (i2) {
      case t2:
        a2 = (e2 - r2) / u2 % 6;
        break;
      case e2:
        a2 = (r2 - t2) / u2 + 2;
        break;
      case r2:
        a2 = (t2 - e2) / u2 + 4;
    }
    (a2 = Math.round(60 * a2)) < 0 && (a2 += 360), s2 = u2 / (1 - Math.abs(2 * c2 - 1));
  }
  return { h: a2, s: Math.round(100 * s2), l: Math.round(100 * c2), a: n2 };
};
var v = function(t2, e2) {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), 360 === t2 || 0 === t2)
    return t2;
  var r2 = [[0, 120], [120, 180], [180, 240], [240, 360]], n2 = [[0, 60], [60, 120], [120, 240], [240, 360]], i2 = e2 ? n2 : r2, o2 = 0, u2 = 0, a2 = 0, s2 = 0;
  return (e2 ? r2 : n2).find(function(e3, r3) {
    return t2 >= e3[0] && t2 < e3[1] && (o2 = e3[0], u2 = e3[1], a2 = i2[r3][0], s2 = i2[r3][1], true);
  }), a2 + (s2 - a2) / (u2 - o2) * (t2 - o2);
};
var M = function(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
};
var R = function(t2) {
  return g.test("" + t2) ? +("" + t2).replace(g, "$1") : Math.min(+t2, 100);
};
var S = function(t2) {
  return 1 === t2.length && (t2 += t2), parseInt(t2, 16);
};
var C = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return 1 === e2.length ? "0x0" + e2 : "0x" + e2;
};
var L = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return 1 === e2.length && (e2 = "0" + e2), e2;
};
var D = function(t2, e2) {
  return void 0 === e2 && (e2 = false), !e2 && g.test(t2) ? Math.min(255 * +t2.replace(g, "$1") / 100, 255) : b.test(t2) ? 3 === t2.length ? e2 ? parseInt(t2 + t2.slice(-1)) / 255 : parseInt(t2 + t2.slice(-1)) : e2 ? parseInt(t2) / 255 : parseInt(t2) : Math.min(+t2, e2 ? 1 : 255);
};
var G = function(t2) {
  return Math.min(g.test(t2) ? +t2.replace(g, "$1") / 100 : +t2, 1);
};
var k = function(t2) {
  return t2.sort().join().toUpperCase();
};
var O = function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var r2 = Math.pow(10, e2);
  return Math.round(+t2 * r2) / r2;
};
var X = function(t2, e2, r2) {
  return Math.max(e2, Math.min(t2, r2));
};
var I = ((a = {})[t.HEX] = function(t2) {
  return "#" + L(t2.r) + L(t2.g) + L(t2.b) + (M(t2, "a") && L(t2.a) || "");
}, a[t.RGB] = function(t2) {
  return "rgb" + (M(t2, "a") ? "a" : "") + "(" + O(t2.r) + "," + O(t2.g) + "," + O(t2.b) + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.HSL] = function(t2) {
  return "hsl" + (M(t2, "a") ? "a" : "") + "(" + O(t2.h) + "," + O(t2.s) + "%," + O(t2.l) + "%" + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.CMYK] = function(t2) {
  return "cmyk(" + O(t2.c) + "%," + O(t2.m) + "%," + O(t2.y) + "%," + O(t2.k) + "%)";
}, a);
var j = function(t2) {
  return (t2 > 360 || t2 < 0) && (t2 -= 360 * Math.floor(t2 / 360)), t2;
};
var T = function(t2) {
  return isNaN(+t2) || t2 > 1 ? 1 : O(t2, 2);
};
var Y = function(t2, e2, n2) {
  return e2.reduce(function(e3, u2) {
    return o(o([], e3, true), [i(i({}, t2), { h: n2 === r.ADDITIVE ? j(t2.h + u2) : j(v(v(t2.h, false) + u2, true)) })], false);
  }, [i({}, t2)]);
};
var P = function(t2, e2) {
  return Y(t2, [30, -30], e2);
};
var w = function(t2, e2) {
  return Y(t2, [180], e2);
};
var K = function(t2, e2) {
  return Y(t2, [150, -150], e2);
};
var x = function(t2, e2) {
  return Y(t2, [120, -120], e2);
};
var N = function(t2, e2) {
  return Y(t2, [60, -120, 180], e2);
};
var V = function(t2, e2) {
  return Y(t2, [90, -90, 180], e2);
};
var U = function(e2) {
  return "string" == typeof e2 ? function(e3) {
    var r2;
    if (Object.keys(t).some(function(t2) {
      if (p[t2].test(e3))
        return r2 = t2, true;
    }), !r2 && ~l.indexOf(e3) && (r2 = t.HEX), !r2)
      throw new Error(F);
    return r2;
  }(e2) : function(e3) {
    var r2, n2 = false, i2 = k(Object.keys(e3));
    if (Object.keys(t).filter(function(e4) {
      return e4 !== t.HEX;
    }).some(function(t2) {
      if (k(t2.split("")) === i2)
        return r2 = t2, true;
    }), r2 && r2 === t.RGB || r2 === t.RGBA) {
      var o2 = Object.entries(e3).map(function(t2) {
        return b.test("" + t2[1]);
      }), u2 = Object.entries(e3).map(function(t2) {
        return g.test("" + t2[1]) || !b.test("" + t2[1]) && !isNaN(+t2[1]) && +t2[1] <= 255;
      }), a2 = o2.some(function(t2, e4) {
        return e4 > 0 && t2 !== o2[e4 - 1];
      }), s2 = u2.some(function(t2, e4) {
        return e4 > 0 && t2 !== u2[e4 - 1];
      });
      !(n2 = a2 || s2 || !o2[0] && !u2[0]) && o2[0] && (r2 = t.HEX);
    }
    if (!r2 || n2)
      throw new Error(A);
    return r2;
  }(e2);
};
var $ = ((s = {})[t.HEX] = function(t2) {
  var e2 = (~l.indexOf(t2) ? n[t2] : t2).match(p.HEX), r2 = { r: S(e2[1] || e2[5]), g: S(e2[2] || e2[6]), b: S(e2[3] || e2[7]) }, i2 = e2[4] || e2[8];
  return void 0 !== i2 && (r2.a = S(i2) / 255), r2;
}, s[t.RGB] = function(t2) {
  var e2 = t2.match(p.RGB), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]);
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255) };
}, s[t.RGBA] = function(t2) {
  var e2 = t2.match(p.RGBA), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]), o2 = +e2[7];
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255), a: T(o2) };
}, s[t.HSL] = function(t2) {
  var e2 = t2.match(p.HSL), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]);
  return y(r2, n2, i2);
}, s[t.HSLA] = function(t2) {
  var e2 = t2.match(p.HSLA), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]), o2 = +e2[4], u2 = y(r2, n2, i2);
  return u2.a = T(o2), u2;
}, s[t.CMYK] = function(t2) {
  var e2 = t2.match(p.CMYK), r2 = G(e2[1] || e2[5]), n2 = G(e2[2] || e2[6]), i2 = G(e2[3] || e2[7]), o2 = G(e2[4] || e2[8]);
  return E(r2, n2, i2, o2);
}, s);
var q = ((c = {})[t.HEX] = function(t2) {
  var e2 = { r: D("" + t2.r), g: D("" + t2.g), b: D("" + t2.b) };
  return e2.a = M(t2, "a") ? Math.min(D("" + t2.a, true), 1) : 1, e2;
}, c[t.RGB] = function(t2) {
  var e2 = this.HEX(t2);
  return delete e2.a, e2;
}, c[t.RGBA] = function(t2) {
  return this.HEX(t2);
}, c[t.HSL] = function(t2) {
  var e2 = R("" + t2.s), r2 = R("" + t2.l);
  return y(j(t2.h), e2, r2);
}, c[t.HSLA] = function(t2) {
  var e2 = this.HSL(t2);
  return e2.a = T(t2.a), e2;
}, c[t.CMYK] = function(t2) {
  var e2 = G("" + t2.c), r2 = G("" + t2.m), n2 = G("" + t2.y), i2 = G("" + t2.k);
  return E(e2, r2, n2, i2);
}, c);
var Q = function(t2, e2) {
  return void 0 === e2 && (e2 = U(t2)), "string" == typeof t2 ? $[e2](t2) : q[e2](t2);
};
var _ = ((d = {})[t.HEX] = function(t2) {
  return { r: C(t2.r), g: C(t2.g), b: C(t2.b) };
}, d.HEXA = function(t2) {
  var e2 = _.HEX(t2);
  return e2.a = M(t2, "a") ? C(255 * t2.a) : "0xFF", e2;
}, d[t.RGB] = function(t2) {
  return M(t2, "a") && delete t2.a, t2;
}, d[t.RGBA] = function(t2) {
  return t2.a = M(t2, "a") ? O(t2.a, 2) : 1, t2;
}, d[t.HSL] = function(t2) {
  var e2 = B(t2.r, t2.g, t2.b);
  return delete e2.a, e2;
}, d[t.HSLA] = function(t2) {
  var e2 = _.HSL(t2);
  return e2.a = M(t2, "a") ? O(t2.a, 2) : 1, e2;
}, d[t.CMYK] = function(t2) {
  return H(t2.r, t2.g, t2.b);
}, d);
var z = function(e2, r2, n2) {
  var o2 = U(e2), u2 = "string" == typeof e2, a2 = Q(e2, o2), s2 = "string" == typeof e2 && M(a2, "a") || "string" != typeof e2 && M(e2, "a"), c2 = B(a2.r, a2.g, a2.b, a2.a);
  s2 || delete c2.a;
  var d2 = n2 ? c2.l / (r2 + 1) : (100 - c2.l) / (r2 + 1), f2 = Array(r2).fill(null).map(function(t2, e3) {
    return i(i({}, c2), { l: c2.l + d2 * (e3 + 1) * (1 - 2 * +n2) });
  });
  switch (o2) {
    case t.HEX:
    default:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? s2 ? I.HEX(i(i({}, e3), { a: O(255 * e3.a, 2) })) : I.HEX(e3) : s2 ? _.HEXA(e3) : _.HEX(e3);
      });
    case t.RGB:
    case t.RGBA:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? I.RGB(e3) : s2 ? _.RGBA(e3) : _.RGB(e3);
      });
    case t.HSL:
    case t.HSLA:
      return f2.map(function(t2) {
        return u2 ? I.HSL(t2) : s2 ? _.HSLA(i(i({}, y(t2.h, t2.s, t2.l)), { a: t2.a })) : _.HSL(y(t2.h, t2.s, t2.l));
      });
  }
};
var J = ((f = { buildHarmony: function(e2, r2, n2) {
  var i2 = U(e2), o2 = Q(e2, i2), u2 = B(o2.r, o2.g, o2.b, o2.a), a2 = "string" == typeof e2 && M(o2, "a") || "string" != typeof e2 && M(e2, "a"), s2 = "string" == typeof e2;
  switch (i2) {
    case t.HEX:
    default:
      return a2 ? this.HEXA(u2, r2, n2, s2) : this.HEX(u2, r2, n2, s2);
    case t.HSL:
      return this.HSL(u2, r2, n2, s2);
    case t.HSLA:
      return this.HSLA(u2, r2, n2, s2);
    case t.RGB:
      return this.RGB(u2, r2, n2, s2);
    case t.RGBA:
      return this.RGBA(u2, r2, n2, s2);
  }
} })[t.HEX] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(y(t3.h, t3.s, t3.l)) : _.HEX(y(t3.h, t3.s, t3.l));
  });
}, f.HEXA = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(i(i({}, y(t3.h, t3.s, t3.l)), { a: 255 * T(t3.a) })) : _.HEXA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.RGB] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(y(t3.h, t3.s, t3.l)) : _.RGB(y(t3.h, t3.s, t3.l));
  });
}, f[t.RGBA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) })) : _.RGBA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.HSL] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL({ h: t3.h, s: t3.s, l: t3.l }) : _.HSL(y(t3.h, t3.s, t3.l));
  });
}, f[t.HSLA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL(i(i({}, t3), { a: T(t3.a) })) : _.HSLA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f);
var W = ((h2 = { mix: function(t2, e2) {
  var n2, o2, u2, a2, s2, c2, d2, f2, h3, l2, p2, g2, b2, F2, A2, m2 = t2.map(function(t3) {
    var e3 = U(t3);
    return Q(t3, e3);
  }), y2 = e2 === r.SUBTRACTIVE ? m2.map(function(t3) {
    var e3, r2, n3, i2, o3, u3, a3, s3, c3, d3, f3, h4, l3, p3, g3 = (e3 = t3.r, r2 = t3.g, n3 = t3.b, i2 = Math.min(e3, r2, n3), o3 = Math.min(255 - e3, 255 - r2, 255 - n3), u3 = e3 - i2, a3 = r2 - i2, s3 = n3 - i2, c3 = Math.min(u3, a3), d3 = u3 - c3, f3 = (a3 + c3) / 2, h4 = (s3 + a3 - c3) / 2, l3 = Math.max(d3, f3, h4) / Math.max(u3, a3, s3), p3 = isNaN(l3) || l3 === 1 / 0 || l3 <= 0 ? 1 : l3, { r: d3 / p3 + o3, y: f3 / p3 + o3, b: h4 / p3 + o3 });
    return M(t3, "a") && (g3.a = t3.a), g3;
  }) : null;
  function E2(t3) {
    var n3 = e2 === r.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return t3.reduce(function(t4, n4) {
      var o3 = M(n4, "a") ? n4.a : 1, u3 = { r: Math.min(t4.r + n4.r * o3, 255), b: Math.min(t4.b + n4.b * o3, 255), a: 1 - (1 - o3) * (1 - t4.a) }, a3 = "g" in t4 ? t4.g : t4.y, s3 = "g" in n4 ? n4.g : n4.y;
      return i(i({}, u3), e2 === r.ADDITIVE ? { g: Math.min(a3 + s3 * o3, 255) } : { y: Math.min(a3 + s3 * o3, 255) });
    }, n3);
  }
  if (e2 === r.ADDITIVE)
    n2 = E2(m2);
  else {
    var H2 = E2(y2);
    o2 = H2.r, u2 = H2.y, a2 = H2.b, s2 = Math.min(o2, u2, a2), c2 = Math.min(255 - o2, 255 - u2, 255 - a2), d2 = o2 - s2, f2 = u2 - s2, h3 = a2 - s2, l2 = Math.min(f2, h3), p2 = d2 + f2 - l2, g2 = f2 + 2 * l2, b2 = 2 * (h3 - l2), F2 = Math.max(p2, g2, b2) / Math.max(d2, f2, h3), A2 = isNaN(F2) || F2 === 1 / 0 || F2 <= 0 ? 1 : F2, (n2 = { r: p2 / A2 + c2, g: g2 / A2 + c2, b: b2 / A2 + c2 }).a = H2.a;
  }
  return { r: O(n2.r, 2), g: O(n2.g, 2), b: O(n2.b, 2), a: X(n2.a, 0, 1) };
} })[t.HEX] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.HEX(n2) : _.HEX(n2);
}, h2.HEXA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return n2.a = r2 ? 255 * T(n2.a) : T(n2.a), r2 ? I.HEX(n2) : _.HEXA(n2);
}, h2[t.RGB] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.RGB(n2) : _.RGB(n2);
}, h2[t.RGBA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return r2 ? I.RGB(n2) : _.RGBA(n2);
}, h2[t.HSL] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b);
  return delete n2.a, delete i2.a, r2 ? I.HSL(i2) : _.HSL(n2);
}, h2[t.HSLA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b, n2.a);
  return r2 ? I.HSL(i2) : _.HSLA(n2);
}, h2);
var Z = function(t2, e2) {
  return "string" == typeof t2 && e2 || "object" == typeof t2 && !e2;
};
var tt = function(t2, e2, r2, n2, i2) {
  var o2 = n2(Q(t2, e2));
  return r2 ? i2(o2) : o2;
};
var et = function(t2, e2, r2, n2, i2, o2) {
  r2 < 1 && (r2 = 5);
  var u2 = function(t3, e3, r3) {
    var n3 = r3 - 1, i3 = (e3.r - t3.r) / n3, o3 = (e3.g - t3.g) / n3, u3 = (e3.b - t3.b) / n3, a2 = T(t3.a), s2 = (T(e3.a) - a2) / n3;
    return Array(r3).fill(null).map(function(r4, c2) {
      return 0 === c2 ? t3 : c2 === n3 ? e3 : { r: O(t3.r + i3 * c2), g: O(t3.g + o3 * c2), b: O(t3.b + u3 * c2), a: O(a2 + s2 * c2, 2) };
    });
  }(Q(t2), Q(e2), r2);
  return u2.map(function(t3) {
    var e3 = i2(t3);
    return n2 ? o2(e3) : e3;
  });
};
var rt = function() {
  function n2(t2) {
    this.rgb = Q(t2), this.updateHSL(), this.updateCMYK();
  }
  return n2.prototype.updateRGB = function() {
    this.rgb = i(i({}, y(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, n2.prototype.updateRGBFromCMYK = function() {
    this.rgb = i(i({}, E(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, n2.prototype.updateHSL = function() {
    this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, n2.prototype.updateCMYK = function() {
    this.cmyk = H(this.rgb.r, this.rgb.g, this.rgb.b);
  }, n2.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, n2.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, n2.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, n2.prototype.setH = function(t2) {
    return this.hsl.h = j(t2), this.updateRGBAndCMYK();
  }, n2.prototype.setS = function(t2) {
    return this.hsl.s = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setL = function(t2) {
    return this.hsl.l = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setR = function(t2) {
    return this.rgb.r = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setG = function(t2) {
    return this.rgb.g = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setB = function(t2) {
    return this.rgb.b = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setA = function(t2) {
    return this.hsl.a = this.rgb.a = X(t2, 0, 1), this;
  }, n2.prototype.setC = function(t2) {
    return this.cmyk.c = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setM = function(t2) {
    return this.cmyk.m = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setY = function(t2) {
    return this.cmyk.y = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setK = function(t2) {
    return this.cmyk.k = X(t2, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(n2.prototype, "H", { get: function() {
    return O(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "S", { get: function() {
    return O(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "L", { get: function() {
    return O(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "R", { get: function() {
    return O(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "G", { get: function() {
    return O(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "B", { get: function() {
    return O(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "A", { get: function() {
    return O(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "C", { get: function() {
    return O(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "M", { get: function() {
    return O(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "Y", { get: function() {
    return O(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "K", { get: function() {
    return O(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXObject", { get: function() {
    return _.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXAObject", { get: function() {
    return _.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBAObject", { get: function() {
    return i(i({}, this.RGBObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLAObject", { get: function() {
    return i(i({}, this.HSLObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEX", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: 255 * this.A };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGB", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: this.A };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSL", { get: function() {
    var t2 = this.hsl, e2 = { h: t2.h, s: t2.s, l: t2.l };
    return I.HSL(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLA", { get: function() {
    return I.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYK", { get: function() {
    return I.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), n2.toHEX = function(t2, e2) {
    void 0 === e2 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEX, I.HEX);
  }, n2.toHEXA = function(t2, e2) {
    void 0 === e2 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEXA, I.HEX);
  }, n2.toRGB = function(t2, e2) {
    void 0 === e2 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGB, I.RGB);
  }, n2.toRGBA = function(t2, e2) {
    void 0 === e2 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGBA, I.RGB);
  }, n2.toHSL = function(e2, r2) {
    void 0 === r2 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSL && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSL, I.HSL);
  }, n2.toHSLA = function(e2, r2) {
    void 0 === r2 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSLA && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSLA, I.HSL);
  }, n2.toCMYK = function(e2, r2) {
    void 0 === r2 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.CMYK && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.CMYK, I.CMYK);
  }, n2.getBlendHEX = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.HEX, I.HEX);
  }, n2.getBlendHEXA = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.HEXA, I.HEX);
  }, n2.getBlendRGB = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.RGB, I.RGB);
  }, n2.getBlendRGBA = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.RGBA, I.RGB);
  }, n2.getBlendHSL = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.HSL, I.HSL);
  }, n2.getBlendHSLA = function(t2, e2, r2, n3) {
    return void 0 === r2 && (r2 = 5), void 0 === n3 && (n3 = true), et(t2, e2, r2, n3, _.HSLA, I.HSL);
  }, n2.getMixHEX = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.HEX(t2, e2, n3);
  }, n2.getMixHEXA = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.HEXA(t2, e2, n3);
  }, n2.getMixRGB = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.RGB(t2, e2, n3);
  }, n2.getMixRGBA = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.RGBA(t2, e2, n3);
  }, n2.getMixHSL = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.HSL(t2, e2, n3);
  }, n2.getMixHSLA = function(t2, e2, n3) {
    return void 0 === e2 && (e2 = r.ADDITIVE), void 0 === n3 && (n3 = true), W.HSLA(t2, e2, n3);
  }, n2.getShades = function(t2, e2) {
    return z(t2, e2, true);
  }, n2.getTints = function(t2, e2) {
    return z(t2, e2, false);
  }, n2.getHarmony = function(t2, n3, i2) {
    switch (void 0 === n3 && (n3 = e.COMPLEMENTARY), void 0 === i2 && (i2 = r.ADDITIVE), n3) {
      case e.ANALOGOUS:
        return J.buildHarmony(t2, P, i2);
      case e.SPLIT_COMPLEMENTARY:
        return J.buildHarmony(t2, K, i2);
      case e.TRIADIC:
        return J.buildHarmony(t2, x, i2);
      case e.TETRADIC:
        return J.buildHarmony(t2, N, i2);
      case e.SQUARE:
        return J.buildHarmony(t2, V, i2);
      default:
        return J.buildHarmony(t2, w, i2);
    }
  }, n2;
}();

// node_modules/vuestic-ui/dist/esm/useColors.js
var colorToRgba = (color, opacity) => {
  return new rt(color).setA(opacity).RGBA;
};
var getTextColor = (color, darkColor = "dark", lightColor = "white") => {
  const { R: R2, G: G2, B: B2 } = new rt(color);
  const isLightBackground = Math.sqrt(R2 * R2 * 0.241 + G2 * G2 * 0.691 + B2 * B2 * 0.068) > 130;
  return isLightBackground ? darkColor : lightColor;
};
var getBoxShadowColor = (color) => {
  return new rt(color).setA(0.4).RGBA;
};
var getHoverColor = (color) => {
  return new rt(color).setA(0.2).RGBA;
};
var getFocusColor = (color) => {
  return new rt(color).setA(0.3).RGBA;
};
var shiftHSLAColor = (color, offset) => {
  const result = new rt(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = new rt(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = rt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = rt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const globalConfig = useGlobalConfigSafe();
  if (!globalConfig) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { setGlobalConfig, getGlobalConfig } = globalConfig;
  const setColors = (colors) => {
    setGlobalConfig((config) => ({
      ...config,
      colors: { ...config.colors, ...colors }
    }));
  };
  const getColors = () => {
    return getGlobalConfig().colors || {};
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = getColors().primary;
    }
    const colors = getColors();
    if (!prop) {
      prop = defaultColor;
    }
    if (colors[prop]) {
      return preferVariables ? `var(--va-${prop})` : colors[prop];
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    if (true) {
      console.warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    }
    return defaultColor;
  };
  const colorsToCSSVariable = (colors, prefix2 = "va") => {
    return Object.keys(colors).filter((key2) => colors[key2] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${colorName}`] = getColor(colors[colorName], void 0, true);
      return acc;
    }, {});
  };
  return {
    setColors,
    getColors,
    getColor,
    getBoxShadowColor,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable
  };
};

// node_modules/vuestic-ui/dist/esm/useSize.js
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size2) => {
      return typeof size2 === "string" || typeof size2 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var useSize = (props, componentName3) => {
  var _a;
  if (componentName3 === void 0) {
    componentName3 = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.type.name;
  }
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName3 ? (_b = (_a2 = getGlobalConfig().components) === null || _a2 === void 0 ? void 0 : _a2[componentName3]) === null || _b === void 0 ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) === null || _a2 === void 0 ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSizeGlobal || defaultSize}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) === null || _b === void 0 ? void 0 : _b.sizes) === null || _c === void 0 ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/esm/VaIcon.js
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
function baseSlice$1(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet2 = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet2(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$12 = _castPath;
var last = last_1;
var parent = _parent;
var toKey2 = _toKey;
function baseUnset$1(object, path) {
  path = castPath$12(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey2(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject2 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject2(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap2 = _arrayMap;
var baseClone2 = _baseClone;
var baseUnset = _baseUnset;
var castPath2 = _castPath;
var copyObject2 = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest2 = _flatRest;
var getAllKeysIn2 = _getAllKeysIn;
var CLONE_DEEP_FLAG2 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG2 = 4;
var omit = flatRest2(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap2(paths, function(path) {
    path = castPath2(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject2(object, getAllKeysIn2(object), result);
  if (isDeep) {
    result = baseClone2(result, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g2) => g2.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g2) => g2.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i2) => ({ ...acc, [paramValue]: values[i2] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge_1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge_1(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key2) => {
    delete configuration[key2];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};
var useIcons = (props) => {
  const { getGlobalConfig } = useGlobalConfig();
  const getIconConfig = () => {
    return getGlobalConfig().icons || [];
  };
  return {
    getIcon: (name) => getIconConfiguration(name, getIconConfig())
  };
};
var script = defineComponent({
  name: "VaIcon",
  props: {
    ...useSizeProps,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(props, { attrs }) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcons();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit_1(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => {
      var _a;
      return [
        iconConfig.value.class,
        getSpinClass((_a = props.spin) !== null && _a !== void 0 ? _a : iconConfig.value.spin)
      ];
    });
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value
    }));
    return {
      iconConfig,
      computedTag,
      computedAttrs,
      computedClass,
      computedStyle
    };
  }
});
function render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    "aria-hidden": "true",
    style: _ctx.computedStyle
  }, _ctx.computedAttrs, { notranslate: "" }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        _ctx.iconConfig.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.iconConfig.content), 1)
        ], 2112)) : createCommentVNode("v-if", true)
      ])
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
script.render = render2;
script.__file = "src/components/va-icon/VaIcon.vue";

// node_modules/vuestic-ui/dist/esm/VaConfig.js
var LocalConfigKey = Symbol("LocalConfigKey");
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
var VaConfig = defineComponent({
  name: "VaConfig",
  props: {
    components: { type: Object, default: () => ({}) }
  },
  setup(props) {
    const { components } = toRefs(props);
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, components.value]);
    provide(LocalConfigKey, nextChain);
    return {};
  },
  render() {
    return this.$slots.default ? this.$slots.default() : null;
  }
});

// node_modules/vuestic-ui/dist/esm/withConfigTransport.js
var useComponentConfigProps = (component) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  return computed(() => {
    var _a;
    const globalConfigProps = {
      ...globalConfig.value.componentsAll,
      ...(_a = globalConfig.value.components) === null || _a === void 0 ? void 0 : _a[component.name]
    };
    const localConfigProps = localConfig.value.reduce((finalConfig, config) => config[component.name] ? { ...finalConfig, ...config[component.name] } : finalConfig, {});
    const props = { ...globalConfigProps, ...localConfigProps };
    return props;
  });
};
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key2) => {
      const incommingProps = instance.vnode.props || {};
      const originalProp = target[key2];
      const propFromConfig = propsFromConfig.value[key2];
      if (incommingProps[key2] === void 0 && propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var patchInstanceProps = (instance, props) => {
  instance.props = props;
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component);
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    patchInstanceProps(instance, props);
    return (_a = component.setup) === null || _a === void 0 ? void 0 : _a.call(component, shallowReadonly(props), ctx);
  };
  return new Proxy(component, {
    get(target, key2) {
      if (key2 === "setup") {
        return customSetup;
      }
      return target[key2];
    }
  });
};
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({});
    return createProxyComponent(component);
  }
};

// node_modules/vuestic-ui/dist/esm/useStateful.js
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var useStatefulEmits = ["update:modelValue"];
function useStateful(props, emit, defaultValue) {
  const valueState = ref(defaultValue === void 0 ? props.modelValue : defaultValue);
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props.modelValue, (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue === null || unwatchModelValue === void 0 ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get() {
      if (props.stateful) {
        return valueState.value;
      }
      return props.modelValue;
    },
    set(value) {
      if (props.stateful) {
        valueState.value = value;
      }
      emit("update:modelValue", value);
    }
  });
  return { valueComputed };
}

// node_modules/vuestic-ui/dist/esm/useAccordion.js
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  let items2 = [];
  const onItemMounted = (item) => {
    items2.push(item);
  };
  const onItemUnmounted = (item) => {
    items2 = items2.filter((i2) => i2 !== item);
  };
  const onItemChanged = (changedItem) => {
    state.value = items2.map((item) => {
      if (item === changedItem) {
        return item.state.value;
      }
      if (!props.multiply) {
        item.state.value = false;
      }
      return item.state.value;
    });
  };
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    onItemChanged,
    props: computed(() => props)
  });
  const updateItemStates = () => {
    items2.forEach((item, index) => {
      item.state.value = state.value[index];
    });
  };
  onMounted(updateItemStates);
  watch(state, updateItemStates);
  return { items: items2 };
};
var useAccordionItem = (state) => {
  const accordion = inject(AccordionServiceKey, {
    props: ref({ inset: void 0, popout: void 0 }),
    onItemChanged: () => void 0,
    onItemMounted: () => void 0,
    onItemUnmounted: () => void 0
  });
  const item = { state };
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  return {
    accordionProps: accordion.props,
    toggle: () => {
      state.value = !state.value;
      accordion.onItemChanged(item);
    }
  };
};

// node_modules/vuestic-ui/dist/esm/index.js
var script2 = defineComponent({
  name: "VaAccordion",
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: Array, default: () => [] },
    multiply: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    popout: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, []);
    const { items: items2 } = useAccordion(props, valueComputed);
    return { collapses: items2, value: valueComputed };
  }
});
var _hoisted_1 = { class: "va-accordion" };
function render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script2.render = render3;
script2.__file = "src/components/va-accordion/VaAccordion.vue";
var VaAccordion = withConfigTransport(script2);

// node_modules/vuestic-ui/dist/esm/toNumber.js
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject3 = isObject_1;
var isSymbol3 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol3(value)) {
    return NAN;
  }
  if (isObject3(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject3(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber;

// node_modules/vuestic-ui/dist/esm/debounce.js
var root2 = _root;
var now$1 = function() {
  return root2.Date.now();
};
var now_1 = now$1;
var isObject4 = isObject_1;
var now = now_1;
var toNumber2 = toNumber_1;
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber2(wait) || 0;
  if (isObject4(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce;

// node_modules/vuestic-ui/dist/esm/index2.js
function noop() {
}
var noop_1 = noop;
var debounce2 = debounce_1;
var isObject5 = isObject_1;
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  if (isObject5(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce2(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({ coordinates, offsetTop, offsetBottom, target }) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, { handler, useCapture = useCaptureDefault, wait = 50 }) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle_1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear2) => clear2());
}
var script3 = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: {
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  setup(props, { emit }) {
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop_1;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});
var _hoisted_12 = {
  ref: "element",
  class: "va-affix"
};
function render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_12, [
    createBaseVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? "hidden" : "inherit" })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.isAffixed ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.computedClass),
      style: normalizeStyle(_ctx.computedStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)) : createCommentVNode("v-if", true)
  ], 512);
}
script3.render = render4;
script3.__file = "src/components/va-affix/VaAffix.vue";
var VaAffix = withConfigTransport(script3);

// node_modules/vuestic-ui/dist/esm/utils.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var warn = (...attrs) => {
  if (__DEV__) {
    console.warn(...attrs);
  }
  return false;
};
var hasOwnProperty2 = (object, key2) => {
  return Object.prototype.hasOwnProperty.call(object, key2);
};
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject_1(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (typeof option !== "object" || !option) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}`;
};

// node_modules/vuestic-ui/dist/esm/useTextColor.js
var useTextColor = (componentColor, isTransparent = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor: getTextColor2 } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const componentColorHex = getColor(unref(componentColor) || props.color);
    return unref(isTransparent) ? componentColorHex : getColor(getTextColor2(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/esm/index31.js
var VaIcon = withConfigTransport(script);

// node_modules/vuestic-ui/dist/esm/index3.js
var useAlertStyles = (props) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background = "transparent";
    }
    if (props.border) {
      background = "var(--va-white)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      background,
      boxShadow
    };
  });
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border ? getColor("dark") : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};
var script4 = defineComponent({
  name: "VaAlert",
  components: { VaIcon },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  setup(props, { slots, emit }) {
    const alertStyles = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide = () => {
      valueComputed.value = false;
    };
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const closeIcon = computed(() => props.closeText || "close");
    const uniqueId = computed(generateUniqueId);
    const titleIdComputed = computed(() => `aria-title-${uniqueId.value}`);
    const descriptionIdComputed = computed(() => `aria-description-${uniqueId.value}`);
    return {
      ...alertStyles,
      valueComputed,
      hasIcon,
      hasTitle,
      borderClass,
      closeIcon,
      hide,
      titleIdComputed,
      descriptionIdComputed
    };
  }
});
var _hoisted_13 = ["role", "aria-labelledby", "aria-describedby"];
var _hoisted_2 = ["id"];
var _hoisted_3 = ["id"];
var _hoisted_4 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_5 = ["aria-label"];
function render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "fade"
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-alert",
        style: normalizeStyle(_ctx.alertStyle),
        role: _ctx.closeable ? "alertdialog" : "alert",
        "aria-labelledby": _ctx.titleIdComputed,
        "aria-describedby": _ctx.descriptionIdComputed
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.borderStyle),
          class: normalizeClass([_ctx.borderClass, "va-alert__border"])
        }, null, 6),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__icon",
          "aria-hidden": "true"
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, { name: _ctx.icon }, null, 8, ["name"])
          ])
        ], 4)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__content"
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle(_ctx.titleStyle),
            class: "va-alert__title",
            id: _ctx.titleIdComputed
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 12, _hoisted_2)) : createCommentVNode("v-if", true),
          createBaseVNode("span", { id: _ctx.descriptionIdComputed }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.description), 1)
            ])
          ], 8, _hoisted_3)
        ], 4),
        _ctx.closeable ? (openBlock(), createElementBlock("div", _hoisted_4, [
          createBaseVNode("div", {
            style: normalizeStyle(_ctx.contentStyle),
            class: "va-alert__close--closeable",
            role: "button",
            tabindex: "0",
            "aria-label": _ctx.closeText || "close alert",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.hide()),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys(($event) => _ctx.hide(), ["space"])),
              _cache[2] || (_cache[2] = withKeys(($event) => _ctx.hide(), ["enter"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              !_ctx.closeText ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                name: _ctx.closeIcon,
                size: "small"
              }, null, 8, ["name"])) : createCommentVNode("v-if", true),
              createTextVNode(" " + toDisplayString(_ctx.closeText), 1)
            ])
          ], 44, _hoisted_5)
        ])) : createCommentVNode("v-if", true)
      ], 12, _hoisted_13)
    ]),
    _: 3
  })) : createCommentVNode("v-if", true);
}
script4.render = render5;
script4.__file = "src/components/va-alert/VaAlert.vue";
var VaAlert = withConfigTransport(script4);

// node_modules/vuestic-ui/dist/esm/index4.js
function getTargetElement(target) {
  if (!target) {
    throw new Error("Cant find target");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(target, onScrollCallback) {
  const scrollRoot = shallowRef();
  let targetElement;
  onMounted(() => {
    targetElement = getTargetElement(target || scrollRoot.value);
    targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener("scroll", onScrollCallback);
  });
  onBeforeUnmount(() => {
    targetElement === null || targetElement === void 0 ? void 0 : targetElement.removeEventListener("scroll", onScrollCallback);
  });
  return scrollRoot;
}
var script5 = defineComponent({
  name: "VaAppBar",
  props: {
    gradient: { type: Boolean, default: false },
    bottom: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    hideOnScroll: { type: Boolean, default: false },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: void 0 },
    absolute: { type: Boolean, default: false }
  },
  setup(props) {
    const prevScrollPosition = ref(0);
    const doShowShadow = ref(false);
    const isHidden = ref(false);
    const scrollRoot = setupScroll(props.target, (e2) => {
      const target = e2.target;
      if (prevScrollPosition.value < target.scrollTop) {
        isHidden.value = !!props.hideOnScroll;
        doShowShadow.value = !!props.shadowOnScroll;
      } else {
        isHidden.value = false;
        doShowShadow.value = false;
      }
      prevScrollPosition.value = target.scrollTop;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color, "primary"));
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return doShowShadow.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const transformComputed = computed(() => {
      if (!isHidden.value) {
        return "";
      }
      return props.bottom ? "translateY(100%)" : "translateY(-100%)";
    });
    const computedStyle = computed(() => ({
      background: props.gradient ? getGradientBackground(colorComputed.value) : colorComputed.value,
      "box-shadow": computedShadow.value,
      transform: transformComputed.value,
      position: props.absolute ? "absolute" : void 0
    }));
    const computedClass = computed(() => ({
      "va-app-bar": true,
      "va-app-bar--bottom": props.bottom
    }));
    return {
      scrollRoot,
      computedStyle,
      computedClass
    };
  }
});
function render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    role: "toolbar",
    class: normalizeClass(_ctx.computedClass),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script5.render = render6;
script5.__file = "src/components/va-app-bar/VaAppBar.vue";
var VaAppBar = withConfigTransport(script5);

// node_modules/vuestic-ui/dist/esm/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/esm/clamp.js
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber3 = toNumber_1;
function clamp2(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber3(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber3(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber3(number), lower, upper);
}
var clamp_1 = clamp2;

// node_modules/vuestic-ui/dist/esm/index43.js
var script6 = defineComponent({
  name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" }
  },
  setup(props) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp_1(props.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp_1(props.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    return {
      infoStyle: computed(() => ({ color: colorComputed.value })),
      rootStyle: computed(() => ({
        width: sizeComputed.value,
        height: sizeComputed.value
      })),
      rootClass: computed(() => ({
        "va-progress-circle--indeterminate": props.indeterminate
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: "progress state",
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      })),
      colorComputed,
      radius,
      dasharray,
      dashoffset,
      cappedThickness
    };
  }
});
var _hoisted_14 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_14, [
      createBaseVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + "%",
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8, _hoisted_22)
    ])),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.infoStyle),
      class: "va-progress-circle__info"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)) : createCommentVNode("v-if", true)
  ], 16);
}
script6.render = render7;
script6.__file = "src/components/va-progress-circle/VaProgressCircle.vue";
var VaProgressCircle = withConfigTransport(script6);

// node_modules/vuestic-ui/dist/esm/index5.js
var script7 = defineComponent({
  name: "VaAvatar",
  components: { VaIcon, VaProgressCircle },
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    color: { type: String, default: "info" },
    textColor: { type: String, default: "white" },
    square: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    src: { type: String, default: null },
    alt: { type: String, default: "" },
    fontSize: { type: String, default: "" }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: props.loading ? "transparent" : colorComputed.value,
      borderRadius: props.square ? 0 : "",
      fontSize: props.fontSize || fontSizeComputed.value,
      width: sizeComputed.value,
      minWidth: sizeComputed.value,
      height: sizeComputed.value
    }));
    return {
      sizeComputed,
      computedStyle,
      colorComputed
    };
  }
});
var _hoisted_15 = ["aria-hidden"];
var _hoisted_23 = ["src", "alt"];
function render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "va-avatar",
    style: normalizeStyle(_ctx.computedStyle),
    "aria-hidden": !_ctx.$props.src,
    "aria-live": "polite"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        size: _ctx.sizeComputed,
        color: _ctx.colorComputed,
        indeterminate: ""
      }, null, 8, ["size", "color"])) : _ctx.$props.src ? (openBlock(), createElementBlock("img", {
        key: 1,
        src: _ctx.$props.src,
        alt: _ctx.$props.alt
      }, null, 8, _hoisted_23)) : _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 2,
        name: _ctx.$props.icon
      }, null, 8, ["name"])) : createCommentVNode("v-if", true)
    ])
  ], 12, _hoisted_15);
}
script7.render = render8;
script7.__file = "src/components/va-avatar/VaAvatar.vue";
var VaAvatar = withConfigTransport(script7);

// node_modules/vuestic-ui/dist/esm/useRouterLink.js
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: "" },
  replace: { type: Boolean, default: false },
  append: { type: Boolean, default: false },
  exact: { type: Boolean, default: false },
  activeClass: { type: String, default: "" },
  exactActiveClass: { type: String, default: "" },
  href: { type: String, default: "" },
  target: { type: String, default: "" },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  const globalProperties = computed(() => {
    var _a;
    return (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.appContext.config.globalProperties;
  });
  const isNuxt = computed(() => {
    var _a;
    return !!((_a = globalProperties.value) === null || _a === void 0 ? void 0 : _a.$nuxt);
  });
  const vueRouter = computed(() => {
    var _a;
    return (_a = globalProperties.value) === null || _a === void 0 ? void 0 : _a.$router;
  });
  const vueRoute = computed(() => {
    var _a;
    return (_a = globalProperties.value) === null || _a === void 0 ? void 0 : _a.$route;
  });
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (props.to) {
      return isNuxt.value ? "nuxt-link" : "router-link";
    }
    return props.tag;
  });
  const isLinkTag = computed(() => ["a", "router-link", "nuxt-link"].includes(tagComputed.value));
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a;
    return props.href || (props.to ? (_a = vueRouter.value) === null || _a === void 0 ? void 0 : _a.resolve(props.to, vueRoute.value).href : "");
  });
  return {
    tagComputed,
    isActiveRouterLink,
    hrefComputed,
    isLinkTag
  };
};

// node_modules/vuestic-ui/dist/esm/VaButton.js
var script8 = defineComponent({
  name: "VaButton",
  components: { VaIcon, VaProgressCircle },
  props: {
    ...useSizeProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    tag: { type: String, default: "button" },
    outline: { type: Boolean, default: void 0 },
    gradient: { type: Boolean, default: void 0 },
    flat: { type: Boolean, default: void 0 },
    type: { type: String, default: "button" },
    disabled: { type: Boolean, default: false },
    block: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    round: { type: Boolean, default: void 0 },
    spaceBetweenItems: { type: Boolean, default: void 0 },
    icon: { type: String, default: void 0 },
    iconRight: { type: String, default: void 0 },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props, { slots }) {
    const button = shallowRef();
    const { sizeComputed } = useSize(props);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const hoverState = ref(false);
    const focusState = ref(false);
    const { getColor, getGradientBackground: getGradientBackground2, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const isSlotContentPassed = computed(() => {
      var _a, _b, _c;
      return !!((_c = (_b = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.children);
    });
    const computedType = computed(() => {
      switch (tagComputed.value) {
        case "a":
        case "router-link":
        case "nuxt-link":
          return void 0;
        default:
          return props.type;
      }
    });
    const hasOneIcon = computed(() => {
      return Boolean(props.iconRight && !props.icon || !props.iconRight && props.icon);
    });
    const computedClass = computed(() => ({
      "va-button--default": !props.flat && !props.outline && !props.disabled,
      "va-button--flat": props.flat,
      "va-button--outline": props.outline,
      "va-button--disabled": props.disabled,
      "va-button--hover": hoverState.value,
      "va-button--focus": focusState.value,
      "va-button--large": props.size === "large",
      "va-button--small": props.size === "small",
      "va-button--normal": !props.size || props.size === "medium",
      "va-button--loading": props.loading,
      "va-button--block": props.block,
      "va-button--square": !props.rounded,
      "va-button--round": props.round || !slots.default && hasOneIcon.value,
      "va-button--no-label": !isSlotContentPassed.value,
      "va-button--space-between-items": props.spaceBetweenItems
    }));
    const loaderSize = computed(() => {
      const size2 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size2 ? `${+size2[1] / 2}${size2[2]}` : sizeComputed.value;
    });
    const computedStyle = computed(() => {
      const borderColor = props.outline ? colorComputed.value : "";
      let background = props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
      if (isTransparentBackground.value) {
        background = "var(--va-transparent)";
      }
      if (hoverState.value) {
        const alpha = props.outline ? -0.9 : -0.8;
        const lightness = 5;
        const color = isTransparentBackground.value ? shiftHSLAColor2(colorComputed.value, { a: alpha }) : shiftHSLAColor2(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground2(color) : color;
      }
      if (focusState.value) {
        const alpha = props.outline ? -0.8 : -0.7;
        const lightness = 10;
        const color = isTransparentBackground.value ? shiftHSLAColor2(colorComputed.value, { a: alpha }) : shiftHSLAColor2(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground2(color) : color;
      }
      return {
        color: textColorComputed.value,
        borderColor,
        background
      };
    });
    const focus = () => {
      var _a;
      return (_a = button.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      return (_a = button.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    return {
      button,
      tagComputed,
      hrefComputed,
      computedClass,
      computedStyle,
      computedType,
      textColorComputed,
      loaderSize,
      focusState,
      hoverState,
      focus,
      blur
    };
  }
});
function render9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    class: ["va-button", _ctx.computedClass],
    ref: "button",
    "aria-live": "polite",
    "aria-disabled": _ctx.$props.disabled,
    style: _ctx.computedStyle,
    disabled: _ctx.$props.disabled,
    type: _ctx.computedType,
    href: _ctx.hrefComputed,
    target: _ctx.$props.target,
    to: _ctx.$props.to,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    "active-class": _ctx.$props.activeClass,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass,
    tabindex: _ctx.loading ? -1 : 0
  }, toHandlers(_ctx.$attrs), {
    onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusState = true),
    onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusState = false),
    onMouseleave: _cache[2] || (_cache[2] = ($event) => _ctx.hoverState = false),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.hoverState = true)
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(["va-button__content", { "va-button__content--loading": _ctx.loading }])
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-button__left-icon",
          name: _ctx.icon,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          class: "va-button__right-icon",
          name: _ctx.iconRight,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("v-if", true)
      ], 2),
      _ctx.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        class: "va-button__loader",
        indeterminate: "",
        size: _ctx.loaderSize,
        color: _ctx.computedStyle.color,
        thickness: 0.15
      }, null, 8, ["size", "color", "thickness"])) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 16, ["aria-disabled", "class", "style", "disabled", "type", "href", "target", "to", "replace", "append", "active-class", "exact", "exact-active-class", "tabindex"]);
}
script8.render = render9;
script8.__file = "src/components/va-button/VaButton.vue";

// node_modules/vuestic-ui/dist/esm/index12.js
var VaButton = withConfigTransport(script8);

// node_modules/vuestic-ui/dist/esm/index6.js
var script9 = defineComponent({
  name: "VaBacktop",
  components: { VaButton },
  props: {
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        return document.querySelector(props.target);
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const visible = computed(() => targetScrollValue.value > props.visibilityHeight);
    onMounted(() => {
      targetElement = getTargetElement2();
      targetElement.addEventListener("scroll", handleScroll, true);
    });
    onBeforeUnmount(() => targetElement === null || targetElement === void 0 ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    return {
      computedStyle,
      visible,
      scrollToTop
    };
  }
});
function render10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": "back to top",
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "expand_less",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 36)) : createCommentVNode("v-if", true);
}
script9.render = render10;
script9.__file = "src/components/va-backtop/VaBacktop.vue";
var VaBacktop = withConfigTransport(script9);

// node_modules/vuestic-ui/dist/esm/index7.js
var script10 = defineComponent({
  name: "VaBadge",
  props: {
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    overlap: { type: Boolean, default: false },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    transparent: { type: Boolean, default: false },
    left: { type: Boolean, default: false },
    bottom: { type: Boolean, default: false }
  },
  setup(props, { slots }) {
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => slots.default || props.dot);
    const badgeClass = computed(() => ({
      "va-badge--visible-empty": props.visibleEmpty,
      "va-badge--empty": isEmpty.value,
      "va-badge--dot": props.dot,
      "va-badge--multiLine": props.multiLine,
      "va-badge--floating": isFloating.value,
      "va-badge--left": props.left,
      "va-badge--bottom": props.bottom,
      "va-badge--overlap": props.overlap
    }));
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const badgeStyle = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1
    }));
    return { badgeClass, badgeStyle };
  }
});
var _hoisted_16 = { class: "va-badge__text" };
function render11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-badge", _ctx.badgeClass]),
    role: "alert"
  }, [
    createBaseVNode("span", {
      class: "va-badge__text-wrapper",
      style: normalizeStyle(_ctx.badgeStyle)
    }, [
      createBaseVNode("span", _hoisted_16, [
        renderSlot(_ctx.$slots, "text", {}, () => [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ])
      ])
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script10.render = render11;
script10.__file = "src/components/va-badge/VaBadge.vue";
var VaBadge = withConfigTransport(script10);

// node_modules/vuestic-ui/dist/esm/useAlign.js
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/esm/index8.js
var script$1 = defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    separator: { type: String, default: "/" },
    color: { type: String, default: "gray" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null }
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : getColor(props.color);
    });
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : getColor(props.color);
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a, _b;
          return !!((_b = (_a = node2 === null || node2 === void 0 ? void 0 : node2.type) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = slots.separator ? slots.separator() : [props.separator];
      return h("span", {
        ariaHidden: true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child === null || child === void 0 ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      var _a;
      const childNodes = ((_a = slots === null || slots === void 0 ? void 0 : slots.default()) === null || _a === void 0 ? void 0 : _a.reduce(childNodeFilter, [])) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child === null || child === void 0 ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h("span", {
        class: "va-breadcrumbs__item",
        ariaCurrent: isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
        style: {
          color: !isLastIndexChildNodes(index) && !isDisabledChild(child) ? computedThemesActiveColor.value : null
        }
      }, [child]);
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      ariaLabel: isAllChildLinks.value ? "breadcrumbs" : void 0
    }, getChildren());
  }
});
script$1.__file = "src/components/va-breadcrumbs/VaBreadcrumbs.vue";
var script11 = defineComponent({
  name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup: (props) => {
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return { tagComputed, hrefComputed, classComputed };
  }
});
function render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-breadcrumb-item", _ctx.classComputed]),
    "active-class": _ctx.$props.activeClass,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to,
    target: _ctx.$props.target,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ]),
    _: 3
  }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
}
script11.render = render12;
script11.__file = "src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.vue";
var VaBreadcrumbsItem = withConfigTransport(script11);
var VaBreadcrumbs = withConfigTransport(script$1);

// node_modules/vuestic-ui/dist/esm/useEmitProxy.js
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key2) => ({
      ...acc,
      [eventToListenerName(getEvent(key2))]: (...args) => emit(getEmit(key2), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key2) => ({
      ...acc,
      [getEvent(key2)]: (...args) => emit(getEmit(key2), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/esm/_createCompounder.js
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key2) {
    return object == null ? void 0 : object[key2];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var deburrLetter = _deburrLetter;
var toString$12 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr$1(string) {
  string = toString$12(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString2 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString2(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder;

// node_modules/vuestic-ui/dist/esm/useBem.js
var createCompounder2 = _createCompounder;
var kebabCase = createCompounder2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
var useBem = (prefix2, modifiers) => {
  if (__DEV__ && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase_1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_2, key2) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key2);
    },
    get(_2, key2, receiver) {
      switch (key2) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key2, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/esm/useCaptureEvent.js
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};

// node_modules/vuestic-ui/dist/esm/index27.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a2) => Array.isArray(a2) ? a2 : [a2];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("click", (event) => {
    const clickTarget = event.target;
    const isClickInside = safeArray(elements).some((element) => unref(element) && checkIfElementChild(unref(element), clickTarget));
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce_1(() => {
      callback === null || callback === void 0 ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};
var script$12 = defineComponent({
  name: "VaDropdown",
  props: {
    ...useStatefulProps,
    stateful: { default: true },
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    attachElement: { type: String, default: "body" },
    disableAttachment: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover", "none"].includes(value)
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (value) => placementsPositions.includes(value)
    }
  },
  emits: [...useStatefulEmits, "anchor-click", "dropdown-content-click", "click-outside"],
  setup(props, { emit }) {
    const anchorRef = shallowRef();
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
      }
    });
    const computedClass = useBem("va-dropdown", () => pick_1(props, ["disabled"]));
    const computedAnchorRef = computed(() => anchorRef.value && props.anchorSelector ? anchorRef.value.querySelector(props.anchorSelector) || anchorRef.value : anchorRef.value);
    usePopover(computedAnchorRef, contentRef, computed(() => ({
      placement: props.placement,
      keepAnchorWidth: props.keepAnchorWidth,
      offset: props.offset,
      stickToEdges: true,
      autoPlacement: true,
      root: props.attachElement
    })));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close) => {
      emit(eventName);
      if (close) {
        valueComputed.value = false;
      }
    };
    const onAnchorClick = () => {
      if (props.trigger !== "click" || props.disabled) {
        return;
      }
      if (valueComputed.value) {
        emitAndClose("anchor-click", props.closeOnAnchorClick);
      } else {
        valueComputed.value = true;
        emit("anchor-click");
      }
    };
    useClickOutside([anchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    return {
      valueComputed,
      anchorRef,
      contentRef,
      computedClass,
      emitAndClose,
      onAnchorClick,
      onMouseEnter,
      onMouseLeave
    };
  }
});
var _hoisted_17 = ["aria-disabled", "aria-expanded"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    "aria-haspopup": "listbox",
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed
  }, [
    createBaseVNode("div", {
      ref: "anchorRef",
      class: "va-dropdown__anchor",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onAnchorClick && _ctx.onAnchorClick(...args)),
      onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      renderSlot(_ctx.$slots, "anchor")
    ], 544),
    _ctx.valueComputed ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.attachElement,
      disabled: _ctx.disableAttachment
    }, [
      createBaseVNode("div", {
        ref: "contentRef",
        class: "va-dropdown__content-wrapper",
        onMouseover: _cache[3] || (_cache[3] = ($event) => _ctx.$props.isContentHoverable && _ctx.onMouseEnter()),
        onMouseout: _cache[4] || (_cache[4] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onClick: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.emitAndClose("dropdown-content-click", _ctx.closeOnContentClick), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 544)
    ], 8, ["to", "disabled"])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_17);
}
script$12.render = render$1;
script$12.__file = "src/components/va-dropdown/VaDropdown.vue";
var script12 = defineComponent({
  name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "white" },
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return { computedStyle };
  }
});
function render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script12.render = render13;
script12.__file = "src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.vue";
var VaDropdownContent = withConfigTransport(script12);
var VaDropdown = withConfigTransport(script$12);

// node_modules/vuestic-ui/dist/esm/index10.js
var script13 = defineComponent({
  name: "VaButtonGroup",
  components: { VaConfig },
  props: {
    color: { type: String, default: "primary" },
    gradient: { type: Boolean, default: void 0 },
    textColor: { type: String, default: void 0 },
    rounded: { type: Boolean, default: true },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props) {
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const computedBackground = computed(() => {
      if (props.outline || props.flat) {
        return "";
      }
      return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
    });
    const computedStyle = computed(() => {
      const backgroundProperty = props.gradient ? "background-image" : "background";
      return {
        [backgroundProperty]: computedBackground.value,
        color: textColorComputed.value
      };
    });
    const buttonConfig = computed(() => ({
      VaButton: {
        ...props,
        color: props.gradient ? "#00000000" : props.color,
        textColor: textColorComputed.value
      }
    }));
    const computedClass = computed(() => ({ "va-button-group_square": !props.rounded }));
    return {
      buttonConfig,
      computedStyle,
      computedClass
    };
  }
});
function render14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-group", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createVNode(_component_va_config, { components: _ctx.buttonConfig }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["components"])
  ], 6);
}
script13.render = render14;
script13.__file = "src/components/va-button-group/VaButtonGroup.vue";
var VaButtonGroup = withConfigTransport(script13);

// node_modules/vuestic-ui/dist/esm/index9.js
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy([{ listen: "click", emit: "main-button-click" }]);
var componentName = "VaButtonDropdown";
var script14 = defineComponent({
  name: componentName,
  components: {
    VaButtonGroup,
    VaButton,
    VaDropdown,
    VaDropdownContent
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    gradient: { type: Boolean, default: void 0 },
    icon: { type: String, default: "expand_more" },
    openedIcon: { type: String, default: "expand_less" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => placementsPositions.includes(placement)
    },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String }
  },
  setup(props, { emit, slots }) {
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed(() => {
      return valueComputed.value ? props.openedIcon : props.icon;
    });
    const computedClass = computed(() => ({
      "va-button-dropdown": true,
      "va-button-dropdown--split": props.split,
      "va-button-dropdown--normal": props.size === "medium",
      "va-button-dropdown--large": props.size === "large",
      "va-button-dropdown--small": props.size === "small"
    }));
    const computedButtonIcons = computed(() => {
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return props.hideIcon ? {} : { [propName]: computedIcon.value };
    });
    const computedViewStyles = computed(() => pick_1(props, ["outline", "gradient", "rounded", "flat", "size", "color"]));
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    return {
      hideDropdown,
      valueComputed,
      computedIcon,
      computedClass,
      listeners: createListeners(emit),
      mainButtonListeners: createMainButtonListeners(emit),
      computedButtonIcons,
      computedViewStyles,
      computedMainButtonProps
    };
  }
});
function render15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.computedClass)
  }, [
    !_ctx.$props.split ? (openBlock(), createBlock(_component_va_dropdown, {
      key: 0,
      disabled: _ctx.$props.disabled,
      placement: _ctx.$props.placement,
      offset: _ctx.$props.offset,
      "keep-anchor-width": _ctx.$props.keepAnchorWidth,
      "close-on-content-click": _ctx.$props.closeOnContentClick,
      stateful: _ctx.$props.stateful,
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event)
    }, {
      anchor: withCtx(() => [
        createVNode(_component_va_button, mergeProps({
          disabled: _ctx.$props.disabled,
          round: !_ctx.$props.label && !_ctx.$slots.label
        }, { ..._ctx.computedButtonIcons, ..._ctx.computedViewStyles }, toHandlers(_ctx.listeners), {
          onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled", "round", "onKeydown"])
      ]),
      default: withCtx(() => [
        createVNode(_component_va_dropdown_content, null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["disabled", "placement", "offset", "keep-anchor-width", "close-on-content-click", "stateful", "modelValue"])) : (openBlock(), createBlock(_component_va_button_group, mergeProps({
      key: 1,
      class: { "va-button-group__left-icon": _ctx.$props.leftIcon }
    }, _ctx.computedViewStyles), {
      default: withCtx(() => [
        !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 0,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("v-if", true),
        createVNode(_component_va_dropdown, {
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
          placement: _ctx.$props.placement,
          offset: _ctx.$props.offset,
          stateful: _ctx.$props.stateful,
          modelValue: _ctx.valueComputed,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
        }, {
          anchor: withCtx(() => [
            createVNode(_component_va_button, mergeProps({
              "aria-label": "toggle dropdown",
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              icon: _ctx.computedIcon
            }, toHandlers(_ctx.listeners), {
              onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
            }), null, 16, ["disabled", "icon", "onKeydown"])
          ]),
          default: withCtx(() => [
            createVNode(_component_va_dropdown_content, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["disabled", "placement", "offset", "stateful", "modelValue"]),
        _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 1,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 16, ["class"]))
  ], 2);
}
script14.render = render15;
script14.__file = "src/components/va-button-dropdown/VaButtonDropdown.vue";
var VaButtonDropdown = withConfigTransport(script14);

// node_modules/vuestic-ui/dist/esm/index11.js
var script15 = defineComponent({
  name: "VaButtonToggle",
  components: {
    VaButtonGroup,
    VaButton
  },
  emits: ["update:modelValue"],
  props: {
    options: {
      type: Array,
      required: true
    },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    activeButtonTextColor: { type: String },
    modelValue: { type: [String, Number], default: "" },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    toggleColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isFlatOrOutline = computed(() => props.outline || props.flat);
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      } else {
        return isFlatOrOutline.value ? colorComputed.value : shiftHSLAColor(colorComputed.value, { l: -6 });
      }
    });
    const { textColorComputed: activeButtonTextColor } = useTextColor(activeButtonColor);
    const isToggled = (value) => value === props.modelValue;
    const getButtonProps = (option = {}) => {
      var _a;
      const iconsProps = {
        icon: option.icon,
        iconRight: option.iconRight
      };
      if (!isToggled(option.value)) {
        return iconsProps;
      }
      return {
        color: activeButtonColor.value,
        textColor: (_a = props.activeButtonTextColor) !== null && _a !== void 0 ? _a : activeButtonTextColor.value,
        ...iconsProps,
        ...isFlatOrOutline.value && { outline: false, flat: false }
      };
    };
    const getButtonClass = (buttonValue) => ({ "va-button--active": isToggled(buttonValue) });
    const changeValue = (value) => emit("update:modelValue", value);
    return {
      getButtonProps,
      getButtonClass,
      changeValue,
      isToggled
    };
  }
});
var _hoisted_18 = { class: "va-button-toggle" };
function render16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", _hoisted_18, [
    createVNode(_component_va_button_group, {
      color: _ctx.color,
      textColor: _ctx.textColor,
      rounded: _ctx.rounded,
      outline: _ctx.outline,
      flat: _ctx.flat,
      gradient: _ctx.gradient
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
          return openBlock(), createBlock(_component_va_button, mergeProps({
            key: option.value,
            "aria-pressed": _ctx.isToggled(option.value),
            class: _ctx.getButtonClass(option.value),
            disabled: _ctx.disabled,
            size: _ctx.size
          }, _ctx.getButtonProps(option), {
            onClick: ($event) => _ctx.changeValue(option.value)
          }), {
            default: withCtx(() => [
              createTextVNode(toDisplayString(option.label), 1)
            ]),
            _: 2
          }, 1040, ["aria-pressed", "class", "disabled", "size", "onClick"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["color", "textColor", "rounded", "outline", "flat", "gradient"])
  ]);
}
script15.render = render16;
script15.__file = "src/components/va-button-toggle/VaButtonToggle.vue";
var VaButtonToggle = withConfigTransport(script15);

// node_modules/vuestic-ui/dist/esm/index13.js
var script$3 = defineComponent({
  name: "VaCard",
  emits: ["click"],
  props: {
    ...useRouterLinkProps,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "white" }
  },
  setup(props) {
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor();
    const stripeStyles = computed(() => ({ background: getColor(props.stripeColor) }));
    const cardClasses = computed(() => ({
      "va-card--square": props.square,
      "va-card--outlined": props.outlined,
      "va-card--no-border": !props.bordered,
      "va-card--disabled": props.disabled,
      "va-card--link": isLinkTag.value
    }));
    const cardStyles = computed(() => {
      if (props.gradient && props.color) {
        return {
          background: getGradientBackground(getColor(props.color)),
          color: textColorComputed.value
        };
      }
      return { background: getColor(props.color), color: textColorComputed.value };
    });
    return {
      cardClasses,
      cardStyles,
      stripeStyles,
      tagComputed,
      hrefComputed
    };
  }
});
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-card", _ctx.cardClasses]),
    style: normalizeStyle(_ctx.cardStyles),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass
  }, {
    default: withCtx(() => [
      _ctx.stripe ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-card__stripe",
        style: normalizeStyle(_ctx.stripeStyles)
      }, null, 4)) : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        class: "va-card__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        renderSlot(_ctx.$slots, "default")
      ])
    ]),
    _: 3
  }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
}
script$3.render = render$3;
script$3.__file = "src/components/va-card/VaCard.vue";
var script$2 = defineComponent({
  name: "VaCardContent"
});
var _hoisted_19 = { class: "va-card__content" };
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_19, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$2.render = render$2;
script$2.__file = "src/components/va-card/VaCardContent.vue";
var script$13 = defineComponent({
  name: "VaCardTitle",
  props: {
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      titleStyles: computed(() => ({
        color: props.textColor ? getColor(props.textColor) : ""
      }))
    };
  }
});
function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-card__title",
    style: normalizeStyle(_ctx.titleStyles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script$13.render = render$12;
script$13.__file = "src/components/va-card/VaCardTitle.vue";
var script16 = defineComponent({
  name: "VaCardActions",
  props: {
    ...useAlignProps
  },
  setup(props) {
    const { alignComputed } = useAlign(props);
    return {
      alignComputed
    };
  }
});
function render17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.vertical ? "va-card__actions_vertical" : "va-card__actions"]),
    style: normalizeStyle(_ctx.alignComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script16.render = render17;
script16.__file = "src/components/va-card/VaCardActions.vue";
var VaCardContent = withConfigTransport(script$2);
var VaCardTitle = withConfigTransport(script$13);
var VaCardActions = withConfigTransport(script16);
var VaCard = withConfigTransport(script$3);

// node_modules/vuestic-ui/dist/esm/index32.js
var script17 = defineComponent({
  name: "VaImage",
  emits: ["loaded", "error"],
  props: {
    ratio: { type: Number, default: 1 },
    contain: { type: Boolean, default: false },
    src: { type: String, required: true },
    alt: { type: String, default: "" }
  },
  setup(props, { emit }) {
    const loading = ref(true);
    const loadingError = ref(false);
    const imageStyles = computed(() => ({
      objectFit: props.contain ? "contain" : "cover"
    }));
    const paddingStyles = computed(() => ({
      paddingBottom: `${1 / props.ratio * 100}%`
    }));
    const handleLoad = () => {
      loading.value = false;
      emit("loaded", props.src);
    };
    const handleError = (err) => {
      loadingError.value = true;
      loading.value = false;
      emit("error", err);
    };
    watch(() => props.src, () => {
      loading.value = true;
      loadingError.value = false;
    });
    return {
      loading,
      loadingError,
      imageStyles,
      paddingStyles,
      handleLoad,
      handleError
    };
  }
});
var _hoisted_110 = {
  class: "va-image",
  "aria-live": "polite"
};
var _hoisted_24 = {
  key: 0,
  class: "va-image__error"
};
var _hoisted_32 = { class: "va-image__img" };
var _hoisted_42 = ["src", "alt"];
var _hoisted_52 = { class: "va-image__overlay" };
var _hoisted_6 = {
  key: 1,
  class: "va-image__loader"
};
function render18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_110, [
    _ctx.loadingError ? (openBlock(), createElementBlock("div", _hoisted_24, [
      renderSlot(_ctx.$slots, "error")
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      style: normalizeStyle(_ctx.paddingStyles)
    }, null, 4),
    withDirectives(createBaseVNode("div", _hoisted_32, [
      createBaseVNode("img", {
        style: normalizeStyle(_ctx.imageStyles),
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
        onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
      }, null, 44, _hoisted_42)
    ], 512), [
      [vShow, !_ctx.loadingError && !_ctx.loading]
    ]),
    createBaseVNode("div", _hoisted_52, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.loading ? (openBlock(), createElementBlock("div", _hoisted_6, [
      renderSlot(_ctx.$slots, "loader")
    ])) : createCommentVNode("v-if", true)
  ]);
}
script17.render = render18;
script17.__file = "src/components/va-image/VaImage.vue";
var VaImage = withConfigTransport(script17);

// node_modules/vuestic-ui/dist/esm/index30.js
var script18 = defineComponent({
  name: "VaHover",
  props: {
    ...useStatefulProps,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return { onMouseEnter, onMouseLeave, valueComputed };
  }
});
function render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-hover",
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: _ctx.valueComputed })))
  ], 32);
}
script18.render = render19;
script18.__file = "src/components/va-hover/VaHover.vue";
var VaHover = withConfigTransport(script18);

// node_modules/vuestic-ui/dist/esm/index14.js
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    goTo,
    prev,
    next
  };
};
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  let direction = 1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      if (props.infinite) {
        currentSlide.value += 1;
        if (currentSlide.value >= props.items.length) {
          currentSlide.value = 0;
        }
      } else {
        if (currentSlide.value <= 0) {
          direction = 1;
        }
        if (currentSlide.value >= props.items.length - 1) {
          direction = -1;
        }
        currentSlide.value += direction;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation === null || animation === void 0 ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("dark"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};
var script19 = defineComponent({
  name: "VaCarousel",
  components: { VaImage, VaButton, VaHover },
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 1e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: false },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed: currentSlide } = useStateful(props, emit, 0);
    const { goTo, next, prev, doShowNextButton, doShowPrevButton } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el === null || el === void 0 ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => +index === currentSlide.value;
    return {
      doShowNextButton,
      doShowPrevButton,
      computedSlidesStyle,
      goTo: withPause(goTo),
      prev: withPause(prev),
      next: withPause(next),
      slides,
      isObjectSlides,
      isCurrentSlide,
      ...useCarouselColor()
    };
  }
});
var _hoisted_111 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_25 = { class: "va-carousel__content" };
var _hoisted_33 = ["aria-hidden", "aria-current", "aria-label"];
function render20(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      "va-carousel--vertical": _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.height }),
    role: "region",
    "aria-label": "carousel"
  }, [
    _ctx.$props.arrows ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.doShowPrevButton ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-carousel__arrow va-carousel__arrow--left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.prev && _ctx.prev(...args)),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prev && _ctx.prev(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "expand_less" : "chevron_left",
                "aria-label": "go previous slide"
              }, null, 8, ["color", "icon"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("v-if", true),
      _ctx.doShowNextButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-carousel__arrow va-carousel__arrow--right",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.next && _ctx.next(...args)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.next && _ctx.next(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "next-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "expand_more" : "chevron_right",
                "aria-label": "go next slide"
              }, null, 8, ["color", "icon"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("v-if", true)
    ], 64)) : createCommentVNode("v-if", true),
    _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_111, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
        return openBlock(), createElementBlock("div", mergeProps({
          class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === _ctx.modelValue }],
          key: index
        }, _ctx.indicatorTrigger === "hover" ? { onmouseover: () => _ctx.goTo(index) } : { onclick: () => _ctx.goTo(index) }), [
          renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
            createVNode(_component_va_hover, { stateful: "" }, {
              default: withCtx(({ hover }) => [
                createVNode(_component_va_button, {
                  "aria-label": `go slide #${index + 1}`,
                  round: "",
                  color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : hover ? _ctx.computedHoverColor : _ctx.computedColor
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(index + 1), 1)
                  ]),
                  _: 2
                }, 1032, ["aria-label", "color"])
              ]),
              _: 2
            }, 1024)
          ])
        ], 16);
      }), 128))
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("div", _hoisted_25, [
      createBaseVNode("div", {
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return openBlock(), createElementBlock("div", {
            class: "va-carousel__slide",
            key: item,
            style: normalizeStyle(_ctx.effect === "fade" ? { animation: _ctx.fadeKeyframe } : ""),
            role: "listitem",
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": `slide ${index + 1} of ${_ctx.slides.length}`
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : ""
              }, null, 8, ["src", "alt"])
            ])
          ], 12, _hoisted_33);
        }), 128))
      ], 4)
    ])
  ], 6);
}
script19.render = render20;
script19.__file = "src/components/va-carousel/VaCarousel.vue";
var VaCarousel = withConfigTransport(script19);

// node_modules/vuestic-ui/dist/esm/useKeyboardOnlyFocus.js
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked = true;
    },
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/esm/useSyncProp.js
function useSyncProp(propName, props, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props[propName] === void 0 ? statefulValue.value : props[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/esm/useFocus.js
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const isFocused = ref(false);
  const onFocus = (e2) => {
    isFocused.value = true;
    emit === null || emit === void 0 ? void 0 : emit("focus", e2);
  };
  const onBlur = (e2) => {
    isFocused.value = false;
    emit === null || emit === void 0 ? void 0 : emit("blur", e2);
  };
  const focus = () => {
    var _a;
    (_a = el === null || el === void 0 ? void 0 : el.value) === null || _a === void 0 ? void 0 : _a.focus();
  };
  const blur = () => {
    var _a;
    (_a = el === null || el === void 0 ? void 0 : el.value) === null || _a === void 0 ? void 0 : _a.blur();
  };
  if (el) {
    onMounted(() => {
      var _a, _b;
      if ((el === null || el === void 0 ? void 0 : el.value) instanceof HTMLElement) {
        (_a = el.value) === null || _a === void 0 ? void 0 : _a.addEventListener("focus", onFocus);
        (_b = el.value) === null || _b === void 0 ? void 0 : _b.addEventListener("blur", onBlur);
      }
    });
    onBeforeUnmount(() => {
      var _a, _b;
      if ((el === null || el === void 0 ? void 0 : el.value) instanceof HTMLElement) {
        (_a = el.value) === null || _a === void 0 ? void 0 : _a.removeEventListener("focus", onFocus);
        (_b = el.value) === null || _b === void 0 ? void 0 : _b.removeEventListener("blur", onBlur);
      }
    });
  }
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/esm/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/esm/index67.js
var baseGetTag3 = _baseGetTag;
var isArray3 = isArray_1;
var isObjectLike3 = isObjectLike_1;
var stringTag2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray3(value) && isObjectLike3(value) && baseGetTag3(value) == stringTag2;
}
var isString_1 = isString;
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString_1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  modelValue: { required: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages"];
var useValidation = (props, emit, reset, focus) => {
  const { isFocused, onFocus, onBlur } = useFocus();
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
  };
  const validate = () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    let error = false;
    let errorMessages = [];
    const rules = flatten_1(props.rules);
    normalizeValidationRules(rules, props.modelValue).forEach((validationResult) => {
      if (isString_1(validationResult)) {
        errorMessages = [...errorMessages, validationResult];
        error = true;
      } else if (validationResult === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  watch(isFocused, (newVal) => !newVal && validate());
  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
  const context = {
    resetValidation,
    focus,
    validate,
    reset,
    hasError: () => computedError.value
  };
  const form = inject(FormServiceKey, void 0);
  onMounted(() => {
    form === null || form === void 0 ? void 0 : form.onChildMounted(context);
  });
  onBeforeUnmount(() => {
    form === null || form === void 0 ? void 0 : form.onChildUnmounted(context);
  });
  return {
    computedError,
    computedErrorMessages,
    listeners: { onFocus, onBlur },
    validate,
    resetValidation
  };
};
var script20 = defineComponent({
  name: "VaMessageList",
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      messages: computed(() => {
        if (!props.modelValue) {
          return [];
        }
        if (!Array.isArray(props.modelValue)) {
          return [props.modelValue];
        }
        return props.modelValue.slice(0, props.limit);
      }),
      computedStyle: computed(() => props.color ? { color: getColor(props.color) } : {})
    };
  }
});
function render21(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.messages.length ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-message-list",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: "va-message-list__message"
      }, toDisplayString(message), 1);
    }), 128))
  ], 4)) : createCommentVNode("v-if", true);
}
script20.render = render21;
script20.__file = "src/components/va-input/components/VaMessageList/VaMessageList.vue";
var VaMessageList = withConfigTransport(script20);

// node_modules/vuestic-ui/dist/esm/useSelectable.js
var useSelectableProps = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: null, default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => emit("update:modelValue", false);
  const focus = () => {
    var _a;
    return (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
  };
  const { computedError, computedErrorMessages, validate } = useValidation(props, emit, reset, focus);
  const { valueComputed } = useStateful(props, emit);
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [label.value, container.value].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      computedError.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => !!props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a;
    if (modelIsArray.value) {
      return (_a = props.modelValue) === null || _a === void 0 ? void 0 : _a.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages
  };
};

// node_modules/vuestic-ui/dist/esm/VaMessageListWrapper.js
var script21 = defineComponent({
  name: "VaMessageListWrapper",
  components: { VaMessageList },
  props: {
    ...useValidationProps
  },
  setup(props) {
    return {
      messagesColor: computed(() => {
        if (props.error) {
          return "danger";
        }
        if (props.success) {
          return "success";
        }
        return "";
      }),
      messagesComputed: computed(() => props.error ? props.errorMessages : props.messages),
      errorLimit: computed(() => props.error ? Number(props.errorCount) : 99)
    };
  }
});
var _hoisted_112 = { class: "va-message-list-wrapper" };
function render22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", _hoisted_112, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      limit: _ctx.errorLimit,
      "model-value": _ctx.messagesComputed
    }, null, 8, ["color", "limit", "model-value"])
  ]);
}
script21.render = render22;
script21.__file = "src/components/va-input/components/VaMessageListWrapper.vue";

// node_modules/vuestic-ui/dist/esm/index15.js
var VaCheckboxValueType = [Boolean, Array, String, Object];
var script22 = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper: script21, VaIcon },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 }
  },
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { isChecked, computedError, isIndeterminate, computedErrorMessages, toggleSelection, onBlur, onFocus } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor();
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : "",
        padding: !props.label ? "" : props.leftLabel ? "0 0.5rem 0 0" : "0 0 0 0.5rem"
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const computedIconName = computed(() => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon);
    const uniqueId = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId.value);
    const computedName = computed(() => props.name || uniqueId.value);
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      ariaLabel: props.ariaLabel,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: isActive.value,
      "aria-invalid": !!computedErrorMessages.value.length,
      "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
    }));
    return {
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});
var _hoisted_113 = ["id", "indeterminate", "value", "checked"];
var _hoisted_26 = ["for"];
function render23(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_113),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            size: "20px",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_26)) : createCommentVNode("v-if", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
script22.render = render23;
script22.__file = "src/components/va-checkbox/VaCheckbox.vue";
var VaCheckbox = withConfigTransport(script22);

// node_modules/vuestic-ui/dist/esm/useHover.js
var getEl = (el) => el.$el !== void 0 ? el.$el : el;
function useHover(el) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  if (el) {
    watch(el, (n2, o2) => {
      if (n2) {
        const newEl = getEl(n2);
        newEl.addEventListener("mouseenter", onMouseEnter);
        newEl.addEventListener("mouseleave", onMouseLeave);
      }
      if (o2) {
        const oldEl = getEl(o2);
        oldEl.removeEventListener("mouseenter", onMouseEnter);
        oldEl.removeEventListener("mouseleave", onMouseLeave);
      }
    });
  }
  return {
    isHovered,
    onMouseEnter,
    onMouseLeave
  };
}

// node_modules/vuestic-ui/dist/esm/index16.js
var script23 = defineComponent({
  name: "VaChip",
  components: { VaIcon },
  emits: [...useStatefulEmits, "focus"],
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
    const size2 = {
      small: "0.875rem",
      medium: "1rem",
      large: "1.25rem"
    };
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return {
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => size2[props.size]),
      tabIndexComputed: computed(() => props.disabled ? -1 : 0),
      computedClass: computed(() => ({
        "va-chip--small": props.size === "small",
        "va-chip--large": props.size === "large",
        "va-chip--square": props.square,
        "va-chip--disabled": props.disabled
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props.outline || props.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    };
  }
});
var _hoisted_114 = { class: "va-chip__content" };
function render24(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    key: 0,
    class: normalizeClass(["va-chip", _ctx.computedClass]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle)
  }, {
    default: withCtx(() => [
      createBaseVNode("span", mergeProps({ class: "va-chip__inner" }, toHandlers(_ctx.keyboardFocusListeners), {
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
      }), [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-chip__icon",
          name: _ctx.icon,
          size: _ctx.iconSize
        }, null, 8, ["name", "size"])) : createCommentVNode("v-if", true),
        createBaseVNode("span", _hoisted_114, [
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.closeable ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          class: "va-chip__close-icon",
          name: "close",
          role: "button",
          "aria-label": "close",
          "aria-hidden": "false",
          tabindex: _ctx.tabIndexComputed,
          size: _ctx.iconSize,
          onClick: withModifiers(_ctx.close, ["stop"]),
          onKeydown: [
            withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
          ]
        }, null, 8, ["tabindex", "size", "onClick", "onKeydown"])) : createCommentVNode("v-if", true)
      ], 16)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("v-if", true);
}
script23.render = render24;
script23.__file = "src/components/va-chip/VaChip.vue";
var VaChip = withConfigTransport(script23);

// node_modules/vuestic-ui/dist/esm/index17.js
var script24 = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon
  },
  props: {
    modelValue: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    solid: { type: Boolean, default: false },
    color: { type: String, default: "background" },
    textColor: { type: String, default: "" },
    colorAll: { type: Boolean, default: false }
  },
  emits: ["focus", "update:modelValue"],
  setup(props, { emit, slots }) {
    const body = shallowRef();
    const [computedModelValue] = useSyncProp("modelValue", props, emit, false);
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { accordionProps, toggle } = useAccordionItem(computedModelValue);
    const { textColorComputed } = useTextColor();
    const getTextNodeHeight = (textNode) => {
      const range = document.createRange();
      range.selectNodeContents(textNode);
      const rect = range.getBoundingClientRect();
      return rect.bottom - rect.top;
    };
    const getNodeHeight = (node) => {
      if (node.nodeName === "#text") {
        return getTextNodeHeight(node);
      }
      if (node.nodeName === "#comment") {
        return 0;
      }
      return node.clientHeight;
    };
    const height = computed(() => {
      if (!computedModelValue.value || !body.value) {
        return 0;
      }
      const nodes = Array.from(body.value.childNodes);
      return nodes.reduce((result, node) => result + getNodeHeight(node), 0);
    });
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const getBackground = () => {
      return props.color && props.colorAll ? getHoverColor2(getColor(props.color)) : "";
    };
    const uniqueId = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    return {
      body,
      height,
      toggle,
      computedModelValue,
      hasKeyboardFocus,
      keyboardFocusListeners,
      textColorComputed,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      computedClasses: computed(() => ({
        "va-collapse--expanded": computedModelValue.value,
        "va-collapse--disabled": props.disabled,
        "va-collapse--solid": props.solid,
        "va-collapse--active": props.solid && computedModelValue.value,
        "va-collapse--popout": accordionProps.value.popout && computedModelValue.value,
        "va-collapse--inset": accordionProps.value.inset && computedModelValue.value
      })),
      headerStyle: computed(() => ({
        paddingLeft: props.icon && 0,
        color: textColorComputed.value,
        backgroundColor: props.color ? getColor(props.color) : ""
      })),
      contentStyle: computed(() => {
        var _a;
        const hasContent = computedModelValue.value && !!((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)[0]);
        return {
          visibility: hasContent ? "visible" : "hidden",
          height: `${height.value}px`,
          transitionDuration: getTransition(),
          background: hasContent ? getBackground() : ""
        };
      })
    };
  }
});
var _hoisted_115 = { class: "va-collapse__header__text" };
var _hoisted_27 = ["id", "aria-labelledby"];
function render25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-collapse", _ctx.computedClasses])
  }, [
    createBaseVNode("div", mergeProps({ class: "va-collapse__header-wrapper" }, toHandlers(_ctx.keyboardFocusListeners), {
      onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggle && _ctx.toggle(...args)),
      onKeydown: [
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["enter"])),
        _cache[3] || (_cache[3] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["space"]))
      ]
    }), [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
        value: _ctx.computedModelValue,
        hasKeyboardFocus: _ctx.hasKeyboardFocus,
        bind: _ctx.headerAttributes,
        attributes: _ctx.headerAttributes
      })), () => [
        createBaseVNode("div", mergeProps(_ctx.headerAttributes, {
          class: "va-collapse__header",
          style: _ctx.headerStyle
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-collapse__header__icon",
            name: _ctx.icon,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])) : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_115, toDisplayString(_ctx.header), 1),
          createVNode(_component_va_icon, {
            class: "va-collapse__header__icon",
            name: _ctx.computedModelValue ? "expand_less" : "expand_more",
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])
        ], 16)
      ])
    ], 16),
    createBaseVNode("div", {
      ref: "body",
      class: "va-collapse__body",
      role: "region",
      style: normalizeStyle(_ctx.contentStyle),
      id: _ctx.panelIdComputed,
      "aria-labelledby": _ctx.headerIdComputed
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 12, _hoisted_27)
  ], 2);
}
script24.render = render25;
script24.__file = "src/components/va-collapse/VaCollapse.vue";
var VaCollapse = withConfigTransport(script24);

// node_modules/vuestic-ui/dist/esm/index18.js
var script25 = defineComponent({
  name: "VaColorIndicator",
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      borderRadius: props.square ? "0px" : "50%",
      backgroundColor: colorComputed.value
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--hoverable": valueComputed.value !== void 0
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return {
      valueComputed,
      computedStyle,
      computedClass,
      toggleModelValue
    };
  }
});
function render26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-color-indicator", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args)),
    onKeydown: [
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["enter"])),
      _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["space"]))
    ]
  }, [
    createBaseVNode("div", {
      class: "va-color-indicator__core",
      style: normalizeStyle(_ctx.computedStyle)
    }, null, 4)
  ], 38);
}
script25.render = render26;
script25.__file = "src/components/va-color-indicator/VaColorIndicator.vue";
var VaColorIndicator = withConfigTransport(script25);

// node_modules/vuestic-ui/dist/esm/child-props.js
function normalizeProps2(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m2) => mergeProps2(to, m2, optionsType));
  const props = normalizeProps2(from[optionsType]);
  for (const key2 in props) {
    to[key2] = props[key2];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  var _a, _b;
  const mixins = (_a = options.mixins) !== null && _a !== void 0 ? _a : [];
  const extendsOptions = (_b = options.extends) !== null && _b !== void 0 ? _b : [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i2 = 0; i2 < mixins.length; i2++) {
    mergeProps2(result, mixins[i2], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};
var filterComponentProps = (propsValues, childProps) => {
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = propsValues[propName];
      return acc;
    }, {});
  });
};
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/esm/useForm.js
var useFormProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useForm = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick_1(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/cleave.js/dist/cleave-esm.js
var commonjsGlobal2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix2, signBeforePrefix, tailPrefix, delimiter) {
  var owner = this;
  owner.numeralDecimalMark = numeralDecimalMark || ".";
  owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
  owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
  owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
  owner.numeralPositiveOnly = !!numeralPositiveOnly;
  owner.stripLeadingZeroes = stripLeadingZeroes !== false;
  owner.prefix = prefix2 || prefix2 === "" ? prefix2 : "";
  owner.signBeforePrefix = !!signBeforePrefix;
  owner.tailPrefix = !!tailPrefix;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
};
NumeralFormatter.groupStyle = {
  thousand: "thousand",
  lakh: "lakh",
  wan: "wan",
  none: "none"
};
NumeralFormatter.prototype = {
  getRawValue: function(value) {
    return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
  },
  format: function(value) {
    var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
    value = value.replace(/[A-Za-z]/g, "").replace(owner.numeralDecimalMark, "M").replace(/[^\dM-]/g, "").replace(/^\-/, "N").replace(/\-/g, "").replace("N", owner.numeralPositiveOnly ? "" : "-").replace("M", owner.numeralDecimalMark);
    if (owner.stripLeadingZeroes) {
      value = value.replace(/^(-)?0+(?=\d)/, "$1");
    }
    partSign = value.slice(0, 1) === "-" ? "-" : "";
    if (typeof owner.prefix != "undefined") {
      if (owner.signBeforePrefix) {
        partSignAndPrefix = partSign + owner.prefix;
      } else {
        partSignAndPrefix = owner.prefix + partSign;
      }
    } else {
      partSignAndPrefix = partSign;
    }
    partInteger = value;
    if (value.indexOf(owner.numeralDecimalMark) >= 0) {
      parts = value.split(owner.numeralDecimalMark);
      partInteger = parts[0];
      partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
    }
    if (partSign === "-") {
      partInteger = partInteger.slice(1);
    }
    if (owner.numeralIntegerScale > 0) {
      partInteger = partInteger.slice(0, owner.numeralIntegerScale);
    }
    switch (owner.numeralThousandsGroupStyle) {
      case NumeralFormatter.groupStyle.lakh:
        partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.wan:
        partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.thousand:
        partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
        break;
    }
    if (owner.tailPrefix) {
      return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
    }
    return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
  }
};
var NumeralFormatter_1 = NumeralFormatter;
var DateFormatter = function(datePattern, dateMin, dateMax) {
  var owner = this;
  owner.date = [];
  owner.blocks = [];
  owner.datePattern = datePattern;
  owner.dateMin = dateMin.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMin.length === 2)
    owner.dateMin.unshift(0);
  owner.dateMax = dateMax.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMax.length === 2)
    owner.dateMax.unshift(0);
  owner.initBlocks();
};
DateFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.datePattern.forEach(function(value) {
      if (value === "Y") {
        owner.blocks.push(4);
      } else {
        owner.blocks.push(2);
      }
    });
  },
  getISOFormatDate: function() {
    var owner = this, date = owner.date;
    return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getValidatedDate: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.datePattern[index]) {
          case "d":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 3) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 31) {
              sub = "31";
            }
            break;
          case "m":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 1) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 12) {
              sub = "12";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedDateString(result);
  },
  getFixedDateString: function(value) {
    var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
    if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
      dayStartIndex = datePattern[0] === "d" ? 0 : 2;
      monthStartIndex = 2 - dayStartIndex;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      date = this.getFixedDate(day, month, 0);
    }
    if (value.length === 8) {
      datePattern.forEach(function(type, index) {
        switch (type) {
          case "d":
            dayIndex = index;
            break;
          case "m":
            monthIndex = index;
            break;
          default:
            yearIndex = index;
            break;
        }
      });
      yearStartIndex = yearIndex * 2;
      dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
      monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = this.getFixedDate(day, month, year);
    }
    if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 2;
      yearStartIndex = 2 - monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
      date = [0, month, year];
    }
    if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 4;
      yearStartIndex = 2 - 0.5 * monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = [0, month, year];
    }
    date = owner.getRangeFixedDate(date);
    owner.date = date;
    var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
      switch (current) {
        case "d":
          return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
        case "m":
          return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
        case "y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
        case "Y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
      }
    }, "");
    return result;
  },
  getRangeFixedDate: function(date) {
    var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
    if (!date.length || dateMin.length < 3 && dateMax.length < 3)
      return date;
    if (datePattern.find(function(x2) {
      return x2.toLowerCase() === "y";
    }) && date[2] === 0)
      return date;
    if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0])))
      return dateMax;
    if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0])))
      return dateMin;
    return date;
  },
  getFixedDate: function(day, month, year) {
    day = Math.min(day, 31);
    month = Math.min(month, 12);
    year = parseInt(year || 0, 10);
    if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {
      day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
    }
    return [day, month, year];
  },
  isLeapYear: function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  },
  addLeadingZeroForYear: function(number, fullYearMode) {
    if (fullYearMode) {
      return (number < 10 ? "000" : number < 100 ? "00" : number < 1e3 ? "0" : "") + number;
    }
    return (number < 10 ? "0" : "") + number;
  }
};
var DateFormatter_1 = DateFormatter;
var TimeFormatter = function(timePattern, timeFormat) {
  var owner = this;
  owner.time = [];
  owner.blocks = [];
  owner.timePattern = timePattern;
  owner.timeFormat = timeFormat;
  owner.initBlocks();
};
TimeFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.timePattern.forEach(function() {
      owner.blocks.push(2);
    });
  },
  getISOFormatTime: function() {
    var owner = this, time = owner.time;
    return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getTimeFormatOptions: function() {
    var owner = this;
    if (String(owner.timeFormat) === "12") {
      return {
        maxHourFirstDigit: 1,
        maxHours: 12,
        maxMinutesFirstDigit: 5,
        maxMinutes: 60
      };
    }
    return {
      maxHourFirstDigit: 2,
      maxHours: 23,
      maxMinutesFirstDigit: 5,
      maxMinutes: 60
    };
  },
  getValidatedTime: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    var timeFormatOptions = owner.getTimeFormatOptions();
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.timePattern[index]) {
          case "h":
            if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
              sub = timeFormatOptions.maxHours + "";
            }
            break;
          case "m":
          case "s":
            if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
              sub = timeFormatOptions.maxMinutes + "";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedTimeString(result);
  },
  getFixedTimeString: function(value) {
    var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
    if (value.length === 6) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "s":
            secondIndex = index * 2;
            break;
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      secondStartIndex = secondIndex;
      second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      second = 0;
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    owner.time = time;
    return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
      switch (current) {
        case "s":
          return previous + owner.addLeadingZero(time[2]);
        case "m":
          return previous + owner.addLeadingZero(time[1]);
        case "h":
          return previous + owner.addLeadingZero(time[0]);
      }
    }, "");
  },
  getFixedTime: function(hour, minute, second) {
    second = Math.min(parseInt(second || 0, 10), 60);
    minute = Math.min(minute, 60);
    hour = Math.min(hour, 60);
    return [hour, minute, second];
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  }
};
var TimeFormatter_1 = TimeFormatter;
var PhoneFormatter = function(formatter, delimiter) {
  var owner = this;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
  owner.formatter = formatter;
};
PhoneFormatter.prototype = {
  setFormatter: function(formatter) {
    this.formatter = formatter;
  },
  format: function(phoneNumber) {
    var owner = this;
    owner.formatter.clear();
    phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
    phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
    phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
    var result = "", current, validated = false;
    for (var i2 = 0, iMax = phoneNumber.length; i2 < iMax; i2++) {
      current = owner.formatter.inputDigit(phoneNumber.charAt(i2));
      if (/[\s()-]/g.test(current)) {
        result = current;
        validated = true;
      } else {
        if (!validated) {
          result = current;
        }
      }
    }
    result = result.replace(/[()]/g, "");
    result = result.replace(/[\s-]/g, owner.delimiter);
    return result;
  }
};
var PhoneFormatter_1 = PhoneFormatter;
var CreditCardDetector = {
  blocks: {
    uatp: [4, 5, 6],
    amex: [4, 6, 5],
    diners: [4, 6, 4],
    discover: [4, 4, 4, 4],
    mastercard: [4, 4, 4, 4],
    dankort: [4, 4, 4, 4],
    instapayment: [4, 4, 4, 4],
    jcb15: [4, 6, 5],
    jcb: [4, 4, 4, 4],
    maestro: [4, 4, 4, 4],
    visa: [4, 4, 4, 4],
    mir: [4, 4, 4, 4],
    unionPay: [4, 4, 4, 4],
    general: [4, 4, 4, 4]
  },
  re: {
    uatp: /^(?!1800)1\d{0,14}/,
    amex: /^3[47]\d{0,13}/,
    discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
    diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
    mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
    dankort: /^(5019|4175|4571)\d{0,12}/,
    instapayment: /^63[7-9]\d{0,13}/,
    jcb15: /^(?:2131|1800)\d{0,11}/,
    jcb: /^(?:35\d{0,2})\d{0,12}/,
    maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
    mir: /^220[0-4]\d{0,12}/,
    visa: /^4\d{0,15}/,
    unionPay: /^(62|81)\d{0,14}/
  },
  getStrictBlocks: function(block) {
    var total = block.reduce(function(prev, current) {
      return prev + current;
    }, 0);
    return block.concat(19 - total);
  },
  getInfo: function(value, strictMode) {
    var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
    strictMode = !!strictMode;
    for (var key2 in re) {
      if (re[key2].test(value)) {
        var matchedBlocks = blocks[key2];
        return {
          type: key2,
          blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
        };
      }
    }
    return {
      type: "unknown",
      blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
    };
  }
};
var CreditCardDetector_1 = CreditCardDetector;
var Util = {
  noop: function() {
  },
  strip: function(value, re) {
    return value.replace(re, "");
  },
  getPostDelimiter: function(value, delimiter, delimiters) {
    if (delimiters.length === 0) {
      return value.slice(-delimiter.length) === delimiter ? delimiter : "";
    }
    var matchedDelimiter = "";
    delimiters.forEach(function(current) {
      if (value.slice(-current.length) === current) {
        matchedDelimiter = current;
      }
    });
    return matchedDelimiter;
  },
  getDelimiterREByDelimiter: function(delimiter) {
    return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
  },
  getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    if (oldValue.length === prevPos) {
      return newValue.length;
    }
    return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
  },
  getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    var oldRawValue, newRawValue, lengthOffset;
    oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
    newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
    lengthOffset = oldRawValue.length - newRawValue.length;
    return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
  },
  stripDelimiters: function(value, delimiter, delimiters) {
    var owner = this;
    if (delimiters.length === 0) {
      var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
      return value.replace(delimiterRE, "");
    }
    delimiters.forEach(function(current) {
      current.split("").forEach(function(letter) {
        value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
      });
    });
    return value;
  },
  headStr: function(str, length) {
    return str.slice(0, length);
  },
  getMaxLength: function(blocks) {
    return blocks.reduce(function(previous, current) {
      return previous + current;
    }, 0);
  },
  getPrefixStrippedValue: function(value, prefix2, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
    if (prefixLength === 0) {
      return value;
    }
    if (value === prefix2 && value !== "") {
      return "";
    }
    if (signBeforePrefix && value.slice(0, 1) == "-") {
      var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
      return "-" + this.getPrefixStrippedValue(value.slice(1), prefix2, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
    }
    if (prevResult.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    } else if (prevResult.slice(-prefixLength) !== prefix2 && tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    }
    var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
    if (value.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      return prevValue.slice(prefixLength);
    } else if (value.slice(-prefixLength) !== prefix2 && tailPrefix) {
      return prevValue.slice(0, -prefixLength - 1);
    }
    return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
  },
  getFirstDiffIndex: function(prev, current) {
    var index = 0;
    while (prev.charAt(index) === current.charAt(index)) {
      if (prev.charAt(index++) === "") {
        return -1;
      }
    }
    return index;
  },
  getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
    var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
    if (blocksLength === 0) {
      return value;
    }
    blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), rest = value.slice(length);
        if (multipleDelimiters) {
          currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
        } else {
          currentDelimiter = delimiter;
        }
        if (delimiterLazyShow) {
          if (index > 0) {
            result += currentDelimiter;
          }
          result += sub;
        } else {
          result += sub;
          if (sub.length === length && index < blocksLength - 1) {
            result += currentDelimiter;
          }
        }
        value = rest;
      }
    });
    return result;
  },
  fixPrefixCursor: function(el, prefix2, delimiter, delimiters) {
    if (!el) {
      return;
    }
    var val = el.value, appendix = delimiter || (delimiters[0] || " ");
    if (!el.setSelectionRange || !prefix2 || prefix2.length + appendix.length <= val.length) {
      return;
    }
    var len = val.length * 2;
    setTimeout(function() {
      el.setSelectionRange(len, len);
    }, 1);
  },
  checkFullSelection: function(value) {
    try {
      var selection = window.getSelection() || document.getSelection() || {};
      return selection.toString().length === value.length;
    } catch (ex) {
    }
    return false;
  },
  setSelection: function(element, position, doc) {
    if (element !== this.getActiveElement(doc)) {
      return;
    }
    if (element && element.value.length <= position) {
      return;
    }
    if (element.createTextRange) {
      var range = element.createTextRange();
      range.move("character", position);
      range.select();
    } else {
      try {
        element.setSelectionRange(position, position);
      } catch (e2) {
        console.warn("The input element type does not support selection");
      }
    }
  },
  getActiveElement: function(parent2) {
    var activeElement = parent2.activeElement;
    if (activeElement && activeElement.shadowRoot) {
      return this.getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  },
  isAndroid: function() {
    return navigator && /android/i.test(navigator.userAgent);
  },
  isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
    if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
      return false;
    }
    return currentInputValue === lastInputValue.slice(0, -1);
  }
};
var Util_1 = Util;
var DefaultProperties = {
  assign: function(target, opts) {
    target = target || {};
    opts = opts || {};
    target.creditCard = !!opts.creditCard;
    target.creditCardStrictMode = !!opts.creditCardStrictMode;
    target.creditCardType = "";
    target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {
    };
    target.phone = !!opts.phone;
    target.phoneRegionCode = opts.phoneRegionCode || "AU";
    target.phoneFormatter = {};
    target.time = !!opts.time;
    target.timePattern = opts.timePattern || ["h", "m", "s"];
    target.timeFormat = opts.timeFormat || "24";
    target.timeFormatter = {};
    target.date = !!opts.date;
    target.datePattern = opts.datePattern || ["d", "m", "Y"];
    target.dateMin = opts.dateMin || "";
    target.dateMax = opts.dateMax || "";
    target.dateFormatter = {};
    target.numeral = !!opts.numeral;
    target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
    target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
    target.numeralDecimalMark = opts.numeralDecimalMark || ".";
    target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
    target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
    target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
    target.signBeforePrefix = !!opts.signBeforePrefix;
    target.tailPrefix = !!opts.tailPrefix;
    target.swapHiddenInput = !!opts.swapHiddenInput;
    target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
    target.uppercase = !!opts.uppercase;
    target.lowercase = !!opts.lowercase;
    target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
    target.noImmediatePrefix = !!opts.noImmediatePrefix;
    target.prefixLength = target.prefix.length;
    target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
    target.copyDelimiter = !!opts.copyDelimiter;
    target.initValue = opts.initValue !== void 0 && opts.initValue !== null ? opts.initValue.toString() : "";
    target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
    target.delimiterLength = target.delimiter.length;
    target.delimiterLazyShow = !!opts.delimiterLazyShow;
    target.delimiters = opts.delimiters || [];
    target.blocks = opts.blocks || [];
    target.blocksLength = target.blocks.length;
    target.root = typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window;
    target.document = opts.document || target.root.document;
    target.maxLength = 0;
    target.backspace = false;
    target.result = "";
    target.onValueChanged = opts.onValueChanged || function() {
    };
    return target;
  }
};
var DefaultProperties_1 = DefaultProperties;
var Cleave = function(element, opts) {
  var owner = this;
  var hasMultipleElements = false;
  if (typeof element === "string") {
    owner.element = document.querySelector(element);
    hasMultipleElements = document.querySelectorAll(element).length > 1;
  } else {
    if (typeof element.length !== "undefined" && element.length > 0) {
      owner.element = element[0];
      hasMultipleElements = element.length > 1;
    } else {
      owner.element = element;
    }
  }
  if (!owner.element) {
    throw new Error("[cleave.js] Please check the element");
  }
  if (hasMultipleElements) {
    try {
      console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
    } catch (e2) {
    }
  }
  opts.initValue = owner.element.value;
  owner.properties = Cleave.DefaultProperties.assign({}, opts);
  owner.init();
};
Cleave.prototype = {
  init: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
      owner.onInput(pps.initValue);
      return;
    }
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    owner.isAndroid = Cleave.Util.isAndroid();
    owner.lastInputValue = "";
    owner.isBackward = "";
    owner.onChangeListener = owner.onChange.bind(owner);
    owner.onKeyDownListener = owner.onKeyDown.bind(owner);
    owner.onFocusListener = owner.onFocus.bind(owner);
    owner.onCutListener = owner.onCut.bind(owner);
    owner.onCopyListener = owner.onCopy.bind(owner);
    owner.initSwapHiddenInput();
    owner.element.addEventListener("input", owner.onChangeListener);
    owner.element.addEventListener("keydown", owner.onKeyDownListener);
    owner.element.addEventListener("focus", owner.onFocusListener);
    owner.element.addEventListener("cut", owner.onCutListener);
    owner.element.addEventListener("copy", owner.onCopyListener);
    owner.initPhoneFormatter();
    owner.initDateFormatter();
    owner.initTimeFormatter();
    owner.initNumeralFormatter();
    if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {
      owner.onInput(pps.initValue);
    }
  },
  initSwapHiddenInput: function() {
    var owner = this, pps = owner.properties;
    if (!pps.swapHiddenInput)
      return;
    var inputFormatter = owner.element.cloneNode(true);
    owner.element.parentNode.insertBefore(inputFormatter, owner.element);
    owner.elementSwapHidden = owner.element;
    owner.elementSwapHidden.type = "hidden";
    owner.element = inputFormatter;
    owner.element.id = "";
  },
  initNumeralFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral) {
      return;
    }
    pps.numeralFormatter = new Cleave.NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);
  },
  initTimeFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.time) {
      return;
    }
    pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
    pps.blocks = pps.timeFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initDateFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.date) {
      return;
    }
    pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
    pps.blocks = pps.dateFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initPhoneFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.phone) {
      return;
    }
    try {
      pps.phoneFormatter = new Cleave.PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);
    } catch (ex) {
      throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
    }
  },
  onKeyDown: function(event) {
    var owner = this, charCode = event.which || event.keyCode;
    owner.lastInputValue = owner.element.value;
    owner.isBackward = charCode === 8;
  },
  onChange: function(event) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
    var postDelimiter = Util2.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
    if (owner.isBackward && postDelimiter) {
      pps.postDelimiterBackspace = postDelimiter;
    } else {
      pps.postDelimiterBackspace = false;
    }
    this.onInput(this.element.value);
  },
  onFocus: function() {
    var owner = this, pps = owner.properties;
    owner.lastInputValue = owner.element.value;
    if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {
      this.onInput(pps.prefix);
    }
    Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
  },
  onCut: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
    this.onInput("");
  },
  onCopy: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
  },
  copyClipboardData: function(e2) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, inputValue = owner.element.value, textToCopy = "";
    if (!pps.copyDelimiter) {
      textToCopy = Util2.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
    } else {
      textToCopy = inputValue;
    }
    try {
      if (e2.clipboardData) {
        e2.clipboardData.setData("Text", textToCopy);
      } else {
        window.clipboardData.setData("Text", textToCopy);
      }
      e2.preventDefault();
    } catch (ex) {
    }
  },
  onInput: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    var postDelimiterAfter = Util2.getPostDelimiter(value, pps.delimiter, pps.delimiters);
    if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
      value = Util2.headStr(value, value.length - pps.postDelimiterBackspace.length);
    }
    if (pps.phone) {
      if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
        pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
      } else {
        pps.result = pps.phoneFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.numeral) {
      if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
        pps.result = "";
      } else {
        pps.result = pps.numeralFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.date) {
      value = pps.dateFormatter.getValidatedDate(value);
    }
    if (pps.time) {
      value = pps.timeFormatter.getValidatedTime(value);
    }
    value = Util2.stripDelimiters(value, pps.delimiter, pps.delimiters);
    value = Util2.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    value = pps.numericOnly ? Util2.strip(value, /[^\d]/g) : value;
    value = pps.uppercase ? value.toUpperCase() : value;
    value = pps.lowercase ? value.toLowerCase() : value;
    if (pps.prefix) {
      if (pps.tailPrefix) {
        value = value + pps.prefix;
      } else {
        value = pps.prefix + value;
      }
      if (pps.blocksLength === 0) {
        pps.result = value;
        owner.updateValueState();
        return;
      }
    }
    if (pps.creditCard) {
      owner.updateCreditCardPropsByValue(value);
    }
    value = Util2.headStr(value, pps.maxLength);
    pps.result = Util2.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);
    owner.updateValueState();
  },
  updateCreditCardPropsByValue: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, creditCardInfo;
    if (Util2.headStr(pps.result, 4) === Util2.headStr(value, 4)) {
      return;
    }
    creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
    pps.blocks = creditCardInfo.blocks;
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Util2.getMaxLength(pps.blocks);
    if (pps.creditCardType !== creditCardInfo.type) {
      pps.creditCardType = creditCardInfo.type;
      pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
    }
  },
  updateValueState: function() {
    var owner = this, Util2 = Cleave.Util, pps = owner.properties;
    if (!owner.element) {
      return;
    }
    var endPos = owner.element.selectionEnd;
    var oldValue = owner.element.value;
    var newValue = pps.result;
    endPos = Util2.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
    if (owner.isAndroid) {
      window.setTimeout(function() {
        owner.element.value = newValue;
        Util2.setSelection(owner.element, endPos, pps.document, false);
        owner.callOnValueChanged();
      }, 1);
      return;
    }
    owner.element.value = newValue;
    if (pps.swapHiddenInput)
      owner.elementSwapHidden.value = owner.getRawValue();
    Util2.setSelection(owner.element, endPos, pps.document, false);
    owner.callOnValueChanged();
  },
  callOnValueChanged: function() {
    var owner = this, pps = owner.properties;
    pps.onValueChanged.call(owner, {
      target: {
        name: owner.element.name,
        value: pps.result,
        rawValue: owner.getRawValue()
      }
    });
  },
  setPhoneRegionCode: function(phoneRegionCode) {
    var owner = this, pps = owner.properties;
    pps.phoneRegionCode = phoneRegionCode;
    owner.initPhoneFormatter();
    owner.onChange();
  },
  setRawValue: function(value) {
    var owner = this, pps = owner.properties;
    value = value !== void 0 && value !== null ? value.toString() : "";
    if (pps.numeral) {
      value = value.replace(".", pps.numeralDecimalMark);
    }
    pps.postDelimiterBackspace = false;
    owner.element.value = value;
    owner.onInput(value);
  },
  getRawValue: function() {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, rawValue = owner.element.value;
    if (pps.rawValueTrimPrefix) {
      rawValue = Util2.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    }
    if (pps.numeral) {
      rawValue = pps.numeralFormatter.getRawValue(rawValue);
    } else {
      rawValue = Util2.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
    }
    return rawValue;
  },
  getISOFormatDate: function() {
    var owner = this, pps = owner.properties;
    return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
  },
  getISOFormatTime: function() {
    var owner = this, pps = owner.properties;
    return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
  },
  getFormattedValue: function() {
    return this.element.value;
  },
  destroy: function() {
    var owner = this;
    owner.element.removeEventListener("input", owner.onChangeListener);
    owner.element.removeEventListener("keydown", owner.onKeyDownListener);
    owner.element.removeEventListener("focus", owner.onFocusListener);
    owner.element.removeEventListener("cut", owner.onCutListener);
    owner.element.removeEventListener("copy", owner.onCopyListener);
  },
  toString: function() {
    return "[Cleave Object]";
  }
};
Cleave.NumeralFormatter = NumeralFormatter_1;
Cleave.DateFormatter = DateFormatter_1;
Cleave.TimeFormatter = TimeFormatter_1;
Cleave.PhoneFormatter = PhoneFormatter_1;
Cleave.CreditCardDetector = CreditCardDetector_1;
Cleave.Util = Util_1;
Cleave.DefaultProperties = DefaultProperties_1;
(typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window)["Cleave"] = Cleave;
var Cleave_1 = Cleave;
var cleave_esm_default = Cleave_1;

// node_modules/vuestic-ui/dist/esm/useCSSVariables.js
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).map(([key2, value]) => ({ [`--${prefix2}-${kebabCase_1(key2)}`]: value })));
};

// node_modules/vuestic-ui/dist/esm/VaInputWrapper.js
var script26 = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList, VaIcon },
  props: {
    ...useFormProps,
    ...useValidationProps,
    counterValue: { type: Number, default: void 0 },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    error: { type: Boolean, default: false },
    success: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
  ],
  setup(props) {
    const { getColor } = useColors();
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick_1(props, ["outline", "bordered", "success", "focused", "error", "disabled", "readonly"]),
      labeled: !!props.label,
      solid: !props.outline && !props.bordered
    }));
    const wrapperStyle = useCSSVariables("va-input-wrapper", () => ({
      color: colorComputed.value
    }));
    const colorComputed = computed(() => getColor(props.color));
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const hasMessages = computed(() => {
      var _a;
      return Boolean(typeof messagesComputed.value === "string" ? messagesComputed.value : (_a = messagesComputed.value) === null || _a === void 0 ? void 0 : _a.length);
    });
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => props.counterValue !== void 0);
    const counterComputed = computed(() => props.maxLength !== void 0 ? `${props.counterValue}/${props.maxLength}` : props.counterValue);
    return {
      wrapperClass,
      wrapperStyle,
      isCounterVisible,
      counterComputed,
      colorComputed,
      messagesColor,
      messagesComputed,
      hasMessages,
      errorLimit
    };
  }
});
var _hoisted_116 = { class: "va-input-wrapper__container" };
var _hoisted_28 = { class: "va-input-wrapper__field" };
var _hoisted_34 = { class: "va-input-wrapper__text" };
var _hoisted_43 = {
  key: 0,
  class: "va-input-wrapper__required-mark"
};
var _hoisted_53 = {
  key: 0,
  class: "va-input-wrapper__bottom"
};
var _hoisted_62 = { class: "va-input-wrapper__bottom-counter" };
function render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    style: normalizeStyle(_ctx.wrapperStyle),
    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("div", _hoisted_116, [
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-input-wrapper__prepend-inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
      }, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_28, [
        _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-input-wrapper__prepend-inner",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "prependInner")
        ])) : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_34, [
          _ctx.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            "aria-hidden": "true",
            class: "va-input-wrapper__label",
            style: normalizeStyle({ color: _ctx.colorComputed })
          }, [
            createTextVNode(toDisplayString(_ctx.label) + " ", 1),
            _ctx.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_43, " * ")) : createCommentVNode("v-if", true)
          ], 4)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          color: "success",
          name: "check_circle",
          size: "small"
        })) : createCommentVNode("v-if", true),
        _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
          key: 2,
          color: "danger",
          name: "warning",
          size: "small"
        })) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "icon"),
        _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "va-input-wrapper__append-inner",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click-append-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "appendInner")
        ])) : createCommentVNode("v-if", true)
      ]),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-input-wrapper__append-inner",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append"))
      }, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("v-if", true)
    ]),
    _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", _hoisted_53, [
      renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.$props.counterValue, maxLength: _ctx.$props.maxLength })), () => [
        createBaseVNode("div", _hoisted_62, toDisplayString(_ctx.counterComputed), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ messages: _ctx.messagesComputed, errorLimit: _ctx.errorLimit, color: _ctx.messagesColor })), () => [
      _ctx.hasMessages ? (openBlock(), createBlock(_component_va_message_list, {
        key: 0,
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit
      }, null, 8, ["color", "model-value", "limit"])) : createCommentVNode("v-if", true)
    ])
  ], 6);
}
script26.render = render27;
script26.__file = "src/components/va-input/components/VaInputWrapper.vue";

// node_modules/vuestic-ui/dist/esm/VaInput.js
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "highlight_off" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused === null || isFocused === void 0 ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError === null || hasError === void 0 ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "small"
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : void 0;
  });
  onUpdated(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : void 0;
  });
  onBeforeUnmount(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) !== null && _a !== void 0 ? _a : void 0;
  });
  return currentEl;
};
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el);
  let previouslyFocusedElement = null;
  return computed({
    get() {
      var _a;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused = (_a = current.value) === null || _a === void 0 ? void 0 : _a.contains(focused.value);
      if (isFocused) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused;
    },
    set(value) {
      const target = previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : current.value;
      if (value) {
        target === null || target === void 0 ? void 0 : target.focus();
      } else {
        target === null || target === void 0 ? void 0 : target.blur();
      }
    }
  });
};
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true },
  modelValue: { type: String }
};
var useCleave = (element, props, emit) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask] } : {};
    }
    return { ...mask };
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, getMask(props.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return props.modelValue;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props.mask !== "string" && !Object.keys(props.mask).length) {
      emit("update:modelValue", value);
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props.returnRaw) {
        emit("update:modelValue", cleave.value.getRawValue());
        return;
      }
    }
    emit("update:modelValue", value);
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important';
`;
var SIZING_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
var getNodeHeightStyles = (node) => {
  const style = window.getComputedStyle(node);
  return {
    boxSizing: style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing"),
    padding: parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top")),
    border: parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width")),
    styles: SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";") + ";",
    lineHeight: parseInt(style.getPropertyValue("line-height"))
  };
};
var textarea = null;
var createHiddenTextarea = (original, styles) => {
  if (!textarea) {
    textarea = document.createElement("textarea");
  }
  textarea.setAttribute("style", styles + HIDDEN_TEXTAREA_STYLE);
  textarea.value = original.value || original.placeholder || "";
  const wrap = original.getAttribute("wrap");
  if (wrap !== null) {
    textarea.setAttribute("wrap", wrap);
  } else {
    textarea.removeAttribute("wrap");
  }
  return textarea;
};
var useTextareaRowHeight = (textarea2) => {
  const calculateRowHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    return getNodeHeightStyles(textarea2.value).lineHeight;
  };
  const calculateHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    const { boxSizing, padding, border, styles } = getNodeHeightStyles(textarea2.value);
    const hiddenTextarea = createHiddenTextarea(textarea2.value, styles);
    document.body.appendChild(hiddenTextarea);
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += border;
    } else if (boxSizing === "content-box") {
      height -= padding;
    }
    document.body.removeChild(hiddenTextarea);
    return height;
  };
  return {
    calculateRowHeight,
    calculateHeight
  };
};
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var script$14 = defineComponent({
  name: "VaTextarea",
  props: {
    ...useFormProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    }
  },
  emits: createEmits2(),
  setup(props, { emit }) {
    const textarea2 = shallowRef();
    const rowHeight = ref(-1);
    const height = ref(-1);
    const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea2);
    const isResizable = computed(() => {
      return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea2.value);
    });
    const updateRowHeight = () => {
      if (isResizable.value) {
        rowHeight.value = calculateRowHeight();
      }
    };
    const updateHeight = () => {
      if (isResizable.value) {
        height.value = calculateHeight();
      }
    };
    onMounted(() => {
      updateRowHeight();
      updateHeight();
    });
    watch(() => props.modelValue, () => {
      nextTick(updateHeight);
    });
    const computedStyle = computed(() => ({
      minHeight: rowHeight.value * props.minRows + "px",
      maxHeight: props.maxRows ? rowHeight.value * props.maxRows + "px" : void 0,
      height: height.value + "px",
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick_1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const focus = () => {
      var _a;
      (_a = textarea2.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = textarea2.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    return {
      textarea: textarea2,
      computedStyle,
      listeners: createListeners2(emit),
      computedProps,
      focus,
      blur
    };
  }
});
var _hoisted_1$1 = ["value"];
function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, { ..._ctx.computedProps, ..._ctx.listeners }, { value: _ctx.modelValue }), null, 16, _hoisted_1$1);
}
script$14.render = render$13;
script$14.__file = "src/components/va-input/components/VaTextarea/VaTextarea.vue";
var VaTextareaProps = extractComponentProps(script$14);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(["change", "keyup", "keypress", "keydown", "focus", "blur"]);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var script27 = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper: script26, VaTextarea: script$14, VaIcon: script },
  props: {
    ...useFormProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...VaTextareaProps,
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    modelValue: { type: [String, Number], default: "" },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits()
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const isFocused = useFocusDeep();
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const focus = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const { computedError, computedErrorMessages, listeners: validationListeners } = useValidation(props, emit, reset, focus);
    const { modelValue } = toRefs(props);
    const { canBeCleared, clearIconProps } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e2) => {
      inputListeners.onFocus(e2);
      validationListeners.onFocus();
    };
    const onBlur = (e2) => {
      inputListeners.onBlur(e2);
      validationListeners.onBlur();
    };
    const inputEvents = {
      ...inputListeners,
      onFocus,
      onBlur,
      onInput
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => ({
      ariaLabel: props.ariaLabel || props.label,
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      "aria-invalid": !!computedErrorMessages.value.length,
      "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", "),
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      ...omit_1(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick_1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode"])
    }));
    const valueLengthComputed = computed(() => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0);
    return {
      input,
      inputEvents,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(props, VaTextareaProps),
      computedValue,
      tabIndexComputed,
      computedError,
      computedErrorMessages,
      isFocused,
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    };
  }
});
var _hoisted_117 = ["value"];
function render28(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_VaInputWrapper = resolveComponent("VaInputWrapper");
  return openBlock(), createBlock(_component_VaInputWrapper, mergeProps(_ctx.fieldListeners, {
    class: _ctx.$attrs.class,
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-hidden": "false",
        "aria-label": "reset",
        class: "va-input__icons__reset",
        tabindex: _ctx.tabIndexComputed
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["tabindex", "onClick", "onKeydown"])) : createCommentVNode("v-if", true),
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
        key: 1,
        color: _ctx.$props.color,
        size: "small",
        name: "loop",
        spin: "counter-clockwise"
      }, null, 8, ["color"])) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      _ctx.type === "textarea" && !_ctx.$slots.content ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
        key: 0,
        ref: "input"
      }, { ..._ctx.computedChildAttributes, ..._ctx.textareaProps, ..._ctx.inputEvents }, { class: "va-input__content__input" }), null, 16)) : !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "va-input__content__input"
      }, { ..._ctx.computedInputAttributes, ..._ctx.inputEvents }, { value: _ctx.computedValue }), null, 16, _hoisted_117)) : createCommentVNode("v-if", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "color", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]);
}
script27.render = render28;
script27.__file = "src/components/va-input/VaInput.vue";

// node_modules/vuestic-ui/dist/esm/index35.js
var VaInput = withConfigTransport(script27);

// node_modules/vuestic-ui/dist/esm/index19.js
var script28 = defineComponent({
  name: "VaColorInput",
  components: {
    VaInput,
    VaColorIndicator
  },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  },
  setup: (props, { emit }) => {
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a;
      return !props.disabled && ((_a = colorPicker.value) === null || _a === void 0 ? void 0 : _a.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    return {
      valueComputed,
      callPickerDialog,
      colorPicker,
      tabIndexComputed
    };
  }
});
var _hoisted_118 = { class: "va-color-input" };
function render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  const _component_va_input = resolveComponent("va-input");
  return openBlock(), createElementBlock("div", _hoisted_118, [
    createVNode(_component_va_color_indicator, {
      class: "va-color-input__dot",
      role: "button",
      "aria-label": "open color picker",
      "aria-disabled": _ctx.$props.disabled,
      tabindex: _ctx.tabIndexComputed,
      color: _ctx.valueComputed,
      indicator: _ctx.$props.indicator,
      onClick: _ctx.callPickerDialog,
      onKeydown: [
        withKeys(_ctx.callPickerDialog, ["space"]),
        withKeys(_ctx.callPickerDialog, ["enter"])
      ]
    }, null, 8, ["aria-disabled", "tabindex", "color", "indicator", "onClick", "onKeydown"]),
    createVNode(_component_va_input, {
      class: "va-color-input__input",
      placeholder: "input color",
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      tabindex: _ctx.tabIndexComputed,
      disabled: _ctx.$props.disabled
    }, null, 8, ["modelValue", "tabindex", "disabled"]),
    withDirectives(createBaseVNode("input", {
      ref: "colorPicker",
      type: "color",
      class: "visually-hidden",
      "aria-hidden": "true",
      tabindex: "-1",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
    }, null, 512), [
      [vModelText, _ctx.valueComputed]
    ])
  ]);
}
script28.render = render29;
script28.__file = "src/components/va-color-input/VaColorInput.vue";
var VaColorInput = withConfigTransport(script28);

// node_modules/vuestic-ui/dist/esm/index20.js
var script29 = defineComponent({
  name: "VaColorPalette",
  components: { VaColorIndicator },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    return {
      valueComputed,
      isSelected: (color) => valueComputed.value === color
    };
  }
});
var _hoisted_119 = { class: "va-color-palette" };
var _hoisted_29 = {
  class: "va-color-palette__colors",
  role: "listbox",
  "aria-label": "color selection"
};
function render30(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  return openBlock(), createElementBlock("div", _hoisted_119, [
    createBaseVNode("ul", _hoisted_29, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palette, (color, index) => {
        return openBlock(), createBlock(_component_va_color_indicator, {
          key: index,
          role: "option",
          "aria-label": `color ${color}`,
          "aria-selected": _ctx.isSelected(color),
          tabindex: "0",
          modelValue: _ctx.isSelected(color),
          color,
          square: _ctx.indicator === "square",
          "onUpdate:modelValue": ($event) => _ctx.valueComputed = color
        }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
      }), 128))
    ])
  ]);
}
script29.render = render30;
script29.__file = "src/components/va-color-palette/VaColorPalette.vue";
var VaColorPalette = withConfigTransport(script29);

// node_modules/vuestic-ui/dist/esm/index21.js
var script30 = {
  name: "VaContent"
};
var _hoisted_120 = { class: "va-content" };
function render31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_120, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script30.render = render31;
script30.__file = "src/components/va-content/VaContent.vue";
var VaContent = withConfigTransport(script30);

// node_modules/vuestic-ui/dist/esm/css-utils.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/esm/index22.js
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(["change"]);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var script31 = defineComponent({
  name: "VaCounter",
  components: { VaInputWrapper: script26, VaIcon: script, VaButton: script8 },
  props: {
    ...useFormProps,
    ...useStatefulProps,
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    min: { type: Number, default: void 0 },
    max: { type: Number, default: void 0 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    messages: { type: [Array, String], default: () => [] },
    width: { type: [String, Number], default: "160px" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean },
    bordered: { type: Boolean },
    increaseIcon: { type: String, default: "add" },
    decreaseIcon: { type: String, default: "remove" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    textColor: { type: String, default: void 0 }
  },
  emits: [
    "update:modelValue",
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs }) {
    const input = shallowRef();
    const { isFocused, focus, blur } = useFocus(input, emit);
    const { valueComputed } = useStateful(props, emit);
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target === null || target === void 0 ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target === null || target === void 0 ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (!props.min || !props.step) {
        return value;
      }
      return props.min + props.step * Math.floor((value - props.min) / props.step);
    };
    const calculateCounterValue = (counterValue) => {
      if (props.min && counterValue < props.min) {
        valueComputed.value = props.min;
        return;
      }
      if (props.max && counterValue > props.max) {
        valueComputed.value = getRoundDownWithStep(props.max);
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (!props.min) {
        return false;
      }
      return Number(valueComputed.value) <= props.min;
    });
    const isMaxReached = computed(() => {
      if (!props.max) {
        return false;
      }
      return props.step ? Number(valueComputed.value) > props.max - props.step : Number(valueComputed.value) >= props.max;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.readonly || props.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.readonly || props.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - props.step);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + props.step);
    };
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.decreaseIcon,
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.increaseIcon,
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonProps = computed(() => ({
      ...pick_1(props, ["rounded", "color", "textColor"]),
      flat: props.flat && !props.outline,
      outline: props.flat && props.outline
    }));
    const decreaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value
    }));
    const increaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value
    }));
    const inputAttributesComputed = computed(() => ({
      tabindex: tabIndexComputed.value,
      ariaLabel: props.label || "counter value",
      ariaValuemin: props.min,
      ariaValuemax: props.max,
      ...omit_1(attrs, ["class", "style"]),
      ...pick_1(props, ["disabled", "min", "max", "step"]),
      readonly: props.readonly || !props.manualInput
    }));
    const inputWrapperPropsComputed = computed(() => ({
      ...pick_1(props, ["color", "readonly", "disabled", "messages", "label", "bordered", "outline"])
    }));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value }
    ]);
    const styleComputed = computed(() => ({
      width: safeCSSLength(props.width),
      ...attrs.style || {}
    }));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    return {
      input,
      valueComputed,
      isFocused,
      fieldListeners: createFieldListeners2(emit),
      inputListeners: createInputListeners2(emit),
      inputAttributesComputed,
      inputWrapperPropsComputed,
      setCountInput,
      setCountChange,
      decreaseCount,
      increaseCount,
      decreaseIconProps,
      increaseIconProps,
      decreaseButtonProps,
      increaseButtonProps,
      colorComputed,
      classComputed,
      styleComputed,
      marginComputed,
      focus,
      blur
    };
  }
});
var _hoisted_121 = {
  ref: "input",
  tabindex: "0"
};
var _hoisted_210 = ["value"];
function render32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaInputWrapper = resolveComponent("VaInputWrapper");
  return openBlock(), createBlock(_component_VaInputWrapper, mergeProps({ class: "va-counter" }, { ..._ctx.fieldListeners, ..._ctx.inputWrapperPropsComputed }, {
    class: _ctx.classComputed,
    style: _ctx.styleComputed,
    focused: _ctx.isFocused,
    onKeydown: [
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.increaseCount(), ["prevent"]), ["up"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.decreaseCount(), ["prevent"]), ["down"]))
    ]
  }), createSlots({
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input",
        type: "number",
        inputmode: "decimal"
      }, { ..._ctx.inputAttributesComputed, ..._ctx.inputListeners }, {
        value: _ctx.valueComputed,
        onInput: _cache[6] || (_cache[6] = (...args) => _ctx.setCountInput && _ctx.setCountInput(...args)),
        onChange: _cache[7] || (_cache[7] = (...args) => _ctx.setCountChange && _ctx.setCountChange(...args))
      }), null, 16, _hoisted_210)) : createCommentVNode("v-if", true)
    ]),
    _: 2
  }, [
    _ctx.$props.buttons ? {
      name: "prepend",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-wrapper",
          style: normalizeStyle({ marginRight: _ctx.marginComputed }),
          onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-decrease",
              "aria-label": "decrease counter"
            }, _ctx.decreaseButtonProps, {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.decreaseCount())
            }), null, 16)
          ])
        ], 36)
      ])
    } : {
      name: "prependInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-decrease" }, _ctx.decreaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$props.buttons ? {
      name: "append",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-wrapper",
          style: normalizeStyle({ marginLeft: _ctx.marginComputed }),
          onMousedown: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-increase",
              "aria-label": "increase counter"
            }, _ctx.increaseButtonProps, {
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.increaseCount())
            }), null, 16)
          ])
        ], 36)
      ])
    } : {
      name: "appendInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-increase" }, _ctx.increaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$slots.content ? {
      name: "content",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", _hoisted_121, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ ...slotScope, value: Number(_ctx.valueComputed) })))
        ], 512)
      ])
    } : void 0
  ]), 1040, ["class", "style", "focused"]);
}
script31.render = render32;
script31.__file = "src/components/va-counter/VaCounter.vue";
var VaCounter = withConfigTransport(script31);

// node_modules/vuestic-ui/dist/esm/index34.js
var script32 = defineComponent({
  name: "VaInnerLoading",
  components: { VaIcon },
  props: {
    ...useLoadingProps,
    color: { type: String },
    icon: { type: String, default: "autorenew" },
    size: { type: Number, default: 30 }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return { colorComputed };
  }
});
var _hoisted_122 = { class: "inner-loading" };
var _hoisted_211 = {
  key: 0,
  class: "inner-loading__overlay",
  "aria-hidden": "true"
};
function render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_122, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_211, [
      createVNode(_component_va_icon, {
        class: "inner-loading__spinner",
        spin: "",
        color: _ctx.colorComputed,
        size: _ctx.$props.size,
        name: _ctx.$props.icon
      }, null, 8, ["color", "size", "name"])
    ])) : createCommentVNode("v-if", true)
  ]);
}
script32.render = render33;
script32.__file = "src/components/va-inner-loading/VaInnerLoading.vue";
var VaInnerLoading = withConfigTransport(script32);

// node_modules/vuestic-ui/dist/esm/index23.js
var baseSlice2 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice2(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$12 = "\\u0300-\\u036f";
var reComboHalfMarksRange$12 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$12 = "\\u20d0-\\u20ff";
var rsComboRange$12 = rsComboMarksRange$12 + reComboHalfMarksRange$12 + rsComboSymbolsRange$12;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$12 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo2 = "[" + rsComboRange2 + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange2 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange2 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsSymbol = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol + rsSeq2, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString3(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$1 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$1;
var createCompounder3 = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder3(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
var buildTableColumn = (source, initialIndex) => {
  const input = typeof source === "string" ? { key: source } : source;
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase_1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (items2) => {
  return Object.keys(merge_1({}, ...items2)).map(buildTableColumn);
};
var buildNormalizedColumns = (columns) => {
  return columns.map(buildTableColumn);
};
function useColumns(props) {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props.items);
    } else {
      return buildNormalizedColumns(props.columns);
    }
  });
  return {
    columnsComputed
  };
}
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a = source === null || source === void 0 ? void 0 : source.toString) === null || _a === void 0 ? void 0 : _a.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column))
  };
};
function useRows(columns, props) {
  const rowsComputed = computed(() => props.items.map((rawItem, index) => buildTableRow(rawItem, index, props.itemsTrackBy, columns.value)));
  return {
    rowsComputed
  };
}
function useFilterable(rawRows, props, emit) {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter((row) => row.cells.some((cell) => {
      return typeof props.filterMethod === "function" ? props.filterMethod(cell.source) : cell.value.toLowerCase().includes(props.filter.toLowerCase());
    }));
  });
  watch(filteredRows, () => {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  });
  return {
    filteredRows
  };
}
function useSortable(columns, filteredRows, props, emit) {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const column = columns.value.find((column2) => column2.name === sortBySync.value);
    if (!column || !column.sortable) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.indexOf(column);
    return [...filteredRows.value].sort((a2, b2) => {
      const firstValue = a2.cells[columnIndex].value;
      const secondValue = b2.cells[columnIndex].value;
      const firstSource = a2.cells[columnIndex].source;
      const secondSource = b2.cells[columnIndex].source;
      if (sortingOrderSync.value === null) {
        return a2.initialIndex - b2.initialIndex;
      } else {
        const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  function toggleSorting(column) {
    if (column.name === sortBySync.value) {
      if (sortingOrderSync.value === null) {
        sortingOrderSync.value = "asc";
      } else if (sortingOrderSync.value === "asc") {
        sortingOrderSync.value = "desc";
      } else {
        sortingOrderSync.value = null;
      }
    } else {
      sortBySync.value = column.name;
      sortingOrderSync.value = "asc";
    }
  }
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting,
    sortedRows
  };
}
function usePaginatedRows$1(sortedRows, props) {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  return {
    paginatedRows
  };
}
function useSelectableRow(paginatedRows, props, emit) {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
}
var prefix = "--va-data-table";
var isFunction$12 = (val) => typeof val === "function";
var getClass = (classes) => isFunction$12(classes) ? classes() : classes;
var getStyle = (styles) => isFunction$12(styles) ? styles() : styles;
function useStyleable(props) {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2, shiftHSLAColor: shiftHSLAColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const rowCSSVariables = computed(() => ({
    [`${prefix}-hover-color`]: getHoverColor2(color.value),
    [`${prefix}-selected-color`]: props.selectable ? getFocusColor2(color.value) : void 0
  }));
  const stickyCSSVariables = computed(() => ({
    [`${prefix}-scroll-table-color`]: (props.height || props.stickyHeader || props.stickyFooter) && shiftHSLAColor2(color.value, { l: 40 }),
    [`${prefix}-scroll-table-height`]: props.height ? safeCSSLength(props.height) : void 0
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    rowCSSVariables,
    stickyCSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
}
var isFunction2 = (val) => typeof val === "function";
var isObject6 = (val) => val !== null && typeof val === "object";
function useBinding(props) {
  const getRowBind = (row) => isFunction2(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject6(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction2(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject6(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
}
function usePaginatedRows(props, rows) {
  const animationName = ref("table-transition-shuffle");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows) => {
    const animationType = isDifferentRowLength.value || newRows.length > 50 ? "fade" : "shuffle";
    animationName.value = props.animated ? `table-transition-${animationType}` : "";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationName.value = props.animated ? "table-transition-shuffle" : "";
    }
  });
  return animationName;
}
var script33 = defineComponent({
  name: "VaDataTable",
  components: {
    VaInnerLoading,
    VaCheckbox,
    VaIcon
  },
  inheritAttrs: false,
  props: {
    columns: { type: Array, default: () => [] },
    items: { type: Array, default: () => [] },
    itemsTrackBy: { type: [String, Function], default: "" },
    modelValue: { type: Array },
    sortingOrder: { type: String },
    sortBy: { type: String },
    filter: { type: String, default: "" },
    filterMethod: { type: Function },
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    animated: { type: Boolean, default: true },
    selectable: { type: Boolean, default: false },
    selectMode: { type: String, default: "multiple" },
    selectedColor: { type: String, default: "primary" },
    perPage: { type: Number },
    currentPage: { type: Number },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    allowFooterSorting: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    stickyHeader: { type: Boolean, default: false },
    stickyFooter: { type: Boolean, default: false },
    height: { type: [String, Number] },
    rowBind: { type: null },
    cellBind: { type: null }
  },
  emits: [
    "update:modelValue",
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu"
  ],
  setup(props, { attrs, emit }) {
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const { sortBySync, sortingOrderSync, toggleSorting, sortedRows } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows$1(sortedRows, props);
    const { ctrlSelectRow, shiftSelectRows, toggleBulkSelection, isRowSelected, severalRowsSelected, allRowsSelected } = useSelectableRow(paginatedRows, props, emit);
    const { rowCSSVariables, stickyCSSVariables, getHeaderCSSVariables, getCellCSSVariables, getFooterCSSVariables, getClass: getClass2, getStyle: getStyle2 } = useStyleable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = usePaginatedRows(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      if (props.clickable) {
        emit(name, {
          event,
          item: row.source,
          itemIndex: row.initialIndex
        });
      }
    };
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        attrs.class
      ],
      style: [stickyCSSVariables.value, attrs.style]
    }));
    const computedTableAttributes = computed(() => ({
      ...omit_1(attrs, ["class", "style"]),
      class: pick_1(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const getColumnAriaSortOrder = (columnName) => sortingOrderSync.value && sortBySync.value === columnName ? sortingOrderSync.value === "asc" ? "ascending" : "descending" : "none";
    return {
      columnsComputed,
      rows: paginatedRows,
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      rowCSSVariables,
      getHeaderCSSVariables,
      getCellCSSVariables,
      getFooterCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2,
      showNoDataHtml,
      showNoDataFilteredHtml,
      onRowClickHandler,
      computedAttributes,
      computedTableAttributes,
      animationName,
      getColumnAriaSortOrder,
      getRowBind,
      getCellBind
    };
  }
});
var _hoisted_123 = { key: 0 };
var _hoisted_212 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_35 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_44 = ["aria-sort", "aria-label", "title", "onClick", "onKeydown"];
var _hoisted_54 = ["tabindex"];
var _hoisted_63 = { key: 0 };
var _hoisted_7 = { key: "showNoDataHtml" };
var _hoisted_8 = ["colspan", "innerHTML"];
var _hoisted_9 = { key: "showNoDataFilteredHtml" };
var _hoisted_10 = ["colspan", "innerHTML"];
var _hoisted_11 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_124 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_132 = {
  key: 0,
  class: "va-data-table__table-th"
};
var _hoisted_142 = ["title", "aria-label", "onClick", "onKeydown"];
var _hoisted_152 = ["tabindex"];
var _hoisted_162 = { key: 0 };
function render34(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");
  return openBlock(), createBlock(_component_va_inner_loading, mergeProps({
    class: "va-data-table",
    "aria-live": "polite"
  }, _ctx.computedAttributes, {
    loading: _ctx.loading,
    color: _ctx.loadingColor
  }), {
    default: withCtx(() => [
      createBaseVNode("table", mergeProps({ class: "va-data-table__table" }, _ctx.computedTableAttributes), [
        "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_123, [
          renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
        ])) : createCommentVNode("v-if", true),
        createBaseVNode("thead", {
          class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }])
        }, [
          renderSlot(_ctx.$slots, "headerPrepend"),
          !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_212, [
            _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_35, [
              _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                key: 0,
                "aria-label": "select all rows",
                "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                "true-value": true,
                "false-value": false,
                color: _ctx.selectedColor,
                "indeterminate-value": "idl",
                indeterminate: "",
                "onUpdate:modelValue": _ctx.toggleBulkSelection
              }, null, 8, ["model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
              return openBlock(), createElementBlock("th", {
                key: column.name,
                scope: "col",
                "aria-sort": _ctx.getColumnAriaSortOrder(column.name),
                "aria-label": column.sortable ? `sort column by ${column.label}` : void 0,
                title: column.thTitle,
                class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                style: normalizeStyle([_ctx.getHeaderCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                onClick: withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["exact"]),
                onKeydown: withKeys(withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
              }, [
                createBaseVNode("div", {
                  class: "va-data-table__table-th-wrapper",
                  tabindex: column.sortable ? 0 : -1
                }, [
                  `header(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_63, [
                    renderSlot(_ctx.$slots, `header(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                  ])) : renderSlot(_ctx.$slots, "header", normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
                    createBaseVNode("span", null, toDisplayString(column.label), 1)
                  ]),
                  column.sortable ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: "va-data-table__table-th-sorting",
                    "aria-hidden": "true",
                    onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_icon, {
                      name: _ctx.sortingOrderSync === "asc" ? "expand_less" : "expand_more",
                      size: "small",
                      class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                    }, null, 8, ["name", "class"])
                  ], 32)) : createCommentVNode("v-if", true)
                ], 8, _hoisted_54)
              ], 46, _hoisted_44);
            }), 128))
          ])) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "headerAppend")
        ], 2),
        createBaseVNode("tbody", {
          class: "va-data-table__table-tbody",
          style: normalizeStyle(_ctx.rowCSSVariables)
        }, [
          renderSlot(_ctx.$slots, "bodyPrepend"),
          createVNode(TransitionGroup, {
            name: _ctx.animationName,
            appear: ""
          }, {
            default: withCtx(() => [
              _ctx.showNoDataHtml ? (openBlock(), createElementBlock("tr", _hoisted_7, [
                createBaseVNode("td", {
                  colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                  innerHTML: _ctx.noDataHtml,
                  class: "no-data"
                }, null, 8, _hoisted_8)
              ])) : _ctx.showNoDataFilteredHtml ? (openBlock(), createElementBlock("tr", _hoisted_9, [
                createBaseVNode("td", {
                  colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                  innerHTML: _ctx.noDataFilteredHtml,
                  class: "no-data"
                }, null, 8, _hoisted_10)
              ])) : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row) => {
                return openBlock(), createElementBlock("tr", mergeProps({
                  key: `table-row_${row.initialIndex}`,
                  class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row) }]]
                }, _ctx.getRowBind(row), {
                  onClick: ($event) => _ctx.onRowClickHandler("row:click", $event, row),
                  onDblclick: ($event) => _ctx.onRowClickHandler("row:dblclick", $event, row),
                  onContextmenu: ($event) => _ctx.onRowClickHandler("row:contextmenu", $event, row)
                }), [
                  _ctx.selectable ? (openBlock(), createElementBlock("td", {
                    class: "va-data-table__table-td va-data-table__table-cell-select",
                    key: `selectable_${row.initialIndex}`,
                    onSelectstart: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_checkbox, {
                      "model-value": _ctx.isRowSelected(row),
                      color: _ctx.selectedColor,
                      "aria-label": `select row ${row.initialIndex}`,
                      onClick: [
                        withModifiers(($event) => _ctx.shiftSelectRows(row), ["shift", "exact", "stop"]),
                        withModifiers(($event) => _ctx.ctrlSelectRow(row), ["ctrl", "exact", "stop"]),
                        withModifiers(($event) => _ctx.ctrlSelectRow(row), ["exact", "stop"])
                      ]
                    }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                  ], 32)) : createCommentVNode("v-if", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell) => {
                    return openBlock(), createElementBlock("td", mergeProps({
                      key: `table-cell_${cell.column.name + cell.rowIndex}`,
                      class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                      style: [_ctx.getCellCSSVariables(cell), _ctx.getStyle(cell.column.tdStyle)]
                    }, _ctx.getCellBind(cell, row)), [
                      `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, cell))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, cell)), () => [
                        createTextVNode(toDisplayString(cell.value), 1)
                      ])
                    ], 16);
                  }), 128))
                ], 16, _hoisted_11);
              }), 128))
            ]),
            _: 3
          }, 8, ["name"]),
          renderSlot(_ctx.$slots, "bodyAppend")
        ], 4),
        _ctx.footerClone ? (openBlock(), createElementBlock("tfoot", {
          key: 1,
          class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }])
        }, [
          renderSlot(_ctx.$slots, "footerPrepend"),
          !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_124, [
            _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_132, [
              _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                key: 0,
                "aria-label": "select all rows",
                "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                "true-value": true,
                "false-value": false,
                color: _ctx.selectedColor,
                "indeterminate-value": "idl",
                indeterminate: "",
                "onUpdate:modelValue": _ctx.toggleBulkSelection
              }, null, 8, ["model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
              return openBlock(), createElementBlock("th", {
                key: column.name,
                title: column.thTitle,
                "aria-label": _ctx.allowFooterSorting && column.sortable ? `sort column by ${column.label}` : void 0,
                class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                style: normalizeStyle([_ctx.getFooterCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                onClick: withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["exact"]),
                onKeydown: withKeys(withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
              }, [
                createBaseVNode("div", {
                  class: "va-data-table__table-th-wrapper",
                  tabindex: _ctx.allowFooterSorting && column.sortable ? 0 : -1
                }, [
                  `footer(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_162, [
                    renderSlot(_ctx.$slots, `footer(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                  ])) : renderSlot(_ctx.$slots, "footer", normalizeProps(mergeProps({ key: 1 }, column)), () => [
                    createBaseVNode("span", null, toDisplayString(column.label), 1)
                  ]),
                  _ctx.allowFooterSorting && column.sortable ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: "va-data-table__table-th-sorting",
                    onSelectstart: _cache[2] || (_cache[2] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_icon, {
                      name: _ctx.sortingOrderSync === "asc" ? "expand_less" : "expand_more",
                      size: "small",
                      class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                    }, null, 8, ["name", "class"])
                  ], 32)) : createCommentVNode("v-if", true)
                ], 8, _hoisted_152)
              ], 46, _hoisted_142);
            }), 128))
          ])) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "footerAppend")
        ], 2)) : createCommentVNode("v-if", true)
      ], 16)
    ]),
    _: 3
  }, 16, ["loading", "color"]);
}
script33.render = render34;
script33.__file = "src/components/va-data-table/VaDataTable.vue";
var VaDataTable = withConfigTransport(script33);

// node_modules/vuestic-ui/dist/esm/VaDatePicker.js
var baseGetTag4 = _baseGetTag;
var isObjectLike4 = isObjectLike_1;
var dateTag2 = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike4(value) && baseGetTag4(value) == dateTag2;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary2 = _baseUnary;
var nodeUtil2 = _nodeUtil.exports;
var nodeIsDate = nodeUtil2 && nodeUtil2.isDate;
var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
var isDatesDayEqual = (date1, date2) => (date1 === null || date1 === void 0 ? void 0 : date1.toDateString()) === (date2 === null || date2 === void 0 ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 === null || date1 === void 0 ? void 0 : date1.getFullYear()) === (date2 === null || date2 === void 0 ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 === null || date1 === void 0 ? void 0 : date1.getMonth()) === (date2 === null || date2 === void 0 ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = new Date();
  date.setFullYear(year);
  return date;
};
var isRange = (value) => {
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate = (value) => isDate_1(value);
var isDates = (value) => Array.isArray(value);
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate_1(modelValue)) {
    return modelValue;
  }
  if (isDate_1(modelValue === null || modelValue === void 0 ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate_1(modelValue[0])) {
    return modelValue[0];
  }
  return new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return { ...statefulView.value, ...props.view };
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};
function isUndefined(t2) {
  return t2 === void 0;
}
var useGridKeyboardNavigation = ({ rowSize, start, end, onSelected, onFocusIndex }) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked = false;
  const onMousedown = () => {
    previouslyClicked = true;
  };
  const onFocus = () => {
    if (previouslyClicked) {
      return;
    }
    previouslyClicked = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e2) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e2.key)) {
      e2.preventDefault();
    }
    if (e2.key === "Enter" || e2.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e2.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e2.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e2.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e2.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d2) => dateEqual(d2, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d2) => !dateEqual(d2, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a2, b2) => a2.getTime() - b2.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(props, emit, datesEqual);
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d2) => datesEqual(d2, date));
    } else if (isRange(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k2) => k2 + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a;
    if (options && ((_a = options.firstWeekday) === null || _a === void 0 ? void 0 : _a.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d2) => new Date(view.value.year, view.value.month - 1, d2));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d2) => new Date(view.value.year, view.value.month, d2));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d2) => new Date(view.value.year, view.value.month + 1, d2))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};
var script$5 = defineComponent({
  name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    return {
      onClick
    };
  }
});
var _hoisted_1$4 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hidden ? (openBlock(), createElementBlock("div", _hoisted_1$4)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["va-date-picker-cell", {
      "va-date-picker-cell_other-month": _ctx.otherMonth,
      "va-date-picker-cell_today": _ctx.highlightToday && _ctx.today,
      "va-date-picker-cell_in-range": _ctx.inRange,
      "va-date-picker-cell_disabled": _ctx.disabled,
      "va-date-picker-cell_highlighted-weekend": _ctx.highlightWeekend && _ctx.weekend,
      "va-date-picker-cell_selected": _ctx.selected,
      "va-date-picker-cell_focused": _ctx.focused,
      "va-date-picker-cell_readonly": _ctx.readonly
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent", "stop"]), ["space", "enter"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34));
}
script$5.render = render$5;
script$5.__file = "src/components/va-date-picker/components/VaDatePickerCell.vue";
var VaDatePickerCellProps = extractComponentProps(script$5, ["date", "selectedValue", "focusedDate", "focused"]);
var script$4 = defineComponent({
  name: "VaDayPicker",
  components: { VaDatePickerCell: script$5 },
  props: {
    ...VaDatePickerCellProps,
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(props, { emit }) {
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const VaDayPickerCellPropValues = filterComponentProps(props, VaDatePickerCellProps);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const { hoveredIndex, onClick, isToday, isSelected, isInRange } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const { focusedCellIndex, containerAttributes } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return {
      hoveredIndex,
      calendarDates,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isOtherMonth,
      isDateDisabled,
      isDateWeekend,
      containerAttributes,
      weekdayNamesComputed,
      VaDayPickerCellPropValues,
      focusedCellIndex
    };
  }
});
var _hoisted_1$3 = ["onMouseenter"];
var _hoisted_2$1 = { class: "va-date-picker-cell__day" };
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    !_ctx.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
      return openBlock(), createElementBlock("div", {
        key: weekday,
        class: "va-day-picker__weekday"
      }, [
        renderSlot(_ctx.$slots, "weekday", {}, () => [
          createTextVNode(toDisplayString(weekday), 1)
        ])
      ]);
    }), 128)) : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.readonly,
          onClick: ($event) => {
            _ctx.onClick(date);
            _ctx.focusedCellIndex = index;
          }
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_2$1, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1)
              ])
            ])
          ]),
          _: 2
        }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "onClick"])
      ], 40, _hoisted_1$3);
    }), 128))
  ], 16);
}
script$4.render = render$4;
script$4.__file = "src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue";
var script$32 = defineComponent({
  name: "VaDatePickerHeader",
  components: { VaButton },
  emits: ["update:view"],
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    return { prev, next, changeView, switchView, syncView };
  }
});
var _hoisted_1$2 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
var _hoisted_213 = { class: "va-date-picker__header__text" };
var _hoisted_36 = { class: "ml-1" };
function render$32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.syncView.type !== "year" ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
    renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "chevron_left",
        flat: "",
        size: "small",
        color: _ctx.color,
        textColor: "dark",
        "aria-label": "next period",
        onClick: _ctx.prev
      }, null, 8, ["disabled", "color", "onClick"])
    ]),
    createBaseVNode("div", _hoisted_213, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
        createVNode(_component_va_button, {
          disabled: _ctx.$props.disabled,
          flat: "",
          size: "small",
          rounded: false,
          color: _ctx.color,
          textColor: "dark",
          "aria-label": "switch view",
          onClick: _ctx.switchView
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
              createTextVNode(toDisplayString(_ctx.syncView.year), 1)
            ]),
            _ctx.syncView.type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
              createBaseVNode("span", _hoisted_36, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1)
            ]) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 8, ["disabled", "color", "onClick"])
      ])
    ]),
    renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "chevron_right",
        flat: "",
        size: "small",
        color: _ctx.color,
        textColor: "dark",
        "aria-label": "previous period",
        onClick: _ctx.next
      }, null, 8, ["disabled", "color", "onClick"])
    ])
  ])) : createCommentVNode("v-if", true);
}
script$32.render = render$32;
script$32.__file = "src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.vue";
var script$22 = defineComponent({
  name: "VaMonthPicker",
  components: { VaDatePickerCell: script$5 },
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(props, { emit }) {
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const { hoveredIndex, onClick, isToday, isSelected, isInRange } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const { focusedCellIndex, containerAttributes } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      months,
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isDisabled,
      containerAttributes,
      focusedCellIndex
    };
  }
});
var _hoisted_1$12 = ["onMouseenter"];
function render$22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: ($event) => _ctx.hoveredIndex = monthIndex,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.readonly,
          onClick: ($event) => {
            _ctx.onClick(month);
            _ctx.focusedCellIndex = monthIndex;
          }
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick"])
      ], 40, _hoisted_1$12);
    }), 128))
  ], 16);
}
script$22.render = render$22;
script$22.__file = "src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.vue";
var script$15 = defineComponent({
  name: "VaYearPicker",
  components: { VaDatePickerCell: script$5 },
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => new Date().getFullYear() + 50 },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(props, { emit }) {
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i2) => createYearDate(start + i2));
    };
    const years = computed(() => generateYearsArray(props.startYear, props.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const { hoveredIndex, onClick, isToday, isSelected, isInRange } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const { focusedCellIndex, containerAttributes } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      hoveredIndex,
      years,
      rootNode,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isYearDisabled,
      focusedCellIndex,
      containerAttributes
    };
  }
});
function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
    }, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.readonly,
        onClick: ($event) => {
          _ctx.onClick(year);
          _ctx.focusedCellIndex = index;
        },
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1)
        ]),
        _: 2
      }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick", "onMouseenter"]);
    }), 128))
  ], 16);
}
script$15.render = render$14;
script$15.__file = "src/components/va-date-picker/components/VaYearPicker/VaYearPicker.vue";
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var script34 = defineComponent({
  name: "VaDatePicker",
  components: { VaDayPicker: script$4, VaDatePickerHeader: script$32, VaMonthPicker: script$22, VaYearPicker: script$15 },
  props: {
    ...useStatefulProps,
    ...extractComponentProps(script$32),
    ...extractComponentProps(script$4),
    ...extractComponentProps(script$22),
    ...extractComponentProps(script$15),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(script$32),
    ...extractComponentEmits(script$15),
    ...extractComponentEmits(script$4),
    ...extractComponentEmits(script$22)
  ],
  setup(props, { emit }) {
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const colorsStyle = colorsToCSSVariable({
      color: props.color,
      "weekends-color": props.weekendsColor
    }, "va-date-picker");
    const focusCurrentPicker = () => {
      var _a;
      return (_a = currentPicker.value) === null || _a === void 0 ? void 0 : _a.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    return {
      dayPickerProps: filterComponentProps(props, extractComponentProps(script$4)),
      headerProps: filterComponentProps(props, extractComponentProps(script$32)),
      monthPickerProps: filterComponentProps(props, extractComponentProps(script$22)),
      yearPickerProps: filterComponentProps(props, extractComponentProps(script$15)),
      syncView,
      classComputed,
      valueComputed,
      onDayModelValueUpdate,
      onMonthClick,
      onMonthModelValueUpdate,
      onYearClick,
      onYearModelValueUpdate,
      colorsStyle,
      currentPicker,
      focusCurrentPicker,
      isPickerReadonly
    };
  }
});
var _hoisted_125 = { class: "va-date-picker__picker-wrapper" };
function render35(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.colorsStyle)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = ($event) => _ctx.syncView = $event)
    }), createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (_2, name) => {
        return {
          name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        };
      })
    ]), 1040, ["view"]),
    createBaseVNode("div", _hoisted_125, [
      _ctx.syncView.type === "day" ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
        key: 0,
        ref: "currentPicker"
      }, _ctx.dayPickerProps, {
        "model-value": _ctx.valueComputed,
        view: _ctx.syncView,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("day"),
        "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
        "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
        "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["model-value", "view", "readonly", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
      _ctx.syncView.type === "month" ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
        key: 1,
        ref: "currentPicker"
      }, _ctx.monthPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("month"),
        "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
        "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
        "onClick:month": _ctx.onMonthClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"])) : createCommentVNode("v-if", true),
      _ctx.syncView.type === "year" ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
        key: 2,
        ref: "currentPicker"
      }, _ctx.yearPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("year"),
        "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
        "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
        "onClick:year": _ctx.onYearClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"])) : createCommentVNode("v-if", true)
    ])
  ], 6);
}
script34.render = render35;
script34.__file = "src/components/va-date-picker/VaDatePicker.vue";

// node_modules/vuestic-ui/dist/esm/index24.js
var useParsable = (parsable, parse2, format) => {
  const text = computed({
    get() {
      const value2 = parsable.value;
      if (typeof value2 === "string") {
        return value2;
      }
      return format(value2);
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = v2;
      } else {
        parsable.value = parse2(v2);
      }
    }
  });
  const value = computed({
    get() {
      if (typeof parsable.value === "string") {
        return parse2(parsable.value);
      }
      return parsable.value;
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = format(v2);
      } else {
        parsable.value = v2;
      }
    }
  });
  return {
    text,
    value
  };
};
function useSyncProp2(propRef, propName, emit, defaultValue) {
  if (defaultValue === void 0) {
    return {
      syncProp: computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return propRef.value;
        }
      })
    };
  }
  const statefulValue = ref(defaultValue);
  return {
    syncProp: computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return (propRef === null || propRef === void 0 ? void 0 : propRef.value) === void 0 ? statefulValue.value : propRef.value;
      }
    })
  };
}
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d2) => isDate_1(d2) && !isNaN(d2.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => text.includes(props.delimiter);
  const isRange3 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const date = (props.parseDate || defaultParseDateFunction)(text);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange3(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};
var isRange2 = (date) => {
  return typeof date === "object" && ("start" in date || "end" in date);
};
var parseSingleDate = (date) => typeof date === "string" ? defaultParseDateFunction(date) : new Date(date);
var parseModelValue = (date) => {
  if (Array.isArray(date)) {
    return date.map(parseSingleDate);
  }
  if (isRange2(date)) {
    return {
      start: isNil_1(date.start) ? date.start : parseSingleDate(date.start),
      end: isNil_1(date.end) ? date.end : parseSingleDate(date.end)
    };
  }
  return parseSingleDate(date);
};
var useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange2(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange2(bufferValue.value)) {
      bufferValue.value = modelValue.value && parseValue(modelValue.value);
    }
  };
  return {
    valueComputed,
    reset
  };
};
var VaInputProps = extractComponentProps(VaInput, [
  "mask",
  "returnRaw",
  "autosize",
  "minRows",
  "maxRows",
  "type",
  "inputmode",
  "counter",
  "maxLength"
]);
var VaDatePickerProps = extractComponentProps(script34);
var script35 = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: script34,
    VaInput,
    VaIcon
  },
  props: {
    ...VaInputProps,
    ...VaDatePickerProps,
    ...useValidationProps,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d2) => d2.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "calendar_today" }
  },
  emits: [
    ...extractComponentEmits(script34),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  setup(props, { emit, slots }) {
    const input = ref();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp2(isOpen, "is-open", emit, false);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const { valueComputed, reset: resetInvalidRange } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d2) => props.formatDate(d2)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const { text, value: valueWithoutText } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => {
      statefulValue.value = props.clearValue;
      emit("clear");
    };
    const focus = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) === null || _a === void 0 ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const showDropdown = () => {
      isOpenSync.value = true;
      nextTick(focusInputOrPicker);
    };
    const toggleDropdown = () => {
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showAndFocus = (event) => {
      if (props.manualInput) {
        return;
      }
      isOpenSync.value = true;
      focusDatePicker();
      event.preventDefault();
    };
    const blur = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    const { computedError, computedErrorMessages, listeners } = useValidation(props, emit, reset, focus);
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const { canBeCleared, clearIconProps, onFocus, onBlur } = useClearable(props, valueComputed);
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small",
      class: "va-date-input__icon"
    }));
    const computedInputProps = computed(() => ({
      ...filterComponentProps(props, VaInputProps).value,
      clearable: false,
      rules: [],
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        onBlur();
        listeners.onBlur();
      }
    }));
    return {
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      input,
      inputProps: computedInputProps,
      inputListeners: computedInputListeners,
      datePickerProps: filterComponentProps(props, extractComponentProps(script34)),
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      hideAndFocus,
      showAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      reset,
      focus,
      blur
    };
  }
});
var _hoisted_126 = { class: "va-date-input" };
function render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createElementBlock("div", _hoisted_126, [
    createVNode(_component_va_dropdown, {
      modelValue: _ctx.isOpenSync,
      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.isOpenSync = $event),
      trigger: "none",
      anchorSelector: ".va-input-wrapper__field",
      offset: [2, 0],
      "close-on-content-click": false,
      stateful: false,
      disabled: _ctx.disabled
    }, {
      anchor: withCtx(() => [
        renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputProps: _ctx.inputProps, inputListeners: _ctx.inputListeners })), () => [
          createVNode(_component_va_input, mergeProps({
            ref: "input",
            class: "va-date-input__input"
          }, _ctx.inputProps, toHandlers(_ctx.inputListeners), {
            "model-value": _ctx.valueText,
            "aria-label": "selected date",
            onChange: _ctx.onInputTextChanged,
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.toggleDropdown()),
            onKeydown: [
              withKeys(withModifiers(_ctx.showAndFocus, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.showAndFocus, ["stop"]), ["space"])
            ]
          }), createSlots({
            prependInner: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, normalizeProps(mergeProps({ key: 0 }, _ctx.iconProps)), null, 16)) : createCommentVNode("v-if", true)
            ]),
            icon: withCtx(() => [
              _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                "aria-hiden": "false",
                role: "button",
                "aria-label": "reset",
                tabindex: "0",
                class: "va-date-input__clear-icon"
              }, _ctx.clearIconProps, {
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.reset()),
                onKeydown: [
                  _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.reset(), ["stop"]), ["enter"])),
                  _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.reset(), ["stop"]), ["space"]))
                ]
              }), null, 16)) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({ key: 1 }, _ctx.iconProps, {
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
                ]
              }), null, 16, ["onKeydown"])) : createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            renderList(_ctx.filterSlots, (name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["model-value", "onChange", "onKeydown"])
        ])
      ]),
      default: withCtx(() => [
        createVNode(_component_va_dropdown_content, {
          onKeydown: _cache[12] || (_cache[12] = withKeys(withModifiers(($event) => _ctx.hideAndFocus(), ["stop", "prevent"]), ["esc"]))
        }, {
          default: withCtx(() => [
            createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
              modelValue: _ctx.valueWithoutText,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.valueWithoutText = $event),
              "onClick:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click:day", $event)),
              "onClick:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("click:month", $event)),
              "onClick:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("click:year", $event)),
              "onHover:day": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("hover:day", $event)),
              "onHover:month": _cache[9] || (_cache[9] = ($event) => _ctx.$emit("hover:month", $event)),
              "onHover:year": _cache[10] || (_cache[10] = ($event) => _ctx.$emit("hover:year", $event)),
              "onUpdate:view": _cache[11] || (_cache[11] = ($event) => _ctx.$emit("update:view", $event))
            }), createSlots({ _: 2 }, [
              renderList(_ctx.$slots, (_2, name) => {
                return {
                  name,
                  fn: withCtx((bind) => [
                    renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                  ])
                };
              })
            ]), 1040, ["modelValue"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["modelValue", "disabled"])
  ]);
}
script35.render = render36;
script35.__file = "src/components/va-date-input/VaDateInput.vue";
var VaDateInput = withConfigTransport(script35);

// node_modules/vuestic-ui/dist/esm/index25.js
var VaDatePicker = withConfigTransport(script34);

// node_modules/vuestic-ui/dist/esm/index26.js
var prefixClass = "va-divider";
var script36 = defineComponent({
  name: "VaDivider",
  props: {
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    }
  },
  setup: (props, { slots }) => ({
    hasSlot: computed(() => !!slots.default),
    classComputed: computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }))
  })
});
var _hoisted_127 = ["aria-orientation"];
var _hoisted_214 = {
  key: 0,
  class: "va-divider__text"
};
function render37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "separator",
    class: normalizeClass(["va-divider", _ctx.classComputed]),
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
  }, [
    _ctx.hasSlot && !_ctx.vertical ? (openBlock(), createElementBlock("div", _hoisted_214, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_127);
}
script36.render = render37;
script36.__file = "src/components/va-divider/VaDivider.vue";
var VaDivider = withConfigTransport(script36);

// node_modules/vuestic-ui/dist/esm/VaModal.js
var ModalElement = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a;
    return props.isTransition ? h(Transition, { ...attrs }, slots) : (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, attrs);
  }
});
var script37 = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton, VaIcon, ModalElement },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "OK" },
    cancelText: { type: String, default: "Cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String] },
    backgroundColor: { type: String, default: "white" },
    noPadding: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding,
      [`va-modal--size-${props.size}`]: props.size !== "medium"
    }));
    const computedModalContainerStyle = computed(() => ({ "z-index": props.zIndex }));
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayStyles = computed(() => {
      const moreThanOneModalIsOpen = !!document.querySelectorAll(".va-modal__overlay").length;
      if (!props.overlay || moreThanOneModalIsOpen) {
        return;
      }
      return {
        "background-color": `rgba(0, 0, 0, ${props.overlayOpacity})`,
        "z-index": props.zIndex && Number(props.zIndex) - 1
      };
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = () => {
      valueComputed.value = false;
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      hide();
      emit("cancel");
    };
    const ok = () => {
      hide();
      emit("ok");
    };
    const onOutsideClick = () => {
      if (props.noOutsideDismiss || props.noDismiss) {
        return;
      }
      emit("click-outside");
      cancel();
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e2) => {
      e2.modalsCounter = e2.modalsCounter ? e2.modalsCounter + 1 : 1;
      const modalNumber = e2.modalsCounter;
      const isOnTop = () => e2.modalsCounter === modalNumber;
      const hideModal = () => {
        if (e2.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isOnTop()) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    watch(valueComputed, (value) => {
      if (value) {
        window.addEventListener("keyup", listenKeyUp);
      } else {
        window.removeEventListener("keyup", listenKeyUp);
      }
      if (props.blur) {
        if (value) {
          document.body.classList.add("va-modal-overlay-background--blurred");
        } else {
          document.body.classList.remove("va-modal-overlay-background--blurred");
        }
      }
    }, { immediate: true });
    const publicMethods = {
      show,
      hide,
      toggle,
      cancel,
      ok,
      onOutsideClick,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    };
    return {
      getColor,
      rootElement,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedModalContainerStyle,
      computedOverlayStyles,
      ...publicMethods
    };
  }
});
var _hoisted_128 = ["aria-labelledby"];
var _hoisted_215 = {
  key: 0,
  class: "va-modal__anchor"
};
var _hoisted_37 = {
  key: 0,
  class: "va-modal"
};
var _hoisted_45 = { key: 0 };
var _hoisted_55 = {
  key: 1,
  class: "va-modal__header"
};
var _hoisted_64 = {
  key: 2,
  class: "va-modal__message"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__message"
};
var _hoisted_82 = {
  key: 4,
  class: "va-modal__footer"
};
var _hoisted_92 = {
  key: 5,
  class: "va-modal__footer"
};
function render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_button = resolveComponent("va-button");
  const _component_modal_element = resolveComponent("modal-element");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass]),
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": _ctx.title
  }, [
    _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", _hoisted_215, [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ show: _ctx.show, hide: _ctx.hide, toggle: _ctx.toggle })))
    ])) : createCommentVNode("v-if", true),
    (openBlock(), createBlock(Teleport, {
      to: _ctx.attachElement,
      disabled: _ctx.$props.disableAttachment
    }, [
      createVNode(_component_modal_element, mergeProps({
        name: "va-modal",
        isTransition: !_ctx.$props.withoutTransitions,
        appear: "",
        duration: 300
      }, _ctx.$attrs, {
        onBeforeEnter: _ctx.onBeforeEnterTransition,
        onAfterEnter: _ctx.onAfterEnterTransition,
        onBeforeLeave: _ctx.onBeforeLeaveTransition,
        onAfterLeave: _ctx.onAfterLeaveTransition
      }), {
        default: withCtx(() => [
          _ctx.valueComputed ? (openBlock(), createElementBlock("div", _hoisted_37, [
            _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-modal__overlay",
              style: normalizeStyle(_ctx.computedOverlayStyles),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onOutsideClick && _ctx.onOutsideClick(...args))
            }, null, 4)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: "va-modal__container",
              style: normalizeStyle(_ctx.computedModalContainerStyle)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["va-modal__dialog", _ctx.computedClass]),
                style: normalizeStyle(_ctx.computedDialogStyle)
              }, [
                _ctx.$props.fullscreen ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  name: "close",
                  class: "va-modal__close",
                  role: "button",
                  "aria-label": "close",
                  "aria-hidden": "false",
                  tabindex: "0",
                  onClick: _ctx.cancel,
                  onKeydown: [
                    withKeys(_ctx.cancel, ["space"]),
                    withKeys(_ctx.cancel, ["enter"])
                  ]
                }, null, 8, ["onClick", "onKeydown"])) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: "va-modal__inner",
                  style: normalizeStyle({ maxWidth: _ctx.$props.maxWidth, maxHeight: _ctx.$props.maxHeight })
                }, [
                  _ctx.$slots.content ? (openBlock(), createElementBlock("div", _hoisted_45, [
                    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ cancel: _ctx.cancel, ok: _ctx.ok })))
                  ])) : createCommentVNode("v-if", true),
                  !_ctx.$slots.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "va-modal__title",
                      style: normalizeStyle({ color: _ctx.getColor("primary") })
                    }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("v-if", true),
                    _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_55, [
                      renderSlot(_ctx.$slots, "header")
                    ])) : createCommentVNode("v-if", true),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_64, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("v-if", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      renderSlot(_ctx.$slots, "default")
                    ])) : createCommentVNode("v-if", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_82, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(_component_va_button, {
                        key: 0,
                        color: "gray",
                        class: "mr-2",
                        flat: "",
                        onClick: _ctx.cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$props.cancelText), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])) : createCommentVNode("v-if", true),
                      createVNode(_component_va_button, { onClick: _ctx.ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$props.okText), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])) : createCommentVNode("v-if", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_92, [
                      renderSlot(_ctx.$slots, "footer")
                    ])) : createCommentVNode("v-if", true)
                  ], 64)) : createCommentVNode("v-if", true)
                ], 4)
              ], 6)
            ], 4)
          ])) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 16, ["isTransition", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
    ], 8, ["to", "disabled"]))
  ], 10, _hoisted_128);
}
script37.render = render38;
script37.__file = "src/components/va-modal/VaModal.vue";
var VaModal = withConfigTransport(script37);

// node_modules/vuestic-ui/dist/esm/index28.js
var script$52 = defineComponent({
  name: "VaFileUploadUndo",
  components: {
    VaButton
  },
  emits: ["recover"]
});
var _hoisted_1$5 = { class: "va-file-upload-undo" };
var _hoisted_2$4 = createBaseVNode("span", null, "File was successfully deleted", -1);
var _hoisted_3$4 = createTextVNode(" Undo ");
function render$52(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    _hoisted_2$4,
    createVNode(_component_va_button, {
      class: "va-file-upload-undo__button",
      size: "small",
      outline: "",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
    }, {
      default: withCtx(() => [
        _hoisted_3$4
      ]),
      _: 1
    })
  ]);
}
script$52.render = render$52;
script$52.__file = "src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.vue";
var VaFileUploadUndo = withConfigTransport(script$52);
var script$42 = defineComponent({
  name: "VaFileUploadListItem",
  components: {
    VaIcon,
    VaCard,
    VaFileUploadUndo
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 }
  },
  setup(props, { emit }) {
    const removed = ref(false);
    const removeFile = () => {
      if (props.undo) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, props.undoDuration);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    return {
      removed,
      removeFile,
      recoverFile
    };
  }
});
var _hoisted_1$42 = {
  key: 1,
  class: "va-file-upload-list-item__content"
};
var _hoisted_2$3 = { class: "va-file-upload-list-item__name" };
var _hoisted_3$3 = { class: "va-file-upload-list-item__size" };
function render$42(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_card = resolveComponent("va-card");
  return openBlock(), createBlock(_component_va_card, {
    class: normalizeClass(["va-file-upload-list-item", { "file-upload-list-item--undo": _ctx.removed }]),
    stripe: _ctx.removed && _ctx.undo,
    stripeColor: _ctx.color,
    "no-margin": "",
    "no-padding": ""
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_file_upload_undo, {
        key: 0,
        onRecover: _ctx.recoverFile
      }, null, 8, ["onRecover"])) : (openBlock(), createElementBlock("div", _hoisted_1$42, [
        createBaseVNode("div", _hoisted_2$3, toDisplayString(_ctx.file && _ctx.file.name), 1),
        createBaseVNode("div", _hoisted_3$3, toDisplayString(_ctx.file && _ctx.file.size), 1),
        createVNode(_component_va_icon, {
          class: "va-file-upload-list-item__delete",
          name: "clear",
          role: "button",
          "aria-hidden": "false",
          "aria-label": "remove file",
          tabindex: "0",
          color: "danger",
          onClick: _ctx.removeFile,
          onKeydown: [
            withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["space"])
          ]
        }, null, 8, ["onClick", "onKeydown"])
      ]))
    ]),
    _: 1
  }, 8, ["class", "stripe", "stripeColor"]);
}
script$42.render = render$42;
script$42.__file = "src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.vue";
var VaFileUploadListItem = withConfigTransport(script$42);
var script$33 = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: { VaFileUploadUndo, VaButton },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 }
  },
  setup(props, { emit }) {
    const previewImage = ref("");
    const removed = ref(false);
    const isFocused = ref(false);
    const overlayStyles = computed(() => ({ backgroundColor: colorToRgba(props.color, 0.7) }));
    const removeImage = () => {
      if (props.undo) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, props.undoDuration);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e2) => {
          var _a, _b;
          if (((_a = e2.target) === null || _a === void 0 ? void 0 : _a.result).includes("image")) {
            previewImage.value = (_b = e2.target) === null || _b === void 0 ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    return {
      previewImage,
      removed,
      isFocused,
      recoverImage,
      overlayStyles,
      removeImage
    };
  }
});
var _hoisted_1$32 = ["src"];
var _hoisted_2$2 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_3$2 = ["title"];
function render$33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_button = resolveComponent("va-button");
  return _ctx.removed && _ctx.undo ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["va-file-upload-gallery-item", { "va-file-upload-gallery-item--undo": _ctx.removed }])
  }, [
    createVNode(_component_va_file_upload_undo, {
      class: "va-file-upload-gallery-item--undo",
      onRecover: _ctx.recoverImage
    }, null, 8, ["onRecover"])
  ], 2)) : (openBlock(), createElementBlock("div", {
    key: 1,
    tabindex: "0",
    class: normalizeClass(["va-file-upload-gallery-item", {
      "file-upload-gallery-item_not-image": !_ctx.previewImage,
      "va-file-upload-gallery-item--focused": _ctx.isFocused
    }]),
    onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = true),
    onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.isFocused = false)
  }, [
    _ctx.previewImage ? (openBlock(), createElementBlock("img", {
      key: 0,
      src: _ctx.previewImage,
      alt: "",
      class: "va-file-upload-gallery-item__image"
    }, null, 8, _hoisted_1$32)) : createCommentVNode("v-if", true),
    createBaseVNode("div", _hoisted_2$2, [
      createBaseVNode("div", {
        class: "va-file-upload-gallery-item__overlay-background",
        style: normalizeStyle(_ctx.overlayStyles)
      }, null, 4),
      createBaseVNode("div", {
        class: "va-file-upload-gallery-item__name",
        title: _ctx.file.name
      }, toDisplayString(_ctx.file.name), 9, _hoisted_3$2),
      createVNode(_component_va_button, {
        flat: "",
        color: "danger",
        icon: "delete_outline",
        class: "va-file-upload-gallery-item__delete",
        "aria-label": "remove image",
        onClick: _ctx.removeImage,
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = true),
        onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = false)
      }, null, 8, ["onClick"])
    ])
  ], 34));
}
script$33.render = render$33;
script$33.__file = "src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.vue";
var VaFileUploadGalleryItem = withConfigTransport(script$33);
var script$23 = defineComponent({
  name: "VaFileUploadSingleItem",
  components: {
    VaButton
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null }
  }
});
var _hoisted_1$22 = { class: "va-file-upload-single-item" };
var _hoisted_2$12 = { class: "va-file-upload-single-item__name" };
var _hoisted_3$1 = createTextVNode(" Delete ");
function render$23(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock("div", _hoisted_1$22, [
    createBaseVNode("div", _hoisted_2$12, toDisplayString(_ctx.file && _ctx.file.name), 1),
    createVNode(_component_va_button, {
      class: "va-file-upload-single-item__button",
      size: "small",
      color: "danger",
      flat: "",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
    }, {
      default: withCtx(() => [
        _hoisted_3$1
      ]),
      _: 1
    })
  ]);
}
script$23.render = render$23;
script$23.__file = "src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.vue";
var VaFileUploadSingleItem = withConfigTransport(script$23);
var script$16 = defineComponent({
  name: "VaFileUploadList",
  components: {
    VaFileUploadListItem,
    VaFileUploadGalleryItem,
    VaFileUploadSingleItem
  },
  emits: ["remove", "removeSingle"],
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    color: { type: String, default: "success" },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 }
  },
  setup(props) {
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k2 = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
      return parseFloat((bytes / Math.pow(k2, i2)).toFixed(2)) + " " + sizes[i2];
    };
    const formatDate = (date = new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    return {
      filesList
    };
  }
});
var _hoisted_1$13 = ["role"];
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_list_item = resolveComponent("va-file-upload-list-item");
  const _component_va_file_upload_gallery_item = resolveComponent("va-file-upload-gallery-item");
  const _component_va_file_upload_single_item = resolveComponent("va-file-upload-single-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${_ctx.type}`]),
    role: _ctx.type !== "single" ? "list" : void 0
  }, [
    _ctx.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.filesList, (file, index) => {
      return openBlock(), createBlock(_component_va_file_upload_list_item, {
        key: file.name,
        role: "listitem",
        file,
        color: _ctx.color,
        undo: _ctx.undo,
        undoDuration: _ctx.undoDuration,
        onRemove: ($event) => _ctx.$emit("remove", index)
      }, null, 8, ["file", "color", "undo", "undoDuration", "onRemove"]);
    }), 128)) : createCommentVNode("v-if", true),
    _ctx.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.filesList, (file, index) => {
      return openBlock(), createBlock(_component_va_file_upload_gallery_item, {
        role: "listitem",
        file,
        key: file.name,
        color: _ctx.color,
        undo: _ctx.undo,
        undoDuration: _ctx.undoDuration,
        onRemove: ($event) => _ctx.$emit("remove", index)
      }, null, 8, ["file", "color", "undo", "undoDuration", "onRemove"]);
    }), 128)) : createCommentVNode("v-if", true),
    _ctx.type === "single" && _ctx.filesList.length ? (openBlock(), createBlock(_component_va_file_upload_single_item, {
      key: 2,
      file: _ctx.filesList[_ctx.filesList.length - 1],
      onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
    }, null, 8, ["file"])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$13);
}
script$16.render = render$15;
script$16.__file = "src/components/va-file-upload/VaFileUploadList/VaFileUploadList.vue";
var VaFileUploadList = withConfigTransport(script$16);
var script38 = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton,
    VaFileUploadList
  },
  props: {
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    dropZoneText: { type: String, default: "Drag\u2019n\u2019drop files or" },
    uploadButtonText: { type: String, default: "Upload file" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const validateFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t2) => props.fileTypes.includes(t2));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e2) => {
      var _a, _b;
      const f2 = ((_a = e2.target) === null || _a === void 0 ? void 0 : _a.files) || ((_b = e2.dataTransfer) === null || _b === void 0 ? void 0 : _b.files);
      if (!f2) {
        return;
      }
      const validatedFiles = props.fileTypes ? validateFiles(Array.from(f2)) : f2;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e2) => {
      uploadFile(e2);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        files.value = validateFiles(files.value);
      }
    });
    return {
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      uploadFile,
      changeFieldValue,
      files,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});
var _hoisted_129 = { class: "va-file-upload__field" };
var _hoisted_216 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_38 = ["accept", "multiple", "disabled"];
function render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_file_upload_list = resolveComponent("va-file-upload-list");
  const _component_va_modal = resolveComponent("va-modal");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload", { "va-file-upload--dropzone": _ctx.dropzone }]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_129, [
        _ctx.dropzone ? (openBlock(), createElementBlock("div", _hoisted_216, toDisplayString(_ctx.dropZoneText), 1)) : createCommentVNode("v-if", true),
        createVNode(_component_va_button, {
          class: "va-file-upload__field__button",
          disabled: _ctx.disabled,
          color: _ctx.colorComputed,
          style: normalizeStyle({ "pointer-events": _ctx.dropzoneHighlight ? "none" : "" }),
          onChange: _ctx.changeFieldValue,
          onClick: _ctx.callFileDialogue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.uploadButtonText), 1)
          ]),
          _: 1
        }, 8, ["disabled", "color", "style", "onChange", "onClick"])
      ])
    ]),
    createBaseVNode("input", {
      ref: "fileInputRef",
      type: "file",
      class: "va-file-upload__field__input",
      tabindex: -1,
      "aria-hidden": "true",
      accept: _ctx.fileTypes,
      multiple: _ctx.type !== "single",
      disabled: _ctx.disabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.changeFieldValue && _ctx.changeFieldValue(...args)),
      onDragenter: _cache[1] || (_cache[1] = ($event) => _ctx.dropzoneHighlight = true),
      onDragleave: _cache[2] || (_cache[2] = ($event) => _ctx.dropzoneHighlight = false)
    }, null, 40, _hoisted_38),
    _ctx.files.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(_component_va_file_upload_list, {
      key: 0,
      type: _ctx.type,
      files: _ctx.files,
      color: _ctx.colorComputed,
      undo: _ctx.undo,
      undoDuration: _ctx.undoDuration,
      onRemove: _ctx.removeFile,
      onRemoveSingle: _ctx.removeSingleFile
    }, null, 8, ["type", "files", "color", "undo", "undoDuration", "onRemove", "onRemoveSingle"])) : createCommentVNode("v-if", true),
    createVNode(_component_va_modal, {
      modelValue: _ctx.modal,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.modal = $event),
      "hide-default-actions": "",
      title: "File validation",
      message: "File type is incorrect!"
    }, null, 8, ["modelValue"])
  ], 6);
}
script38.render = render39;
script38.__file = "src/components/va-file-upload/VaFileUpload.vue";
var VaFileUpload = withConfigTransport(script38);

// node_modules/vuestic-ui/dist/esm/index29.js
var isVaForm = (value) => !!value.focusInvalid;
var script39 = defineComponent({
  name: "VaForm",
  emits: ["validation"],
  props: {
    autofocus: { type: Boolean, default: false },
    tag: { type: String, default: "div" }
  },
  setup(props, { emit }) {
    const nestedFormElements = ref([]);
    const parentFormProvider = () => inject(FormServiceKey, void 0);
    provide(FormServiceKey, {
      onChildMounted: (child) => childMountedHandler(child),
      onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild)
    });
    const childMountedHandler = (child) => {
      nestedFormElements.value.push(child);
    };
    const childUnmountedHandler = (removableChild) => {
      nestedFormElements.value = nestedFormElements.value.filter((child) => child !== removableChild);
    };
    const reset = () => {
      nestedFormElements.value.filter(({ reset: reset2 }) => reset2).forEach((item) => {
        item.reset();
      });
    };
    const resetValidation = () => {
      nestedFormElements.value.filter(({ resetValidation: resetValidation2 }) => resetValidation2).forEach((item) => {
        item.resetValidation();
      });
    };
    const focus = () => {
      var _a;
      (_a = nestedFormElements.value.find(({ focus: focus2 }) => focus2)) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const focusInvalid = () => {
      const invalidComponent = nestedFormElements.value.find((item) => !isVaForm(item) && item.hasError());
      if (invalidComponent) {
        invalidComponent.focus();
      } else {
        nestedFormElements.value.forEach((item) => isVaForm(item) && item.focusInvalid());
      }
    };
    const validate = () => {
      const formValid = nestedFormElements.value.filter(({ validate: validate2 }) => validate2).map((child) => child.validate()).every((isValid) => isValid);
      emit("validation", formValid);
      return formValid;
    };
    const publicMethods = {
      reset,
      resetValidation,
      focus,
      focusInvalid,
      validate
    };
    onMounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) === null || _a === void 0 ? void 0 : _a.onChildMounted) === null || _b === void 0 ? void 0 : _b.call(_a, publicMethods);
      if (props.autofocus) {
        nextTick(focus);
      }
    });
    onUnmounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) === null || _a === void 0 ? void 0 : _a.onChildUnmounted) === null || _b === void 0 ? void 0 : _b.call(_a, publicMethods);
    });
    return publicMethods;
  }
});
function render40(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
script39.render = render40;
script39.__file = "src/components/va-form/VaForm.vue";
var VaForm = withConfigTransport(script39);

// node_modules/vuestic-ui/dist/esm/index33.js
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a;
    (_a = element.value) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", handler.value, { passive: true });
  };
  const removeScrollListener = () => {
    var _a;
    (_a = element.value) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", handler.value);
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};
var script40 = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: {
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(props, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) === null || _a === void 0 ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const { addScrollListener, removeScrollListener } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce_1(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});
var _hoisted_130 = { class: "va-infinite-scroll__spinner__default" };
function render41(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createBaseVNode("div", _hoisted_130, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["thickness", "color"])
          ])
        ]) : createCommentVNode("v-if", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
script40.render = render41;
script40.__file = "src/components/va-infinite-scroll/VaInfiniteScroll.vue";
var VaInfiniteScroll = withConfigTransport(script40);

// node_modules/vuestic-ui/dist/esm/index36.js
var script$53 = defineComponent({
  name: "VaList",
  props: {
    fit: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list--fit": props.fit }))
  })
});
function render$53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list", _ctx.computedClass]),
    role: "list"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$53.render = render$53;
script$53.__file = "src/components/va-list/VaList.vue";
var script$43 = defineComponent({
  name: "VaListItem",
  emits: ["focus", "click"],
  props: {
    ...useRouterLinkProps,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  setup(props) {
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = computed(() => ({
      "va-list-item--disabled": props.disabled
    }));
    return {
      ...useRouterLink(props),
      tabIndexComputed,
      computedClass
    };
  }
});
function render$43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-list-item", _ctx.computedClass]),
    role: "listitem",
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    tabindex: _ctx.tabIndexComputed
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-list-item__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 32)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
}
script$43.render = render$43;
script$43.__file = "src/components/va-list/VaListItem.vue";
var script$34 = defineComponent({
  name: "VaListLabel",
  props: {
    color: { type: String, default: "primary" }
  },
  setup: (props) => {
    const { getColor } = useColors();
    return {
      computedStyle: computed(() => ({
        color: getColor(props.color)
      }))
    };
  }
});
function render$34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-list-label",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script$34.render = render$34;
script$34.__file = "src/components/va-list/VaListLabel.vue";
var script$24 = defineComponent({
  name: "VaListItemLabel",
  props: {
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list-item-label--caption": props.caption })),
    computedStyle: computed(() => ({ "-webkit-line-clamp": props.lines }))
  })
});
function render$24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-label", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script$24.render = render$24;
script$24.__file = "src/components/va-list/VaListItemLabel.vue";
var script$17 = defineComponent({
  name: "VaListItemSection",
  props: {
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }))
  })
});
function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-section", _ctx.computedClass])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$17.render = render$16;
script$17.__file = "src/components/va-list/VaListItemSection.vue";
var script41 = defineComponent({
  name: "VaListSeparator",
  props: {
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }))
  })
});
function render42(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": "true",
    class: normalizeClass(["va-list-separator", _ctx.computedClass])
  }, null, 2);
}
script41.render = render42;
script41.__file = "src/components/va-list/VaListSeparator.vue";
var VaListItem = withConfigTransport(script$43);
var VaListLabel = withConfigTransport(script$34);
var VaListItemLabel = withConfigTransport(script$24);
var VaListItemSection = withConfigTransport(script$17);
var VaListSeparator = withConfigTransport(script41);
var VaList = withConfigTransport(script$53);

// node_modules/vuestic-ui/dist/esm/index37.js
var script$18 = defineComponent({
  name: "VaNavbar",
  props: {
    color: { type: String, default: "secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const color = computed(() => getColor(props.color));
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    return {
      computedStyle,
      shapeStyleComputed
    };
  }
});
var _hoisted_1$14 = { class: "va-navbar__content" };
var _hoisted_217 = {
  key: 0,
  class: "va-navbar__left"
};
var _hoisted_39 = {
  key: 1,
  class: "va-navbar__center"
};
var _hoisted_46 = {
  key: 2,
  class: "va-navbar__right"
};
function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: "va-navbar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createBaseVNode("div", _hoisted_1$14, [
      _ctx.$slots.left ? (openBlock(), createElementBlock("div", _hoisted_217, [
        renderSlot(_ctx.$slots, "left")
      ])) : createCommentVNode("v-if", true),
      _ctx.$slots.center ? (openBlock(), createElementBlock("div", _hoisted_39, [
        renderSlot(_ctx.$slots, "center")
      ])) : createCommentVNode("v-if", true),
      _ctx.$slots.right ? (openBlock(), createElementBlock("div", _hoisted_46, [
        renderSlot(_ctx.$slots, "right")
      ])) : createCommentVNode("v-if", true)
    ]),
    _ctx.shape ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "va-navbar__background-shape",
      style: normalizeStyle(_ctx.shapeStyleComputed)
    }, null, 4)) : createCommentVNode("v-if", true)
  ], 4);
}
script$18.render = render$17;
script$18.__file = "src/components/va-navbar/VaNavbar.vue";
var script42 = defineComponent({
  name: "VaNavbarItem"
});
var _hoisted_131 = { class: "va-navbar__item" };
function render43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_131, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script42.render = render43;
script42.__file = "src/components/va-navbar/VaNavbarItem/VaNavbarItem.vue";
var VaNavbar = withConfigTransport(script$18);
var VaNavbarItem = withConfigTransport(script42);

// node_modules/vuestic-ui/dist/esm/useArrayRefs.js
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
true ? Object.freeze({}) : {};
true ? Object.freeze([]) : [];
var extend = Object.assign;
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var hasOwn = (val, key2) => hasOwnProperty3.call(val, key2);
var isArray4 = Array.isArray;
var isMap2 = (val) => toTypeString(val) === "[object Map]";
var isString2 = (val) => typeof val === "string";
var isSymbol4 = (val) => typeof val === "symbol";
var isObject7 = (val) => val !== null && typeof val === "object";
var objectToString2 = Object.prototype.toString;
var toTypeString = (value) => objectToString2.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key2) => isString2(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
function warn2(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
var createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
var newTracked = (dep) => (dep.n & trackOpBit) > 0;
var targetMap = /* @__PURE__ */ new WeakMap();
var trackOpBit = 1;
var activeEffect;
var ITERATE_KEY = Symbol(true ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    const eventInfo = true ? { effect: activeEffect, target, type, key: key2 } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray4(target)) {
    depsMap.forEach((dep, key3) => {
      if (key3 === "length" || key3 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type) {
      case "add":
        if (!isArray4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = true ? { target, type, key: key2, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (true) {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (true) {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of isArray4(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (effect.onTrigger) {
        effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
      }
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol4));
var get = createGetter();
var readonlyGet = createGetter(true);
var arrayInstrumentations = createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray4(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol4(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef2(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject7(res)) {
      return isReadonly2 ? readonly(res) : reactive2(res);
    }
    return res;
  };
}
var set = createSetter();
function createSetter(shallow = false) {
  return function set2(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (isReadonly(oldValue) && isRef2(oldValue) && !isRef2(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray4(target) && isRef2(oldValue) && !isRef2(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray4(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key2, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key2) {
  const hadKey = hasOwn(target, key2);
  const oldValue = target[key2];
  const result = Reflect.deleteProperty(target, key2);
  if (result && hadKey) {
    trigger(target, "delete", key2, void 0, oldValue);
  }
  return result;
}
function has(target, key2) {
  const result = Reflect.has(target, key2);
  if (!isSymbol4(key2) || !builtInSymbols.has(key2)) {
    track(target, "has", key2);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray4(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key2) {
    if (true) {
      warn2(`Set operation on key "${String(key2)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key2) {
    if (true) {
      warn2(`Delete operation on key "${String(key2)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toShallow = (value) => value;
var getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key2);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$1(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key2);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  } else if (true) {
    checkIdentityKeys(target, has2, key2);
  }
  const oldValue = get2.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key2, value, oldValue);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  } else if (true) {
    checkIdentityKeys(target, has2, key2);
  }
  const oldValue = get2 ? get2.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger(target, "delete", key2, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = true ? isMap2(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap2(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key2 = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key2}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1(this, key2);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has2, key2) {
  const rawKey = toRaw(key2);
  if (rawKey !== key2 && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject7(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
var toReactive = (value) => isObject7(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject7(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (true) {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    if (true) {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef2(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function shallowRef2(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef2(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
};
var useArrayRefs = () => {
  const itemRefs = shallowRef2([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/esm/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "value" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const isStringOrNumber = (option) => {
    const typeOfOption = typeof option;
    return typeOfOption === "string" || typeOfOption === "number";
  };
  const getOptionProperty = (option, selector) => {
    return !selector || isStringOrNumber(option) ? option : getValueByKey(option, selector);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  const getOptionByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.options.find((option) => value === getValue2(option)) || value;
  };
  const getText = (option) => getOptionProperty(option, props.textBy);
  const getDisabled = (option) => getValueByKey(option, props.disabledBy);
  const getTrackBy = (option) => getOptionProperty(option, props.trackBy);
  const getGroupBy = (option) => getOptionProperty(option, props.groupBy);
  return {
    getValue: getValue2,
    getOptionByValue,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/esm/index44.js
var script43 = defineComponent({
  name: "VaRadio",
  emits: ["update:modelValue", "focus"],
  props: {
    ...useFormProps,
    modelValue: { type: [Boolean, Array, String, Object], default: null },
    option: { default: null },
    name: { type: String, default: "" },
    label: { type: String, default: "" },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    tabindex: { type: Number, default: 0 }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const isActive = computed(() => props.modelValue === props.option);
    const { computedClasses } = useForm("va-radio", props);
    const computedClass = computed(() => ({
      "va-radio--left-label": props.leftLabel,
      ...computedClasses
    }));
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return {
        borderColor: getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return { borderColor: getColor(props.color) };
    });
    const computedLabel = computed(() => props.label || props.option);
    const onClick = (e2) => {
      if (props.readonly || props.disabled) {
        return;
      }
      emit("update:modelValue", props.option, e2);
    };
    const onFocus = (e2) => emit("focus", e2);
    return {
      computedClass,
      isActive,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      computedLabel,
      onClick,
      onFocus,
      computedName: computed(() => props.name || generateUniqueId()),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_133 = ["checked", "disabled", "readonly", "name", "value", "aria-checked", "tabindex"];
var _hoisted_218 = { class: "va-radio__text" };
function render44(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["va-radio", _ctx.computedClass])
  }, [
    createBaseVNode("input", {
      class: "va-radio__input",
      type: "radio",
      checked: _ctx.isActive,
      disabled: _ctx.$props.disabled,
      readonly: _ctx.$props.readonly,
      name: _ctx.computedName,
      value: _ctx.computedLabel,
      "aria-checked": _ctx.isActive,
      tabindex: _ctx.tabIndexComputed,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args))
    }, null, 40, _hoisted_133),
    createBaseVNode("span", {
      "aria-hidden": "true",
      class: "va-radio__icon",
      style: normalizeStyle(_ctx.iconComputedStyles)
    }, [
      createBaseVNode("span", {
        class: "va-radio__icon__background",
        style: normalizeStyle(_ctx.iconBackgroundComputedStyles)
      }, null, 4),
      createBaseVNode("span", {
        class: "va-radio__icon__dot",
        style: normalizeStyle(_ctx.iconDotComputedStyles)
      }, null, 4)
    ], 4),
    createBaseVNode("span", _hoisted_218, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.computedLabel), 1)
      ])
    ])
  ], 2);
}
script43.render = render44;
script43.__file = "src/components/va-radio/VaRadio.vue";
var VaRadio = withConfigTransport(script43);

// node_modules/vuestic-ui/dist/esm/index49.js
var script44 = defineComponent({
  name: "VaSwitch",
  components: { VaProgressCircle, VaMessageListWrapper: script21 },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  props: {
    ...useSelectableProps,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "gray" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { isChecked, computedError, isIndeterminate, computedErrorMessages, ...selectable } = useSelectable(props, emit, elements);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick_1(props, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      onKeyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size2 = { small: "15px", medium: "20px", large: "25px" };
      return size2[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: props.error ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: props.error ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value
    }));
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => ({
      id: props.id,
      name: props.name,
      disabled: props.disabled,
      readonly: props.readonly,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: !!props.modelValue,
      ariaLabelledby: ariaLabelIdComputed.value,
      "aria-invalid": !!computedErrorMessages.value.length,
      "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
    }));
    return {
      ...selectable,
      computedErrorMessages,
      isChecked,
      computedError,
      isIndeterminate,
      keyboardFocusListeners,
      computedInnerLabel,
      computedLabel,
      computedClass,
      styleComputed,
      progressCircleSize,
      trackStyle,
      labelStyle,
      trackLabelStyle,
      ariaLabelIdComputed,
      inputAttributesComputed
    };
  }
});
var _hoisted_134 = { class: "va-switch__checker-wrapper" };
var _hoisted_219 = { class: "va-switch__checker" };
var _hoisted_310 = ["id"];
function render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-switch", _ctx.computedClass]),
    style: normalizeStyle(_ctx.styleComputed),
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-switch__container",
        tabindex: "-1",
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-switch__inner",
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-switch__input",
            role: "switch"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]), ["enter"]))
          }), null, 16),
          createBaseVNode("div", {
            class: "va-switch__track",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.trackStyle)
          }, [
            _ctx.computedInnerLabel || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-switch__track-label",
              style: normalizeStyle(_ctx.trackLabelStyle)
            }, [
              renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                createTextVNode(toDisplayString(_ctx.computedInnerLabel), 1)
              ])
            ], 4)) : createCommentVNode("v-if", true),
            createBaseVNode("div", _hoisted_134, [
              createBaseVNode("span", _hoisted_219, [
                _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
                  key: 0,
                  indeterminate: "",
                  size: _ctx.progressCircleSize,
                  color: _ctx.trackStyle.backgroundColor
                }, null, 8, ["size", "color"])) : createCommentVNode("v-if", true)
              ])
            ])
          ], 4)
        ]),
        _ctx.computedLabel || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "label",
          class: "va-switch__label",
          style: normalizeStyle(_ctx.labelStyle),
          id: _ctx.ariaLabelIdComputed,
          onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["stop"]), ["enter"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.computedLabel), 1)
          ])
        ], 44, _hoisted_310)) : createCommentVNode("v-if", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
script44.render = render45;
script44.__file = "src/components/va-switch/VaSwitch.vue";
var VaSwitch = withConfigTransport(script44);

// node_modules/vuestic-ui/dist/esm/index38.js
var script45 = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper: script21
  },
  emits: [...useStatefulEmits],
  props: {
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Object, Array] }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, props.defaultValue);
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const getKey = (option) => getTrackBy(option);
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => {
      valueComputed.value = void 0;
    };
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const { computedError, computedErrorMessages } = useValidation(props, emit, reset, focus);
    const computedProps = computed(() => pick_1(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (__DEV__ && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue: getValue2,
      getText,
      getKey,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});
var _hoisted_135 = { class: "va-option-list__list" };
function render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("ul", _hoisted_135, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return openBlock(), createElementBlock("li", {
            key: _ctx.getKey(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              _ctx.$props.type === "radio" ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                key: 0,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                option: _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                key: 1,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(_component_va_switch, mergeProps({
                key: 2,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]);
        }), 128))
      ])
    ]),
    _: 3
  }, 8, ["error", "error-messages", "error-count"]);
}
script45.render = render46;
script45.__file = "src/components/va-option-list/VaOptionList.vue";
var VaOptionList = withConfigTransport(script45);

// node_modules/vuestic-ui/dist/esm/index39.js
var setPaginationRange = (value = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (value - paginationMiddlePage <= 0 || value > pages) {
      start = 1;
    } else {
      start = value + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(value - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i2 = 0; i2 < visiblePages; i2++) {
    range.push(start + i2);
  }
  if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};
var script46 = defineComponent({
  name: "VaPagination",
  components: { VaButtonGroup, VaButton },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["medium", "small", "large"].includes(v2)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "first_page" },
    boundaryIconRight: { type: String, default: "last_page" },
    directionIconLeft: { type: String, default: "chevron_left" },
    directionIconRight: { type: String, default: "chevron_right" }
  },
  setup(props, { emit }) {
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usedTotal = computed(() => !!((props.total || props.pageSize === 0) && props.pageSize));
    const { valueComputed } = useStateful(props, emit);
    const { textColorComputed } = useTextColor();
    const currentValue = computed({
      get: () => usedTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
      const value = currentValue.value || 1;
      const totalPages = usedTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usedTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : props.pages);
    const IsLstPageNotVisible = computed(() => !!props.visiblePages && lastPage.value > props.visiblePages);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers, input } = props;
      return input || IsLstPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => props.input || IsLstPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = `${currentValue.value}`;
      nextTick(() => {
        var _a;
        return (_a = htmlInput.value) === null || _a === void 0 ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const onUserInput = (pageNum) => {
      if (pageNum === "..." || pageNum < 1 || pageNum > lastPage.value) {
        return;
      }
      currentValue.value = usedTotal.value ? (pageNum - 1) * props.pageSize + 1 : pageNum;
    };
    const resetInput = () => {
      var _a;
      inputValue.value = "";
      (_a = htmlInput.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor } = useColors();
    const activeButtonStyle = (buttonValue) => {
      if (buttonValue === currentValue.value) {
        return {
          backgroundColor: getColor(props.color),
          color: textColorComputed.value
        };
      }
      return {
        color: getColor(props.color)
      };
    };
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1
    }));
    watch([usedTotal, () => props.pages], () => {
      if (__DEV__ && usedTotal.value && props.pages) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    return {
      currentValue,
      lastPage,
      changeValue,
      inputValue,
      showPagination,
      showBoundaryLinks,
      onUserInput,
      activeButtonStyle,
      showDirectionLinks,
      paginationRange,
      focusInput,
      inputStyleComputed
    };
  }
});
var _hoisted_136 = ["disabled", "placeholder"];
function render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return _ctx.showPagination ? (openBlock(), createBlock(_component_va_button_group, {
    key: 0,
    class: "va-pagination",
    flat: _ctx.$props.flat,
    size: _ctx.$props.size,
    color: _ctx.$props.color,
    outline: "",
    onKeydown: [
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onUserInput(_ctx.currentValue - 1), ["stop"]), ["left"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.onUserInput(_ctx.currentValue + 1), ["stop"]), ["right"]))
    ]
  }, {
    default: withCtx(() => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        "aria-label": "go first page",
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.boundaryIconLeft,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onUserInput(1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("v-if", true),
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        "aria-label": "go prev page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.directionIconLeft,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onUserInput(_ctx.currentValue - 1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("v-if", true),
      !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginationRange, (n2, i2) => {
          return openBlock(), createBlock(_component_va_button, {
            key: i2,
            class: normalizeClass(["va-pagination__numeric-button", { "va-button--ellipsis": n2 === "..." }]),
            outline: "",
            "aria-label": `go to ${n2} page`,
            "aria-current": n2 === _ctx.currentValue,
            style: normalizeStyle(_ctx.activeButtonStyle(n2)),
            disabled: _ctx.$props.disabled || n2 === "...",
            onClick: ($event) => _ctx.onUserInput(n2)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(n2), 1)
            ]),
            _: 2
          }, 1032, ["aria-label", "aria-current", "style", "disabled", "class", "onClick"]);
        }), 128))
      ]) : withDirectives((openBlock(), createElementBlock("input", {
        key: 3,
        ref: "htmlInput",
        class: normalizeClass(["va-pagination__input va-button", { "va-pagination__input--flat": _ctx.$props.flat }]),
        "aria-label": "enter the page number to go",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
        disabled: _ctx.$props.disabled,
        placeholder: `${_ctx.currentValue}/${_ctx.lastPage}`,
        style: normalizeStyle(_ctx.inputStyleComputed),
        onKeydown: _cache[3] || (_cache[3] = withKeys((...args) => _ctx.changeValue && _ctx.changeValue(...args), ["enter"])),
        onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.focusInput && _ctx.focusInput(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
      }, null, 46, _hoisted_136)), [
        [vModelText, _ctx.inputValue]
      ]),
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 4,
        "aria-label": "go next page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.directionIconRight,
        onClick: _cache[6] || (_cache[6] = ($event) => _ctx.onUserInput(_ctx.currentValue + 1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("v-if", true),
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 5,
        "aria-label": "go last page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.boundaryIconRight,
        onClick: _cache[7] || (_cache[7] = ($event) => _ctx.onUserInput(_ctx.lastPage))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["flat", "size", "color"])) : createCommentVNode("v-if", true);
}
script46.render = render47;
script46.__file = "src/components/va-pagination/VaPagination.vue";
var VaPagination = withConfigTransport(script46);

// node_modules/vuestic-ui/dist/esm/index40.js
var script47 = defineComponent({
  name: "VaParallax",
  props: {
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  },
  setup(props) {
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const targetElement = computed(() => {
      var _a;
      if (!props.target) {
        return getScrollableParent((_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const getScrollableParent = (element) => {
      if (!element) {
        return document.body;
      }
      if (element.scrollHeight > element.clientHeight) {
        return element;
      }
      return getScrollableParent(element.parentElement);
    };
    const imgHeight = computed(() => {
      var _a;
      return ((_a = img.value) === null || _a === void 0 ? void 0 : _a.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a, _b;
      const offset = ((_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) === null || _b === void 0 ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props.height;
      elOffsetTop.value = offset.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", translate);
      (_b = targetElement.value) === null || _b === void 0 ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", translate);
      (_b = targetElement.value) === null || _b === void 0 ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a, _b;
      if ((_a = img.value) === null || _a === void 0 ? void 0 : _a.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) === null || _b === void 0 ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return {
      img,
      rootElement,
      computedWrapperStyles,
      computedImgStyles
    };
  }
});
var _hoisted_137 = { class: "va-parallax__image-container" };
var _hoisted_220 = ["src", "alt"];
var _hoisted_311 = { class: "va-parallax__item-container" };
function render48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-parallax",
    style: normalizeStyle(_ctx.computedWrapperStyles)
  }, [
    createBaseVNode("div", _hoisted_137, [
      createBaseVNode("img", {
        ref: "img",
        class: "va-parallax__image",
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        style: normalizeStyle(_ctx.computedImgStyles)
      }, null, 12, _hoisted_220)
    ]),
    createBaseVNode("div", _hoisted_311, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
script47.render = render48;
script47.__file = "src/components/va-parallax/VaParallax.vue";
var VaParallax = withConfigTransport(script47);

// node_modules/vuestic-ui/dist/esm/index41.js
var VaDropdownProps = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var script48 = defineComponent({
  name: "VaPopover",
  components: { VaDropdown, VaIcon },
  props: {
    ...VaDropdownProps,
    trigger: { default: "hover" },
    color: { type: String, default: "dark" },
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  },
  setup(props, { slots }) {
    const VaDropdownPropValues = filterComponentProps(props, VaDropdownProps);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(() => showTitleComputed.value || showBodyComputed.value);
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return {
      textColorComputed,
      VaDropdownPropValues,
      showBodyComputed,
      showIconComputed,
      showTitleComputed,
      computedPopoverStyle,
      showPopoverContentComputed
    };
  }
});
var _hoisted_138 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_221 = { key: 1 };
var _hoisted_312 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_47 = {
  key: 1,
  class: "va-popover__body"
};
function render49(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps(_ctx.VaDropdownPropValues, {
    "model-value": _ctx.modelValue,
    "close-on-click-outside": _ctx.autoHide,
    offset: _ctx.$props.offset,
    class: "va-popover"
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        style: normalizeStyle(_ctx.computedPopoverStyle),
        class: "va-popover__content",
        role: "tooltip"
      }, [
        _ctx.showIconComputed ? (openBlock(), createElementBlock("div", _hoisted_138, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, {
              name: _ctx.$props.icon,
              color: _ctx.textColorComputed
            }, null, 8, ["name", "color"])
          ])
        ])) : createCommentVNode("v-if", true),
        _ctx.showPopoverContentComputed ? (openBlock(), createElementBlock("div", _hoisted_221, [
          _ctx.showTitleComputed ? (openBlock(), createElementBlock("div", _hoisted_312, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.title), 1)
            ])
          ])) : createCommentVNode("v-if", true),
          _ctx.showBodyComputed ? (openBlock(), createElementBlock("div", _hoisted_47, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.message), 1)
            ])
          ])) : createCommentVNode("v-if", true)
        ])) : createCommentVNode("v-if", true)
      ], 4)
    ]),
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["model-value", "close-on-click-outside", "offset"]);
}
script48.render = render49;
script48.__file = "src/components/va-popover/VaPopover.vue";
var VaPopover = withConfigTransport(script48);

// node_modules/vuestic-ui/dist/esm/index42.js
var script49 = defineComponent({
  name: "VaProgressBar",
  props: {
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    return {
      rootClass: computed(() => ({
        "va-progress-bar--square": !props.rounded,
        [`va-progress-bar--${props.size}`]: isTextSize.value
      })),
      rooStyle: computed(() => ({
        "--va-progress-bar-color": colorComputed.value,
        "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
      })),
      wrapperStyle: computed(() => ({
        height: getCSSHeight()
      })),
      bufferStyle: computed(() => ({
        width: `${props.indeterminate ? 100 : clamp_1(props.buffer, 0, 100)}%`,
        color: textColorComputed.value,
        [props.reverse ? "right" : "left"]: 0
      })),
      progressStyle: computed(() => ({
        width: `${clamp_1(props.modelValue, 0, 100)}%`,
        marginLeft: props.reverse ? "auto" : void 0
      })),
      intermediateStyle: computed(() => ({
        animationDirection: props.reverse ? "reverse" : "normal"
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: "progress state",
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      }))
    };
  }
});
var _hoisted_139 = {
  key: 0,
  class: "va-progress-bar__info"
};
function render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-bar", _ctx.rootClass],
    style: _ctx.rooStyle
  }, _ctx.ariaAttributesComputed), [
    !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_139, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
        _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
        ], 2112)) : createCommentVNode("v-if", true)
      ])
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: "va-progress-bar__wrapper",
      style: normalizeStyle(_ctx.wrapperStyle)
    }, [
      createBaseVNode("div", {
        class: "va-progress-bar__buffer",
        style: normalizeStyle(_ctx.bufferStyle)
      }, [
        _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
          _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
          ], 2112)) : createCommentVNode("v-if", true)
        ]) : createCommentVNode("v-if", true)
      ], 4),
      _ctx.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-start",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4),
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-end",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4)
      ], 64)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-progress-bar__progress",
        style: normalizeStyle(_ctx.progressStyle)
      }, null, 4))
    ], 4)
  ], 16);
}
script49.render = render50;
script49.__file = "src/components/va-progress-bar/VaProgressBar.vue";
var VaProgressBar = withConfigTransport(script49);

// node_modules/vuestic-ui/dist/esm/index45.js
var RatingValue;
(function(RatingValue2) {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
})(RatingValue || (RatingValue = {}));
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp_1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor: getTextColor2 } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getTextColor2(computedColor.value);
    }
    return getTextColor2(backgroundColor.value);
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};
var script$25 = defineComponent({
  name: "VaRatingItem",
  components: { VaIcon },
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(props, { emit }) {
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onEnter = () => {
      modelValue.value = 1;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    return {
      computedColor,
      rootEl,
      onEnter,
      onClick,
      onMouseMove,
      onMouseLeave,
      visibleValue,
      computedIconName: computed(() => {
        if (props.halves && visibleValue.value === RatingValue.HALF) {
          return props.halfIcon;
        }
        if (visibleValue.value === RatingValue.EMPTY) {
          return props.emptyIcon;
        }
        return props.icon;
      }),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_1$15 = ["tabindex"];
function render$25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootEl",
    class: "va-rating-item",
    role: "button",
    tabindex: _ctx.tabIndexComputed,
    onKeyup: [
      _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["enter"])),
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {
      props: { value: _ctx.visibleValue, onClick: _ctx.onClick }
    }, () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor,
        onClick: _ctx.onClick
      }, null, 8, ["name", "size", "color", "onClick"])
    ])
  ], 40, _hoisted_1$15);
}
script$25.render = render$25;
script$25.__file = "src/components/va-rating/components/VaRatingItem/VaRatingItem.vue";
var script$19 = defineComponent({
  name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(props) {
    return {
      ...useVaRatingColors(props),
      ...useSize(props, "VaRating")
    };
  }
});
function render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`
    })
  }, toDisplayString(_ctx.itemNumber), 5);
}
script$19.render = render$18;
script$19.__file = "src/components/va-rating/components/VaRatingItemNumberButton.vue";
var VaRatingItemProps = extractComponentProps(script$25);
var VaRatingItemNumberButtonProps = extractComponentProps(script$19, ["modelValue", "itemNumber"]);
var script50 = defineComponent({
  name: "VaRating",
  props: {
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormProps,
    ...VaRatingItemProps,
    ...VaRatingItemNumberButtonProps,
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] }
  },
  emits: ["update:modelValue"],
  components: { VaRatingItem: script$25, VaRatingItemNumberButton: script$19 },
  setup(props) {
    const { computedClasses: rootClass } = useForm("va-rating", props);
    const rating = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    return {
      ...useVaRatingColors(props),
      ...rating,
      rootClass,
      VaRatingItemProps: filterComponentProps(props, VaRatingItemProps),
      VaRatingItemNumberButtonProps: filterComponentProps(props, VaRatingItemNumberButtonProps),
      isInteractionsEnabled,
      tabIndexComputed: computed(() => isInteractionsEnabled.value ? 0 : void 0),
      onArrowKeyPress: (direction) => {
        const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
        rating.onItemValueUpdate(rating.visibleValue.value, step * direction);
      }
    };
  }
});
var _hoisted_140 = ["aria-label"];
function render51(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": `current rating ${_ctx.$props.modelValue} of ${_ctx.$props.max}`
  }, [
    createBaseVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys(($event) => _ctx.onArrowKeyPress(-1), ["left"])),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.onArrowKeyPress(1), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return openBlock(), createBlock(_component_va_rating_item, mergeProps({ key: itemNumber }, _ctx.VaRatingItemProps, {
          "aria-label": `vote rating ${itemNumber} of ${_ctx.$props.max}`,
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: ($event) => _ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event),
          "onUpdate:modelValue": ($event) => _ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event)
        }), createSlots({ _: 2 }, [
          _ctx.$props.numbers ? {
            name: "default",
            fn: withCtx(({ props }) => [
              createVNode(_component_VaRatingItemNumberButton, mergeProps(_ctx.VaRatingItemNumberButtonProps, {
                "model-value": props.value,
                "item-number": itemNumber,
                onClick: props.onClick
              }), null, 16, ["model-value", "item-number", "onClick"])
            ])
          } : void 0
        ]), 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
      }), 128))
    ], 32),
    _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "va-rating__text-wrapper",
      style: normalizeStyle({ color: _ctx.computedColor })
    }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_140);
}
script50.render = render51;
script50.__file = "src/components/va-rating/VaRating.vue";
var VaRatingItem = withConfigTransport(script$25);
var VaRating = withConfigTransport(script50);

// node_modules/vuestic-ui/dist/esm/index46.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections, emit) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= maxSelections.value;
  };
  const addOption = (optionToAdd) => {
    const newSelectedOptions = [...selections.value, optionToAdd];
    emit("update:modelValue", newSelectedOptions);
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};
var script$110 = defineComponent({
  name: "VaSelectOptionList",
  components: { VaIcon },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: {
    ...useColorProps,
    options: { type: Array, default: () => [] },
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    getGroupBy: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: {
      type: [String, Number, Object],
      default: null
    }
  },
  setup(props, { emit }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const rootElement = shallowRef();
    const itemRefs = ref({});
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        emit("scroll-bottom");
      }
    };
    const beforeUpdate = () => {
      itemRefs.value = {};
    };
    const setItemRef = (option) => (el) => {
      if (el) {
        itemRefs.value[props.getTrackBy(option)] = el;
      }
    };
    const hoveredOptionComputed = computed({
      get: () => props.hoveredOption || null,
      set: (value) => emit("update:hoveredOption", value)
    });
    const filteredOptions = computed(() => {
      if (!props.search) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = props.getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !option.group) {
        groups._noGroup.push(option);
      } else {
        const groupBy = props.getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const selectOption = (option) => emit("select-option", option);
    const getOptionIcon = (option) => typeof option === "object" ? option.icon : void 0;
    const getOptionClass = (option) => ({
      "va-select-option-list__option": true,
      "va-select-option-list__option--selected": props.getSelectedState(option)
    });
    const getOptionStyle = (option) => ({
      color: props.getSelectedState(option) ? getColor(props.color) : "inherit",
      backgroundColor: isHovered(option) ? getHoverColor2(getColor(props.color)) : "transparent"
    });
    const isHovered = (option) => {
      if (!hoveredOptionComputed.value) {
        return false;
      }
      if (typeof option === "string") {
        return option === hoveredOptionComputed.value;
      }
      if (!props.getTrackBy) {
        return false;
      }
      return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option);
    };
    const updateHoveredOption = (option) => {
      hoveredOptionComputed.value = option || null;
    };
    const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
      return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value);
    }));
    const hoverPreviousOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1));
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value - 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1];
        } else {
          emit("no-previous-option-to-hover");
        }
      }
    };
    const hoverNextOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0]);
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value + 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1];
        }
      }
    };
    const hoverFirstOption = () => {
      if (filteredOptions.value.length > 0) {
        updateHoveredOption(filteredOptions.value[0]);
      }
    };
    const focus = () => {
      var _a;
      (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
    };
    const scrollToOption = (option) => {
      if (!option) {
        return;
      }
      const element = itemRefs.value[props.getTrackBy(option)];
      if (element) {
        scrollToElement(element);
      }
    };
    watch(() => props.hoveredOption, (newOption) => newOption && scrollToOption(newOption));
    const publicMethods = {
      hoverPreviousOption,
      hoverNextOption,
      hoverFirstOption,
      focus,
      scrollToOption
    };
    return {
      rootElement,
      getColor,
      filteredOptions,
      optionGroups,
      onScroll,
      beforeUpdate,
      setItemRef,
      selectOption,
      getOptionIcon,
      getOptionClass,
      getOptionStyle,
      updateHoveredOption,
      ...publicMethods
    };
  }
});
var _hoisted_1$16 = ["tabindex"];
var _hoisted_2$13 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
var _hoisted_313 = ["aria-selected", "onClick", "onMouseover"];
var _hoisted_48 = {
  key: 0,
  class: "va-select-option-list no-options"
};
function render$19(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2$13, toDisplayString(groupName), 1)) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
          return openBlock(), createElementBlock("div", {
            key: _ctx.$props.getTrackBy(option),
            ref_for: true,
            ref: _ctx.setItemRef(option),
            role: "option",
            "aria-selected": !!_ctx.$props.getSelectedState(option),
            class: normalizeClass(_ctx.getOptionClass(option)),
            style: normalizeStyle(_ctx.getOptionStyle(option)),
            onClick: ($event) => _ctx.selectOption(option),
            onMouseover: ($event) => _ctx.updateHoveredOption(option)
          }, [
            _ctx.getOptionIcon(option) ? (openBlock(), createBlock(_component_va_icon, {
              key: 0,
              size: "small",
              class: "va-select-option-list__option--icon",
              name: _ctx.getOptionIcon(option)
            }, null, 8, ["name"])) : createCommentVNode("v-if", true),
            createBaseVNode("span", null, toDisplayString(_ctx.getText(option)), 1),
            withDirectives(createVNode(_component_va_icon, {
              class: "va-select-option-list__option--selected-icon",
              size: "small",
              name: "done",
              color: _ctx.getColor(_ctx.$props.color)
            }, null, 8, ["color"]), [
              [vShow, _ctx.$props.getSelectedState(option)]
            ])
          ], 46, _hoisted_313);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_48, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("v-if", true)
  ], 40, _hoisted_1$16);
}
script$110.render = render$19;
script$110.__file = "src/components/va-select/VaSelectOptionList/VaSelectOptionList.vue";
var VaSelectOptionList = withConfigTransport(script$110);
var script51 = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper: script26
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormProps,
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    separator: { type: String, default: ", " },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "Items not found" },
    fixed: { type: Boolean, default: true },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    dropdownIcon: {
      type: [String, Object],
      default: () => ({
        open: "expand_more",
        close: "expand_less"
      }),
      validator: (value) => {
        if (typeof value === "string") {
          return true;
        }
        const isOpenIconString = typeof value.open === "string";
        const isCloseIconString = typeof value.close === "string";
        return isOpenIconString && isCloseIconString;
      }
    },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    requiredMark: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep();
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const { getHoverColor: getHoverColor2, getColor } = useColors();
    const { getOptionByValue, getValue: getValue2, getText, getTrackBy, getGroupBy } = useSelectableList(props);
    const { validate, computedError, computedErrorMessages } = useValidation(props, emit, () => reset(), () => focus());
    const colorComputed = computed(() => getColor(props.color));
    const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
    const onScrollBottom = () => {
      emit("scroll-bottom");
    };
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const valueComputed = computed({
      get() {
        const value = getOptionByValue(props.modelValue);
        if (props.multiple) {
          if (!value) {
            return [];
          }
          if (!Array.isArray(value)) {
            return [value];
          }
          return value;
        }
        if (Array.isArray(value)) {
          warn("Model value should be a string or a number for a single Select.");
          if (value.length) {
            return value[value.length - 1];
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(value));
        }
      }
    });
    const valueComputedString = computed(() => {
      if (!valueComputed.value) {
        return props.clearValue;
      }
      if (typeof valueComputed.value === "string" || typeof valueComputed.value === "number") {
        return valueComputed.value;
      }
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
      }
      return getText(valueComputed.value);
    });
    const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
    const { canBeCleared, clearIconProps, onFocus, onBlur } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      return props.multiple && Array.isArray(valueComputed.value) ? !!valueComputed.value.length : canBeCleared.value;
    });
    const toggleIcon = computed(() => {
      if (!props.dropdownIcon) {
        return "";
      }
      if (typeof props.dropdownIcon === "string") {
        return props.dropdownIcon;
      }
      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v2) => Array.isArray(v2.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit);
        const isSelected = checkIsOptionSelected(getValue2(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue2(option), getValue2(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          addOption(getValue2(option));
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : { ...option };
        hideAndFocus();
      }
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) === null || _a === void 0 ? void 0 : _a.some((option) => getText(option) === searchInput.value);
      if (!(props.allowCreate === "unique" && hasAddedOption)) {
        emit("create-new", searchInput.value);
        searchInput.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value) {
        return;
      }
      if (!showDropdownContent.value) {
        showDropdown();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && searchInput.value !== "";
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const hoverPreviousOption = () => {
      var _a;
      (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.hoverPreviousOption();
    };
    const hoverNextOption = () => {
      var _a;
      (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.hoverNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? showDropdown() : hideDropdown();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const hideDropdown = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const toggleDropdown = () => {
      if (showDropdownContent.value) {
        hideAndFocus();
      } else {
        showDropdown();
      }
    };
    const onSelectClick = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      toggleDropdown();
    };
    const hideAndFocus = () => {
      hideDropdown();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) === null || _b === void 0 ? void 0 : _b.hoverFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const focus = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick((_a = input.value) === null || _a === void 0 ? void 0 : _a.blur);
    };
    const reset = () => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) === null || _a === void 0 ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key2) => key2 === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    return {
      isFocused,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      onSelectClick,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueComputed,
      valueComputedString,
      showClearIcon,
      toggleIcon,
      computedErrorMessages,
      computedError,
      filteredOptions,
      checkIsOptionSelected,
      closeOnContentClick,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      hoverPreviousOption,
      hoverNextOption,
      showDropdownContentComputed,
      showDropdown,
      hideDropdown,
      hideAndFocus,
      toggleDropdown,
      toggleIconColor,
      onHintedSearch,
      getText,
      getTrackBy,
      getGroupBy,
      onScrollBottom,
      clearIconProps,
      isPlaceholder
    };
  }
});
var _hoisted_141 = {
  key: 0,
  class: "va-select__placeholder"
};
var _hoisted_222 = { class: "va-select-dropdown__options-wrapper" };
function render52(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    ref: "dropdown",
    class: "va-select__dropdown va-select-dropdown",
    trigger: "none",
    anchorSelector: ".va-input-wrapper__field",
    placement: _ctx.$props.placement,
    disabled: _ctx.$props.disabled,
    "max-height": _ctx.$props.maxHeight,
    fixed: _ctx.$props.fixed,
    "close-on-content-click": _ctx.closeOnContentClick,
    stateful: false,
    offset: [1, 0],
    "keep-anchor-width": "",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.showDropdownContentComputed = $event),
    onKeydown: [
      withKeys(withModifiers(_ctx.showDropdown, ["stop", "prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop", "prevent"]), ["down"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop", "prevent"]), ["space"]),
      withKeys(withModifiers(_ctx.showDropdown, ["stop", "prevent"]), ["enter"])
    ],
    onClick: withModifiers(_ctx.onSelectClick, ["prevent"])
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select",
        "aria-label": "selected option",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        disabled: _ctx.$props.disabled,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-hidden": "false",
            "aria-label": "reset",
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["onClick", "onKeydown"])) : createCommentVNode("v-if", true)
        ]),
        appendInner: withCtx(() => [
          _ctx.$slots.appendInner ? renderSlot(_ctx.$slots, "appendInner", { key: 0 }) : createCommentVNode("v-if", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8, ["color", "name"])
        ]),
        default: withCtx(() => [
          _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_141, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
            valueString: _ctx.valueComputedString,
            value: _ctx.valueComputed,
            tabindex: _ctx.tabIndexComputed
          })), () => [
            createTextVNode(toDisplayString(_ctx.valueComputedString), 1)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prepend ? {
          name: "prepend",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prepend")
          ])
        } : void 0,
        _ctx.$slots.append ? {
          name: "append",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "append")
          ])
        } : void 0,
        _ctx.$slots.prependInner ? {
          name: "prependInner",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prependInner")
          ])
        } : void 0
      ]), 1032, ["model-value", "success", "error", "color", "label", "loading", "disabled", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width }),
        onKeyup: _cache[4] || (_cache[4] = withKeys(withModifiers(() => void 0, ["stop"]), ["enter"])),
        onKeydown: [
          _cache[5] || (_cache[5] = withKeys(withModifiers(() => void 0, ["stop", "prevent"]), ["tab"])),
          withKeys(withModifiers(_ctx.hideAndFocus, ["prevent"]), ["esc"])
        ]
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select__input",
            placeholder: "Search",
            "aria-label": "options filter",
            tabindex: _ctx.tabIndexComputed,
            bordered: true,
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            onKeydown: [
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["tabindex", "modelValue", "onKeydown"])) : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_222, [
            createVNode(_component_va_select_option_list, {
              ref: "optionList",
              hoveredOption: _ctx.hoveredOption,
              "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
              style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
              options: _ctx.filteredOptions,
              "selected-value": _ctx.valueComputed,
              "get-selected-state": _ctx.checkIsOptionSelected,
              "get-text": _ctx.getText,
              "get-track-by": _ctx.getTrackBy,
              "get-group-by": _ctx.getGroupBy,
              search: _ctx.searchInput,
              "no-options-text": _ctx.$props.noOptionsText,
              color: _ctx.$props.color,
              tabindex: _ctx.tabIndexComputed,
              onSelectOption: _ctx.selectOption,
              onNoPreviousOptionToHover: _ctx.focusSearchBar,
              onKeydown: [
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
                _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
                _ctx.onHintedSearch
              ],
              onScrollBottom: _ctx.onScrollBottom
            }, null, 8, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "get-text", "get-track-by", "get-group-by", "search", "no-options-text", "color", "tabindex", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
          ])
        ]),
        _: 1
      }, 8, ["style", "onKeydown"])
    ]),
    _: 3
  }, 8, ["placement", "disabled", "max-height", "fixed", "close-on-content-click", "modelValue", "onKeydown", "onClick"]);
}
script51.render = render52;
script51.__file = "src/components/va-select/VaSelect.vue";
var VaSelect = withConfigTransport(script51);

// node_modules/vuestic-ui/dist/esm/index47.js
var key = Symbol("VaSidebar");
var useSidebar = () => {
  const { props } = getCurrentInstance();
  provide(key, {
    color: toRef(props, "color")
  });
};
var useSidebarItem = () => {
  const { color } = inject(key, { color: ref("white") });
  return {
    sidebarColor: color
  };
};
var script$35 = defineComponent({
  name: "VaSidebar",
  props: {
    color: { type: String, default: "background" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    position: {
      type: String,
      default: "left",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true }
  },
  setup(props) {
    const { getColor } = useColors();
    useSidebar();
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const computedWidth = computed(() => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    });
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => {
      const backgroundColor = getColor(props.color);
      const background = props.gradient ? getGradientBackground(backgroundColor) : backgroundColor;
      const color = textColorComputed.value;
      return {
        color,
        background,
        width: computedWidth.value
      };
    });
    const computedClass = computed(() => ({
      "va-sidebar--minimized": isMinimized.value,
      "va-sidebar--right": props.position === "right"
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    return {
      computedClass,
      computedStyle,
      updateHoverState
    };
  }
});
var _hoisted_1$23 = { class: "va-sidebar__menu" };
function render$35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("aside", {
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.updateHoverState(false))
  }, [
    createBaseVNode("div", _hoisted_1$23, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 38);
}
script$35.render = render$35;
script$35.__file = "src/components/va-sidebar/VaSidebar.vue";
var script$26 = defineComponent({
  name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    borderColor: { type: String, default: void 0 }
  },
  setup(props) {
    const anchor = shallowRef();
    const { isHovered } = useHover(anchor);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { sidebarColor } = useSidebarItem();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      return getColor(sidebarColor.value);
    });
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const style = {
        color: props.textColor
      };
      if (props.active) {
        style.backgroundColor = backgroundColorComputed.value;
        style.color = textColorComputed.value;
        style.borderColor = getColor(props.borderColor || props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(getColor(props.hoverColor || props.activeColor));
      }
      return style;
    });
    const { tagComputed, hrefComputed } = useRouterLink(props);
    return {
      anchor,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered
    };
  }
});
function render$26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "anchor",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style", "href", "to"]);
}
script$26.render = render$26;
script$26.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItem.vue";
var script$111 = defineComponent({
  name: "VaSidebarItemContent"
});
var _hoisted_1$17 = { class: "va-sidebar__item__content va-sidebar-item-content" };
function render$110(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$17, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$111.render = render$110;
script$111.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.vue";
var script52 = defineComponent({
  name: "VaSidebarItemTitle"
});
var _hoisted_143 = { class: "va-sidebar__title va-sidebar-item-title" };
function render53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_143, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script52.render = render53;
script52.__file = "src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.vue";
var VaSidebarItemContent = withConfigTransport(script$111);
var VaSidebarItemTitle = withConfigTransport(script52);
var VaSidebarItem = withConfigTransport(script$26);
var VaSidebar = withConfigTransport(script$35);

// node_modules/vuestic-ui/dist/esm/index48.js
var validateSlider = (value, step, min, max, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max < min) {
    warn("The maximum value can not be less than the minimum value.");
  }
  if (min > max) {
    warn("The minimum value can not be greater than the maximum value.");
  }
  if ((max - min) % step !== 0) {
    warn("Step is illegal. Slider is nondivisible.");
  }
  const inRange = (v2) => {
    if (v2 < min) {
      warn(`The value of the slider is ${v2}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
    } else if (v2 > max) {
      warn(`The value of the slider is ${v2}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};
var script53 = defineComponent({
  name: "VaSlider",
  components: { VaIcon },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: {
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true }
  },
  setup(props, { emit }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size2 = ref(0);
    const currentValue = ref(props.modelValue);
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick_1(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val2}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val2}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range && index !== void 0 ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => props.modelValue,
      set: (val2) => {
        if (!props.range) {
          val2 = limitValue(val2);
        }
        if (!flag.value) {
          emit("change", val2);
        }
        emit("update:modelValue", val2);
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size2.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(props.modelValue) ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value] : (props.modelValue - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size2.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e2, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e2.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e2 ? e2.touches[0] : e2;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(props.modelValue)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(props.modelValue) ? (_a = dots.value[index]) === null || _a === void 0 ? void 0 : _a.focus() : (_b = dot.value) === null || _b === void 0 ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e2) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e2.preventDefault();
      if ("touches" in e2) {
        setValueOnPos(getPos(e2.touches[0]));
      } else {
        setValueOnPos(getPos(e2));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", props.modelValue);
        } else {
          return false;
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (isRange3, where, which) => {
        if (isRange3 && Array.isArray(val.value)) {
          if (!props.pins) {
            return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = val.value[which] / onePinInterval | 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value[which] !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value.splice(which, 1, nearestPinVal);
          } else {
            val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
        } else {
          if (!props.pins && !Array.isArray(val.value)) {
            val.value += where ? props.step : -props.step;
            return;
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value = nearestPinVal;
          } else {
            val.value += where ? props.step : -props.step;
          }
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a = dots.value[0]) === null || _a === void 0 ? void 0 : _a.focus();
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) === null || _b === void 0 ? void 0 : _b.focus();
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(true, 0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(true, 1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(false, 1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(false, 1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e2) => {
      getStaticData();
      return props.vertical ? offset.value - e2.clientY : e2.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size2.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
        if (isDiff(currentValue.value[slider], newValue)) {
          currentValue.value.splice(slider, 1, newValue);
          if (slider === 0) {
            val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
            currentValue.value = [...val.value];
          } else {
            val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
            currentValue.value = [...val.value];
          }
        }
      } else {
        if (newValue < props.min || newValue > props.max) {
          return false;
        }
        if (isDiff(currentValue.value, newValue)) {
          currentValue.value = newValue;
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(props.modelValue) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus === null || dotToFocus === void 0 ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value[1] = val.value[0];
            currentSliderDotIndex.value = 0;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value[0] = val.value[1];
            currentSliderDotIndex.value = 1;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const limitValue = (val2) => {
      const inRange = (v2) => {
        if (v2 < props.min) {
          return props.min;
        } else if (v2 > props.max) {
          return props.max;
        }
        return v2;
      };
      if (Array.isArray(val2)) {
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 0) {
          const v2 = inRange(val2[1]);
          return [v2, v2];
        }
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 1) {
          const v2 = inRange(val2[0]);
          return [v2, v2];
        }
        return val2.map((v2) => inRange(v2));
      } else {
        return inRange(val2);
      }
    };
    const isDiff = (a2, b2) => JSON.stringify(a2) !== JSON.stringify(b2);
    const clickOnContainer = (e2) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e2 ? getPos(e2.touches[0]) : getPos(e2);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e2, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      ariaValuemin: props.min,
      ariaValuemax: props.max,
      ariaLabelledby: ariaLabelIdComputed.value,
      ariaOrientation: props.vertical ? "vertical" : "horizontal",
      ariaDisabled: props.disabled,
      ariaReadonly: props.readonly,
      ariaValuenow: !Array.isArray(props.modelValue) ? props.modelValue : void 0
    }));
    onMounted(() => {
      if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value, step, min, max, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});
var _hoisted_144 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_223 = ["id"];
var _hoisted_314 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_49 = ["tabindex", "onFocus"];
var _hoisted_56 = ["tabindex"];
var _hoisted_65 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_73 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function render54(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_144, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("v-if", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_223)) : createCommentVNode("v-if", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_314, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onMouseup: _cache[4] || (_cache[4] = ($event) => _ctx.hasMouseDown = false),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createBaseVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("v-if", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("v-if", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("v-if", true)
          ], 46, _hoisted_49);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createBaseVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createBaseVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("v-if", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("v-if", true)
        ], 46, _hoisted_56)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_65, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("v-if", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 4)) : createCommentVNode("v-if", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_73, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("v-if", true)
  ], 16);
}
script53.render = render54;
script53.__file = "src/components/va-slider/VaSlider.vue";
var VaSlider = withConfigTransport(script53);

// node_modules/vuestic-ui/dist/esm/toast.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear2 = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear: clear2
  };
};
var VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props) => () => props.render()
});
var script54 = defineComponent({
  name: "VaToast",
  components: { VaIcon: script, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: {
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a, _b;
      (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) === null || _b === void 0 ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a;
      visible.value = false;
      (_a = rootElement.value) === null || _a === void 0 ? void 0 : _a.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return {
      visible,
      toastClasses,
      toastStyles,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    };
  }
});
var _hoisted_145 = ["role"];
var _hoisted_224 = { class: "va-toast__group" };
var _hoisted_315 = ["textContent"];
var _hoisted_410 = { class: "va-toast__content" };
var _hoisted_57 = ["innerHTML"];
var _hoisted_66 = ["textContent"];
var _hoisted_74 = {
  key: 1,
  class: "va-toast__content"
};
function render55(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? "alertdialog" : "alert",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createBaseVNode("div", _hoisted_224, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_315)) : createCommentVNode("v-if", true),
          withDirectives(createBaseVNode("div", _hoisted_410, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_57)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_66))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_74, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("v-if", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": "close toast",
            "aria-hidden": "false",
            tabindex: "0",
            size: "small",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["name", "onClick", "onKeydown"])) : createCommentVNode("v-if", true)
        ])
      ], 46, _hoisted_145), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
script54.render = render55;
script54.__file = "src/components/va-toast/VaToast.vue";
var useToast = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.appContext;
  const createdInThisSetupContext = [];
  const init = (options) => {
    const id = createToastInstance(options, appContext);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};
var VaToast = withConfigTransport(script54);
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a;
  return ((_a = vNode.component) === null || _a === void 0 ? void 0 : _a.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const { offsetX: targetOffsetX, offsetY: targetOffsetY, position: targetPosition } = nodeProps;
  const redundantHeight = (_a = targetInstance.el) === null || _a === void 0 ? void 0 : _a.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_2, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, { props, children, element, appContext } = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props === null || props === void 0 ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, { ...props, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a;
    return ((_a = instance.el) === null || _a === void 0 ? void 0 : _a.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const { offsetX: itemOffsetX, offsetY: itemOffsetY, position: itemPosition } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/esm/index50.js
var useResizeObserver = (elementsList, cb) => {
  const resizeObserver = ref();
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      var _a;
      const unrefedElement = unref(element);
      unrefedElement && ((_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    var _a;
    (_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver.value = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => {
    var _a;
    return (_a = resizeObserver.value) === null || _a === void 0 ? void 0 : _a.disconnect();
  });
  return resizeObserver;
};
var TabsViewKey = Symbol("TabsView");
var TabKey = Symbol("Tab");
var getClientWidth = (element) => (element === null || element === void 0 ? void 0 : element.clientWidth) || 0;
var script$112 = defineComponent({
  name: "VaTabs",
  components: { VaButton, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: {
    ...useStatefulProps,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "chevron_left" },
    nextIcon: { type: String, default: "chevron_right" }
  },
  setup: (props, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : ""
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
        tabsContentOffset.value = leftSidePosition;
      } else if (showPagination.value && rightSidePosition >= containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
      } else {
        tabsContentOffset.value = 0;
      }
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value) {
        moveToTab(tabsList.value[0]);
      }
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const currentTabLeftSidePosition = unref((_a = tabsList.value[i2]) === null || _a === void 0 ? void 0 : _a.leftSidePosition);
          const nextTabLeftSidePosition = unref((_b = tabsList.value[i2 + 1]) === null || _b === void 0 ? void 0 : _b.leftSidePosition);
          if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
            offsetToSet = currentTabLeftSidePosition;
            break;
          }
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const rightSidePosition2 = unref(tabsList.value[i2].rightSidePosition);
          if (rightSidePosition2 > containerRightSide) {
            offsetToSet = unref(tabsList.value[i2].leftSidePosition);
            if (tabsContentOffset.value < offsetToSet) {
              break;
            }
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) === null || _a === void 0 ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement === null || tabElement === void 0 ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const redrawTabs = () => {
      const oldShowPaginationValue = showPagination.value;
      updatePagination();
      if (oldShowPaginationValue === showPagination.value) {
        updateTabsState();
        includeAnimation();
      } else {
        requestAnimationFrame(() => {
          updateTabsState();
          includeAnimation();
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) === null || _a === void 0 ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) === null || _a === void 0 ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper, tabs], redrawTabs);
    return {
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      redrawTabs,
      selectTab
    };
  }
});
var _hoisted_1$18 = ["aria-disabled"];
var _hoisted_2$14 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_316 = [
  _hoisted_2$14
];
var _hoisted_411 = { class: "va-tabs__tabs-items" };
var _hoisted_58 = { class: "va-tabs__content" };
function render$111(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createBaseVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": "move pagination left",
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        flat: "",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["disabled", "color", "icon", "onClick"])) : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createBaseVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createBaseVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_316, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_411, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": "move pagination right",
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        flat: "",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["color", "disabled", "icon", "onClick"])) : createCommentVNode("v-if", true)
    ], 8, _hoisted_1$18),
    createBaseVNode("div", _hoisted_58, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
script$112.render = render$111;
script$112.__file = "src/components/va-tabs/VaTabs.vue";
var script55 = defineComponent({
  name: "VaTab",
  components: { VaIcon },
  emits: ["click", "keydown-enter", "focus"],
  props: {
    ...useRouterLinkProps,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  setup: (props, { emit }) => {
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const { parentDisabled, selectTab, moveToTab, registerTab, unregisterTab } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hasKeyboardFocus.value || hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a, _b;
      const componentOffsetLeft = ((_a = tabElement.value) === null || _a === void 0 ? void 0 : _a.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) === null || _b === void 0 ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return {
      tabElement,
      parentDisabled,
      isActive,
      hoverState,
      hasKeyboardFocus,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isActiveRouterLink,
      colorComputed,
      classComputed,
      computedStyle,
      tabIndexComputed,
      rightSidePosition,
      leftSidePosition,
      updateHoverState,
      updateSidePositions,
      onTabClick,
      onTabKeydown,
      onFocus
    };
  }
});
var _hoisted_146 = ["tabindex"];
var _hoisted_225 = ["textContent"];
function render56(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.updateHoverState(false))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({ class: "va-tab__content" }, toHandlers(_ctx.keyboardFocusListeners), {
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTabClick && _ctx.onTabClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onTabKeydown && _ctx.onTabKeydown(...args), ["enter"]))
      }), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-tab__icon",
            size: "small",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("v-if", true),
          createBaseVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8, _hoisted_225)
        ])
      ], 16, _hoisted_146)
    ]),
    _: 3
  }, 8, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
}
script55.render = render56;
script55.__file = "src/components/va-tabs/components/VaTab/VaTab.vue";
var VaTab = withConfigTransport(script55);
var VaTabs = withConfigTransport(script$112);

// node_modules/vuestic-ui/dist/esm/VaTimePicker.js
var safeModelValue = (m2) => m2.value ? m2.value : new Date(new Date().setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h3) => (h3 === 0 ? 12 : h3) - Number(h3 > 12) * 12;
var from12to24 = (h3, isAM = false) => (h3 === 12 ? 0 : h3) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i2) => props.hoursFilter(props.ampm ? i2 + 12 * Number(isPM.value) : i2));
    }
    return array.map((n2) => {
      return props.ampm ? from24to12(n2) : n2;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h4 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i2) => i2 === h4);
      }
      const h3 = modelValue.value.getHours();
      return items2.value.findIndex((i2) => i2 === h3);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m2 = modelValue.value.getMinutes();
      return items2.value.findIndex((i2) => i2 === m2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s2 = modelValue.value.getSeconds();
      return items2.value.findIndex((i2) => i2 === s2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h3 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h3 + 12 : h3;
        if (isPM.value && h3 <= 12) {
          h24 = h3 + 12;
        }
        if (!isPM.value && h3 >= 12) {
          h24 = h3 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};
var script$113 = defineComponent({
  name: "VaTimePickerColumn",
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        rootElement.value.scrollTo({
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n2) => {
      if (!Number.isInteger(n2)) {
        return n2;
      }
      return n2 < 10 ? `0${n2}` : `${n2}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max((scrollTop - scrollTop % props.cellHeight) / props.cellHeight, scrollTop / props.cellHeight);
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce_1(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      focus,
      blur
    };
  }
});
var _hoisted_147 = ["onClick"];
function render$112(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(), ["stop", "prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(5), ["stop", "prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.makeActivePrev(), ["stop", "prevent"]), ["up"]))
    ],
    onScrollPassive: _cache[3] || (_cache[3] = (...args) => _ctx.onScroll && _ctx.onScroll(...args)),
    onTouchmovePassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return openBlock(), createElementBlock("div", {
        key: item,
        class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
        onClick: ($event) => _ctx.onCellClick(index)
      }, [
        renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
          createTextVNode(toDisplayString(_ctx.formatCell(item)), 1)
        ])
      ], 10, _hoisted_147);
    }), 128))
  ], 544);
}
script$113.render = render$112;
script$113.__file = "src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue";
var VaTimePickerColumn = withConfigTransport(script$113);
var script56 = defineComponent({
  name: "VaTimePicker",
  components: { VaTimePickerColumn },
  props: {
    ...useStatefulProps,
    ...useFormProps,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a;
      (_a = pickers.value[idx]) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = (idx) => {
      var _a;
      idx ? (_a = pickers.value[idx]) === null || _a === void 0 ? void 0 : _a.blur() : pickers.value.forEach((el) => el === null || el === void 0 ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useForm("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex === null || activeColumnIndex === void 0 ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex === null || activeColumnIndex === void 0 ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
      return {
        height: `${props.cellHeight * props.visibleCellsCount}px`,
        "cell-height": `${props.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    return {
      columns,
      computedStyles,
      computedClasses,
      isPM,
      pickers,
      setItemRef,
      focusNext,
      focusPrev,
      activeColumnIndex,
      focus,
      blur
    };
  }
});
function render57(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["stop", "prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["stop", "prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
        ],
        onFocus: ($event) => _ctx.activeColumnIndex = idx
      }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
    }), 128))
  ], 6);
}
script56.render = render57;
script56.__file = "src/components/va-time-picker/VaTimePicker.vue";

// node_modules/vuestic-ui/dist/esm/index51.js
var parse = (text) => {
  const m2 = text.match(/[0-9]{1,2}/g);
  if (!m2) {
    return [];
  }
  return m2.map((s2) => Number(s2));
};
var parsePeriod = (text) => {
  const m2 = text.match(/pm|am/i);
  if (!m2) {
    return null;
  }
  return Number(m2[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d2 = new Date();
  const [h3, m2, s2] = parse(text);
  const period = parsePeriod(text);
  if (!h3) {
    return null;
  }
  const is12format = period !== null && h3 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h3 === 12 ? 0 : h3 : h3;
  d2.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d2.setMinutes(Math.min(m2 || 0, 60));
  d2.setSeconds(Math.min(s2 || 0, 60));
  return d2;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};
var VaInputProps2 = extractComponentProps(script27, [
  "mask",
  "returnRaw",
  "autosize",
  "minRows",
  "maxRows",
  "type",
  "inputmode",
  "counter",
  "maxLength"
]);
var script57 = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: script56, VaIcon: script, VaInput: script27 },
  emits: [...useValidationEmits, ...useClearableEmits, "update:modelValue", "update:isOpen"],
  props: {
    ...VaInputProps2,
    ...extractComponentProps(script56),
    ...useValidationProps,
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  },
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const onInputTextChanged = (val) => {
      if (!val) {
        return reset();
      }
      const v2 = parse2(val);
      if (isValid.value && v2) {
        modelValueSync.value = v2;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const focus = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = input.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    const { computedError, computedErrorMessages, listeners } = useValidation(props, emit, reset, focus);
    const { canBeCleared, clearIconProps, onFocus, onBlur } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small"
    }));
    const computedInputProps = computed(() => ({
      ...filterComponentProps(props, VaInputProps2).value,
      clearable: false,
      rules: [],
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        onBlur();
        listeners.onBlur();
      }
    }));
    const iconsTabIndexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const computedInputAttrs = computed(() => ({
      ariaLabel: props.label || "selected time",
      ariaDisabled: props.disabled,
      ariaReadonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      ...omit_1(attrs, ["class", "style"])
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      isOpenSync.value = false;
      focus();
    };
    const showDropdownWithoutFocus = () => {
      isOpenSync.value = true;
    };
    const showDropdown = (event, cancel, prevent) => {
      if (cancel) {
        return;
      }
      if (prevent) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
      }
      showDropdownWithoutFocus();
      nextTick(() => {
        var _a;
        return (_a = timePicker.value) === null || _a === void 0 ? void 0 : _a.focus();
      });
    };
    const toggleDropdown = () => {
      isOpenSync.value ? hideDropdown() : showDropdown();
    };
    const toggleDropdownWithoutFocus = () => {
      isOpenSync.value ? hideDropdown() : showDropdownWithoutFocus();
    };
    return {
      input,
      timePicker,
      timePickerProps: filterComponentProps(props, extractComponentProps(script56)),
      computedInputProps,
      computedInputAttrs,
      computedInputListeners,
      iconsTabIndexComputed,
      isOpenSync,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      toggleDropdownWithoutFocus,
      reset,
      focus,
      blur,
      onFocus,
      onBlur
    };
  }
});
function render58(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    class: normalizeClass(["va-time-input", _ctx.$attrs.class]),
    style: normalizeStyle(_ctx.$attrs.style),
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.isOpenSync = $event),
    placement: "bottom-start",
    offset: [2, 0],
    "close-on-content-click": false,
    disabled: _ctx.$props.disabled,
    anchorSelector: ".va-input-wrapper__field",
    stateful: false,
    trigger: "none",
    onKeydown: [
      withKeys(withModifiers(_ctx.showDropdown, ["prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.showDropdown, ["prevent"]), ["down"]),
      _cache[3] || (_cache[3] = withKeys(($event) => _ctx.showDropdown($event, _ctx.$props.manualInput, !_ctx.$props.manualInput), ["space"])),
      _cache[4] || (_cache[4] = withKeys(($event) => !_ctx.$props.manualInput && _ctx.showDropdown(), ["enter"])),
      withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
    ],
    onClick: _cache[5] || (_cache[5] = ($event) => (!_ctx.$props.manualInput || _ctx.isOpenSync) && _ctx.toggleDropdownWithoutFocus())
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input, mergeProps({ ref: "input" }, { ..._ctx.computedInputProps, ..._ctx.computedInputAttrs }, toHandlers(_ctx.computedInputListeners), {
        modelValue: _ctx.valueText,
        onChange: _cache[0] || (_cache[0] = ($event) => _ctx.onInputTextChanged($event.target.value))
      }), createSlots({
        prependInner: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))),
          _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            tabindex: _ctx.iconsTabIndexComputed
          }, _ctx.iconProps, {
            onClick: withModifiers(_ctx.toggleDropdown, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.toggleDropdown, ["stop"]), ["enter"])
          }), null, 16, ["tabindex", "onClick", "onKeydown"])) : createCommentVNode("v-if", true)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "reset",
            "aria-hidden": "false",
            tabindex: _ctx.iconsTabIndexComputed
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
            onFocus: _ctx.onFocus,
            onBlur: _ctx.onBlur
          }), null, 16, ["tabindex", "onClick", "onKeydown", "onFocus", "onBlur"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            class: "va-dropdown__icons__reset",
            tabindex: _ctx.iconsTabIndexComputed
          }, _ctx.iconProps, {
            onClick: withModifiers(_ctx.toggleDropdown, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.toggleDropdown, ["stop"]), ["enter"])
          }), null, 16, ["tabindex", "onClick", "onKeydown"])) : createCommentVNode("v-if", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))
            ])
          };
        })
      ]), 1040, ["modelValue"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 8, ["class", "style", "modelValue", "disabled", "onKeydown"]);
}
script57.render = render58;
script57.__file = "src/components/va-time-input/VaTimeInput.vue";
var VaTimeInput = withConfigTransport(script57);

// node_modules/vuestic-ui/dist/esm/index52.js
var VaTimePicker = withConfigTransport(script56);

// node_modules/vuestic-ui/dist/esm/index53.js
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a;
  return !!((_a = slot == null ? void 0 : slot.props) == null ? void 0 : _a.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a;
  const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME$1 = "va-timeline";
var script$27 = {
  name: COMPONENT_NAME$1,
  props: {
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h("div", {
      class: {
        [COMPONENT_NAME$1]: true,
        [`${COMPONENT_NAME$1}--vertical`]: props.vertical,
        [`${COMPONENT_NAME$1}--align-top`]: props.alignTop
      }
    }, processSlots({ props, slots }));
  }
};
script$27.__file = "src/components/va-timeline/VaTimeline.vue";
var componentName2 = "va-timeline-separator";
var script$114 = defineComponent({
  name: componentName2,
  props: {
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h("div", {
      class: {
        [componentName2]: true,
        [`${componentName2}--vertical`]: props.vertical
      }
    }, [
      h("div", {
        class: {
          [`${componentName2}__line`]: true,
          [`${componentName2}__line--active`]: props.activePrevious
        },
        style: {
          backgroundColor: getColor(props.activePrevious ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName2}__center`]: true,
          [`${componentName2}__center--active`]: props.active
        },
        style: {
          backgroundColor: getColor(props.active ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName2}__line`]: true,
          [`${componentName2}__line--active`]: props.activeNext
        },
        style: {
          backgroundColor: getColor(props.activeNext ? props.color : "divider")
        }
      })
    ]);
  }
});
script$114.__file = "src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.vue";
var VaTimelineSeparator = withConfigTransport(script$114);
var COMPONENT_NAME = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var script58 = defineComponent({
  name: COMPONENT_NAME,
  props: {
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props, { slots }) {
    const children = [
      h(VaTimelineSeparator, { ...filterComponentProps(props, VaTimelineSeparatorProps).value })
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(h("div", { class: `${COMPONENT_NAME}__before` }, before()));
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(h("div", { class: `${COMPONENT_NAME}__after` }, after()));
    }
    return () => h("div", {
      class: [
        { [COMPONENT_NAME]: true },
        { [`${COMPONENT_NAME}--vertical`]: props.vertical },
        { [`${COMPONENT_NAME}--is-first`]: props.isFirst },
        { [`${COMPONENT_NAME}--is-last`]: props.isLast }
      ]
    }, children);
  }
});
script58.__file = "src/components/va-timeline/VaTimelineItem/VaTimelineItem.vue";
var VaTimelineItem = withConfigTransport(script58);
var VaTimeline = withConfigTransport(script$27);

// node_modules/vuestic-ui/dist/esm/index54.js
var TreeViewKey = Symbol("TreeView");
var TreeCategoryKey = Symbol("TreeCategory");
var TreeNodeKey = Symbol("TreeNode");
var script$36 = defineComponent({
  name: "VaTreeView",
  props: {
    color: {
      type: String,
      default: ""
    }
  },
  setup: (props) => {
    const categories = ref([]);
    const collapse = () => {
      nextTick(() => {
        categories.value.forEach((child) => {
          child.collapse();
        });
      });
    };
    const expand = () => {
      nextTick(() => {
        categories.value.forEach((child) => {
          child.expand();
        });
      });
    };
    const onChildMounted = (category) => {
      categories.value.push(category);
    };
    const onChildUnmounted = (removableCategory) => {
      categories.value = categories.value.filter((category) => category !== removableCategory);
    };
    const treeView = {
      color: props.color,
      onChildMounted,
      onChildUnmounted
    };
    provide(TreeViewKey, treeView);
    return {
      collapse,
      expand,
      ...useColors()
    };
  }
});
var _hoisted_1$24 = { class: "va-tree-view" };
function render$36(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$24, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$36.render = render$36;
script$36.__file = "src/components/va-tree-view/VaTreeView.vue";
var script$28 = defineComponent({
  name: "VaTreeNode",
  components: { VaIcon },
  props: {
    highlighted: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ""
    },
    iconRight: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(props) {
    const { getColor } = useColors();
    const treeCategory = inject(TreeCategoryKey, {
      onChildMounted: (value) => void 0,
      onChildUnmounted: (value) => void 0
    });
    provide(TreeNodeKey, {
      props: computed(() => props)
    });
    onMounted(() => treeCategory && treeCategory.onChildMounted(TreeNodeKey));
    onBeforeUnmount(() => treeCategory && treeCategory.onChildUnmounted(TreeNodeKey));
    return {
      treeCategory,
      getColor
    };
  }
});
var _hoisted_1$19 = {
  key: 0,
  class: "va-tree-node__checkbox"
};
var _hoisted_2$15 = {
  key: 1,
  class: "va-tree-node__icon"
};
var _hoisted_3$12 = { class: "va-tree-node__label" };
var _hoisted_4$1 = {
  key: 2,
  class: "va-tree-node__icon-right",
  size: 24
};
function render$27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tree-node", { "va-tree-node--highlighted": _ctx.$props.highlighted }])
  }, [
    _ctx.$slots.checkbox ? (openBlock(), createElementBlock("div", _hoisted_1$19, [
      renderSlot(_ctx.$slots, "checkbox")
    ])) : createCommentVNode("v-if", true),
    _ctx.$props.icon ? (openBlock(), createElementBlock("div", _hoisted_2$15, [
      createVNode(_component_va_icon, {
        name: _ctx.$props.icon,
        color: _ctx.getColor("info"),
        size: 24
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("div", _hoisted_3$12, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.$props.iconRight ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
      createVNode(_component_va_icon, {
        name: _ctx.$props.iconRight,
        color: _ctx.getColor("info")
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("v-if", true)
  ], 2);
}
script$28.render = render$27;
script$28.__file = "src/components/va-tree-view/VaTreeNode/VaTreeNode.vue";
var VaTreeNode = withConfigTransport(script$28);
var script$115 = defineComponent({
  name: "SquareWithIcon",
  components: { VaIcon },
  props: {
    icon: {
      type: String,
      default: "",
      required: true
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return {
      colorComputed
    };
  }
});
function render$113(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "square-with-icon",
    style: normalizeStyle({ backgroundColor: _ctx.colorComputed })
  }, [
    createVNode(_component_va_icon, {
      name: _ctx.$props.icon
    }, null, 8, ["name"])
  ], 4);
}
script$115.render = render$113;
script$115.__file = "src/components/va-tree-view/SquareWithIcon/SquareWithIcon.vue";
var script59 = defineComponent({
  name: "VaTreeCategory",
  components: {
    SquareWithIcon: script$115,
    VaIcon: script
  },
  props: {
    label: {
      type: [String, Number],
      default: ""
    },
    isOpen: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup: (props) => {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const nodes = ref([]);
    const isOpenCached = ref(false);
    const onChildMounted = (node) => {
      nodes.value.push(node);
    };
    const onChildUnmounted = (removableNode) => {
      nodes.value = nodes.value.filter((node) => node !== removableNode);
    };
    const treeView = inject(TreeViewKey, {
      onChildMounted: (value) => void 0,
      onChildUnmounted: (value) => void 0
    });
    const collapse = () => {
      isOpenCached.value = false;
      nextTick(() => {
        nodes.value.forEach((child) => {
          if (child.$options.name === "va-tree-category") {
            child.collapse();
          }
        });
      });
    };
    const expand = () => {
      isOpenCached.value = true;
      nextTick(() => {
        nodes.value.forEach((child) => {
          var _a;
          (_a = child.expand) === null || _a === void 0 ? void 0 : _a.call(child);
        });
      });
    };
    const toggle = (e2) => {
      if (!e2.target.classList.contains("va-checkbox__input")) {
        isOpenCached.value = !isOpenCached.value;
      }
    };
    watch(() => props.isOpen, (isOpen) => {
      isOpenCached.value = isOpen;
    }, { immediate: true });
    const treeCategory = {
      treeView,
      nodes: nodes.value,
      isOpenCached: isOpenCached.value,
      onChildMounted,
      onChildUnmounted,
      collapse,
      expand,
      toggle
    };
    provide(TreeCategoryKey, treeCategory);
    onMounted(() => treeView === null || treeView === void 0 ? void 0 : treeView.onChildMounted(treeCategory));
    onBeforeUnmount(() => treeView === null || treeView === void 0 ? void 0 : treeView.onChildUnmounted(treeCategory));
    return {
      treeCategory,
      treeView,
      nodes,
      isOpenCached,
      collapse,
      expand,
      toggle,
      getColor,
      colorComputed
    };
  }
});
var _hoisted_148 = { class: "va-tree-category" };
var _hoisted_226 = { class: "va-tree-category__header-switcher" };
var _hoisted_317 = {
  key: 0,
  class: "va-tree-category__header-checkbox"
};
var _hoisted_412 = {
  key: 1,
  class: "va-tree-category__header-icon"
};
var _hoisted_59 = { class: "va-tree-category__header-label" };
var _hoisted_67 = {
  key: 0,
  class: "va-tree-category__list-container"
};
var _hoisted_75 = { class: "va-tree-category__list-internal-container" };
function render59(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_square_with_icon = resolveComponent("square-with-icon");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_148, [
    createBaseVNode("div", {
      class: "va-tree-category__header",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args))
    }, [
      createBaseVNode("div", _hoisted_226, [
        createVNode(_component_square_with_icon, {
          icon: _ctx.isOpenCached ? "remove" : "add",
          color: _ctx.colorComputed
        }, null, 8, ["icon", "color"])
      ]),
      _ctx.$slots.checkbox ? (openBlock(), createElementBlock("div", _hoisted_317, [
        renderSlot(_ctx.$slots, "checkbox")
      ])) : createCommentVNode("v-if", true),
      _ctx.$props.icon ? (openBlock(), createElementBlock("div", _hoisted_412, [
        createVNode(_component_va_icon, {
          name: _ctx.$props.icon,
          color: _ctx.getColor("info")
        }, null, 8, ["name", "color"])
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_59, toDisplayString(_ctx.$props.label), 1)
    ]),
    _ctx.isOpenCached ? (openBlock(), createElementBlock("div", _hoisted_67, [
      createBaseVNode("div", _hoisted_75, [
        renderSlot(_ctx.$slots, "default")
      ])
    ])) : createCommentVNode("v-if", true)
  ]);
}
script59.render = render59;
script59.__file = "src/components/va-tree-view/VaTreeCategory/VaTreeCategory.vue";
var VaTreeCategory = withConfigTransport(script59);
var VaTreeView = withConfigTransport(script$36);

// node_modules/vuestic-ui/dist/esm/VaSeparator.vue_vue_type_script_lang.js
var script60 = defineComponent({
  name: "VaSeparator"
});

// node_modules/vuestic-ui/dist/esm/VaSeparator.js
var _hoisted_149 = {
  class: "va-separator",
  "aria-hidden": "true"
};
function render60(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_149);
}
script60.render = render60;
script60.__file = "src/components/va-separator/VaSeparator.vue";

// node_modules/vuestic-ui/dist/esm/VaSpacer.vue_vue_type_script_lang.js
var script61 = defineComponent({
  name: "VaSpacer"
});

// node_modules/vuestic-ui/dist/esm/VaSpacer.js
var _hoisted_150 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
function render61(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_150);
}
script61.render = render61;
script61.__file = "src/components/va-spacer/VaSpacer.vue";

// node_modules/vuestic-ui/dist/esm/index55.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/esm/index65.js
var GlobalConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    const globalConfig = createGlobalConfig();
    if (config) {
      globalConfig.mergeGlobalConfig(config);
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));
var setCSSVariable = (name, value, root3) => {
  root3.style.setProperty(`--va-${name}`, value);
};
var createColorConfigPlugin = (app) => {
  const globalConfig = getGlobalProperty(app, "$vaConfig").globalConfig;
  const renderCSSVarialbes = (colors = globalConfig.value.colors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    return colorNames.map((key2) => `--va-${key2}: ${colors[key2]}`).join(";");
  };
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const root3 = document.documentElement;
    const colorNames = Object.keys(newValue);
    colorNames.forEach((key2) => {
      setCSSVariable(key2, newValue[key2], root3);
    });
  };
  updateColors(globalConfig.value.colors);
  watch(() => globalConfig.value.colors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return { renderCSSVarialbes, updateColors };
};
var ColorConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/esm/modal.js
var getNodeProps2 = (vNode) => {
  var _a;
  return ((_a = vNode.component) === null || _a === void 0 ? void 0 : _a.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  var _a;
  const el = document === null || document === void 0 ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props === null || props === void 0 ? void 0 : props.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props === null || props === void 0 ? void 0 : props["onUpdate:modelValue"]) === null || _a2 === void 0 ? void 0 : _a2.call(props, value);
    if ((props === null || props === void 0 ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, {
    ...props,
    stateful: (_a = props === null || props === void 0 ? void 0 : props.stateful) !== null && _a !== void 0 ? _a : true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/esm/index66.js
var createVaToastPlugin = (app) => ({
  init(options) {
    return createToastInstance(options, app === null || app === void 0 ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app === null || app === void 0 ? void 0 : app._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));
var createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app === null || app === void 0 ? void 0 : app._context);
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/esm/vuestic-components2.js
var vuesticComponentMap = Object.freeze({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaSelect,
  VaSeparator: script60,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer: script61,
  VaSwitch,
  VaTabs,
  VaTab,
  VaTimeInput,
  VaTimeline,
  VaTimelineItem,
  VaTimePicker,
  VaTreeCategory,
  VaTreeNode,
  VaTreeRoot: VaTreeView,
  VaTreeView
});

// node_modules/vuestic-ui/dist/esm/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/esm/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    Object.entries(vuesticComponentMap).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, ColorConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
  }
}));

// node_modules/vuestic-ui/dist/esm/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config, components, plugins } = options;
    usePlugin(app, (plugins === null || plugins === void 0 ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app, (plugins === null || plugins === void 0 ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app.component(name, component);
      });
    }
  }
}));

// node_modules/vuestic-ui/dist/esm/vuestic-plugin.js
var VuesticPlugin = {
  install(app, vuesticConfig) {
    app.use(GlobalConfigPlugin(vuesticConfig));
    app.use(ColorConfigPlugin());
    Object.entries(vuesticComponentMap).forEach(([name, component]) => {
      app.component(name, component);
    });
    app.use(VaDropdownPlugin());
    app.use(VaToastPlugin());
    app.use(VaModalPlugin());
  }
};

// node_modules/vuestic-ui/dist/esm/vuestic-plugin-without-components.js
var VuesticPluginsWithoutComponents = {
  install(app, vuesticConfig) {
    app.use(VaDropdownPlugin());
    app.use(VaToastPlugin());
    app.use(VaModalPlugin);
    app.use(GlobalConfigPlugin(vuesticConfig));
    app.use(ColorConfigPlugin());
  }
};

// node_modules/vuestic-ui/dist/esm/useModal.js
var useModal = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  return { init };
};
export {
  ColorConfigPlugin,
  GlobalConfigPlugin,
  TabKey,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  script26 as VaInputWrapper,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  script21 as VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaSelect,
  VaSelectOptionList,
  script60 as VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  script61 as VaSpacer,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeCategory,
  VaTreeNode,
  VaTreeView,
  VuesticIconAliases,
  VuesticIconFonts,
  VuesticPlugin,
  VuesticPluginsWithoutComponents,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  useColors,
  useGlobalConfig,
  useIcons,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui.js.map
